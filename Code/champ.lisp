;;; -*- Mode: Lisp; Package: FSet; Syntax: ANSI-Common-Lisp -*-

;;; File: champ.lisp
;;; Contents: CHAMP implementation for FSet.
;;; See: https://michael.steindorfer.name/publications/phd-thesis-efficient-immutable-collections.pdf
;;;
;;; This file is part of FSet.  Copyright (c) 2024-2025 Scott L. Burson.
;;; FSet is licensed under the 2-clause BSD license; see LICENSE.
;;; This license provides NO WARRANTY.

(in-package :fset)

#||

Our implementation differs slightly from the published CHAMP algorithm.  It is agnostic as to the
number of bits in the hash values; it will use as many as are provided, up to the fixnum size.  A
collision can be detected at any level, when two members/keys hash to the same value but `equal?'
is false on them.  When that happens, we fall back to using a WB-tree for those entries.  The
resulting collision node will be as high in the tree as possible given that it can contain only
keys with that hash value; this can require pushing it down an arbitrary number of levels when
adding a new key.

As Steindorfer recommends, we do go to the trouble to canonicalize on deletion, so that the shape of
the tree is a function of the members/keys, i.e., is independent of how the tree was constructed.
The two-tree algorithms (`compare', `union', etc.) take considerable advantage of this fact.

||#


;;; ================================================================================
;;; Global constants

;;; `eval-when' needed in Allegro to make the `deftype' work.
(eval-when (:compile-toplevel :load-toplevel :execute)
  (defconstant champ-hash-bits-per-level
    ;; Drops to 4 on 32-bit implementations.
    (min 5 (- (integer-length (1+ (* 2 (integer-length most-positive-fixnum)))) 2)))
  (defconstant champ-node-radix (ash 1 champ-hash-bits-per-level))
  (defconstant champ-hash-level-mask (1- champ-node-radix)))
(deftype champ-bit-index () `(integer 0 ,(1- champ-node-radix)))
;;; These have the same bounds but are logically different types.
(deftype champ-entry-index () `(integer 0 ,(1- champ-node-radix)))
(deftype champ-subnode-index () `(integer 0 ,(1- champ-node-radix)))

(declaim (inline champ-hash-bits)
	 (ftype (function (fixnum fixnum) champ-bit-index) champ-hash-bits))
(defun champ-hash-bits (hash depth)
  (ldb (byte champ-hash-bits-per-level (* depth champ-hash-bits-per-level))
       hash))

(declaim (inline 1-bits-below))
(defun 1-bits-below (idx mask)
  "The number of 1 bits in `mask' at bit positions (strictly) less than `idx'."
  (declare (optimize (speed 3))
	   (type champ-bit-index idx)
	   (fixnum mask))
  (logcount (logand (1- (the fixnum (ash 1 idx))) mask)))

(declaim (inline least-1-bit))
(defun least-1-bit (n)
  (declare (fixnum n))
  (1- (logcount (logxor n (1- n)))))

(defmacro do-bit-indices ((idx-var val &optional result) &body body)
  (let ((val-var (gensymx #:val-)))
    `(let ((,val-var ,val))
       (declare (fixnum ,val-var))
       (do ((,idx-var (least-1-bit ,val-var) (least-1-bit ,val-var)))
	   ((= 0 ,val-var) ,result)
	 (logandc2f ,val-var (ash 1 ,idx-var))
	. ,body))))

;;; Verification utility, used to recover hash bits from masks.
(defun bit-indices (mask)
  "A list of the indices of the 1 bits of `mask', in ascending order."
  (let ((result nil))
    (do-bit-indices (i mask (nreverse result))
      (push i result))))


;;; Although we tell people that the hash function must return a fixnum, we
;;; have no way to enforce that, so just to be sure, we check the return value.
;;; A fixnum test is pretty cheap on most platforms.
(defmacro hash-to-fixnum (val hash-fn)
  `(let ((h (funcall ,hash-fn ,val)))
     (if (typep h 'fixnum)
	 h
       (the fixnum (squash-bignum-hash h)))))


;;; ================================================================================
;;; Sets

(defstruct (ch-set-node
	     (:type vector))
  ;; It's more convenient for these slots to be mutable... since the nodes are just vectors anyway, we
  ;; can't completely prevent a client from stupidly bashing them.
  (entry-mask 0 :type fixnum)
  (subnode-mask 0 :type fixnum)
  (size 0 :type fixnum) ; total number of elements at or below this node
  (hash-value 0 :type fixnum))
(defconstant ch-set-node-header-size 4)

(deftype ch-set-tree ()
  '(or null cons simple-vector))

(declaim (inline ch-set-tree-size))
(defun ch-set-tree-size (tree)
  (cond ((null tree) 0)
	((consp tree)
	 (wb-set-tree-size (cdr tree)))
	(t (ch-set-node-size tree))))

(declaim (inline ch-set-tree-hash-value))
(defun ch-set-tree-hash-value (tree)
  (cond ((null tree) 0)
	((consp tree) (the fixnum (car tree)))
	(t (ch-set-node-hash-value tree))))

(defun ch-set-tree-with (tree value hash-fn compare-fn &optional (depth 0))
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn)
	   (type (integer 0 64) depth))
  (let ((value-hash (hash-to-fixnum value hash-fn)))
    (declare (fixnum value-hash))
    (rlabels (rec tree (ash value-hash (- (* champ-hash-bits-per-level depth))) depth)
      (rec (node hash-shifted depth &optional node-hash)
	(declare (fixnum hash-shifted)
		 (type (integer 0 64) depth)
		 (type (or null fixnum) node-hash))
	(let ((hash-bits (logand hash-shifted champ-hash-level-mask)))
	  (if (null node)
	      (vector (ash 1 hash-bits) 0 1 value-hash value)
	    (if (consp node)
		;; We can create collision nodes at any level (see below).  -- Well, not at the root.  But
		;; this is called from elsewhere (e.g. `-union') on subtrees, which might be collision nodes.
		(let ((node-hash (or node-hash (hash-to-fixnum (wb-set-tree-arb (cdr node)) hash-fn)))
		      ((wb-hash-shifted (ash node-hash (- (* champ-hash-bits-per-level depth)))))
		      (size (1+ (wb-set-tree-size (cdr node)))))
		  (declare (fixnum wb-hash-shifted hash-shifted size))
		  (if (= hash-shifted wb-hash-shifted)
		      ;; Update the collision node.
		      (let ((new-wb-tree (wb-set-tree-with (cdr node) value compare-fn)))
			(if (eq new-wb-tree (cdr node))
			    node
			  ;; New entry in collision node
			  (cons (car node) new-wb-tree)))
		    (let ((hash-bits (logand hash-shifted champ-hash-level-mask))
			  (wb-hash-bits (logand wb-hash-shifted champ-hash-level-mask))
			  (content-hash (hash-mix (car node) value-hash)))
		      (if (= hash-bits wb-hash-bits)
			  (vector 0 (ash 1 hash-bits) size content-hash
				  (rec node (ash hash-shifted (- champ-hash-bits-per-level)) (1+ depth) node-hash))
			(vector (ash 1 hash-bits) (ash 1 wb-hash-bits) size content-hash
				value node)))))
	      ;; Normal case
	      (let ((entry-mask (ch-set-node-entry-mask node))
		    ((entry-raw-idx (1-bits-below hash-bits entry-mask))
		     ((entry-idx (+ ch-set-node-header-size entry-raw-idx))))
		    (subnode-mask (ch-set-node-subnode-mask node))
		    ((subnode-raw-idx (1-bits-below hash-bits subnode-mask))
		     ((subnode-idx (- (the fixnum (length node)) 1 subnode-raw-idx)))))
		(declare (fixnum entry-mask entry-raw-idx entry-idx subnode-mask subnode-raw-idx subnode-idx))
		(if (logbitp hash-bits entry-mask)
		    ;; Entry found
		    (let ((ex-value (svref node entry-idx)))
		      (if (equal?-cmp value ex-value compare-fn)
			  node
			;; Entry with different value found: make a subnode
			(let ((hash-shifted (ash hash-shifted (- champ-hash-bits-per-level)))
			      (ex-value-hash (hash-to-fixnum ex-value hash-fn))
			      ((ex-value-hash-shifted (ash ex-value-hash (* (- champ-hash-bits-per-level) (1+ depth))))
			       ((n2 (if (= hash-shifted ex-value-hash-shifted)
					;; Collision!  Fall back to WB-tree.
					(cons value-hash (wb-set-tree-with (wb-set-tree-with nil ex-value compare-fn)
									   value compare-fn))
				      ;; Turn the entry into a subnode and recur.
				      (rec (vector (ash 1 (logand ex-value-hash-shifted champ-hash-level-mask))
						   0 1 ex-value-hash ex-value)
					   hash-shifted (1+ depth))))
				;; The `1+' is because we're inserting _after_ `subnode-idx', because the subnodes
				;; are in reverse order.
				((n (vector-rem-1-ins-1 node entry-idx (1+ subnode-idx) n2))))))
			  (logandc2f (ch-set-node-entry-mask n) (ash 1 hash-bits))
			  (logiorf (ch-set-node-subnode-mask n) (ash 1 hash-bits))
			  (incf (ch-set-node-size n))
			  (unless (consp n2)
			    (hash-mixf (ch-set-node-hash-value n) value-hash))
			  n)))
		  ;; No entry found: check for subnode
		  (if (logbitp hash-bits subnode-mask)
		      ;; Subnode found
		      (let ((subnode (svref node subnode-idx))
			    ((new-subnode (rec subnode (ash hash-shifted (- champ-hash-bits-per-level)) (1+ depth)))))
			(if (eq new-subnode subnode)
			    node ; no change
			  ;; New subnode
			  (let ((n (vector-update node subnode-idx new-subnode)))
			    (setf (ch-set-node-size n)
				  (the fixnum (+ (ch-set-node-size n) (- (the fixnum (ch-set-tree-size new-subnode))
									 (the fixnum (ch-set-tree-size subnode))))))
			    (hash-mixf (ch-set-node-hash-value n) (hash-unmix (ch-set-tree-hash-value new-subnode)
									      (ch-set-tree-hash-value subnode)))
			    n)))
		    ;; Neither entry nor subnode found: make new entry
		    (let ((n (vector-insert node entry-idx value)))
		      (logiorf (ch-set-node-entry-mask n) (ash 1 hash-bits))
		      (incf (ch-set-node-size n))
		      (hash-mixf (ch-set-node-hash-value n) value-hash)
		      n)))))))))))

(defun vector-rem-1-ins-1 (vec rem-idx ins-idx ins-val)
  (declare (optimize (speed 3) (safety 0))
	   (simple-vector vec)
	   (fixnum rem-idx ins-idx))
  (assert (<= rem-idx (the fixnum (1- ins-idx))))
  (let ((len (length vec))
	((v (make-array len))))
    (declare (fixnum len))
    (dotimes (i rem-idx)
      (setf (svref v i) (svref vec i)))
    (dotimes (i (- ins-idx rem-idx 1))
      (declare (fixnum i))
      (setf (svref v (+ rem-idx i)) (svref vec (+ rem-idx i 1))))
    (setf (svref v (1- ins-idx)) ins-val)
    (dotimes (i (- len ins-idx))
      (declare (fixnum i))
      (setf (svref v (+ ins-idx i)) (svref vec (+ ins-idx i))))
    v))

(defun ch-set-tree-less (tree value hash-fn compare-fn &optional (depth 0))
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn)
	   (type (integer 0 64) depth))
  (let ((value-hash (hash-to-fixnum value hash-fn)))
    (declare (fixnum value-hash))
    (rlabels (rec tree (ash value-hash (- (* champ-hash-bits-per-level depth))))
      (rec (node hash-shifted)
	(declare (fixnum hash-shifted))
	(and node
	     (if (consp node)
		 (let ((new-wb-tree (wb-set-tree-less (cdr node) value compare-fn)))
		   (if (eq new-wb-tree (cdr node))
		       node
		     (if (= 1 (wb-set-tree-size new-wb-tree))
			 ;; Removing next-to-last entry of collision node: turn remaining value into entry
			 (let ((rem-val (wb-set-tree-arb new-wb-tree))
			       (hash-bits (logand hash-shifted champ-hash-level-mask)))
			   (vector (ash 1 hash-bits) 0 1 value-hash rem-val))
		       (cons (car node) new-wb-tree))))
	       (let ((hash-bits (logand hash-shifted champ-hash-level-mask))
		     (entry-mask (ch-set-node-entry-mask node))
		     ((entry-raw-idx (1-bits-below hash-bits entry-mask))
		      ((entry-idx (+ ch-set-node-header-size entry-raw-idx))))
		     (subnode-mask (ch-set-node-subnode-mask node)))
		 (if (logbitp hash-bits entry-mask)
		     (let ((ex-value (svref node entry-idx)))
		       (cond ((not (equal?-cmp ex-value value compare-fn))
			      node)
			     ((and (= (logcount entry-mask) 1) (= 0 subnode-mask))
			      (assert (= depth 0))
			      nil)
			     (t
			      (let ((n (vector-remove-at node entry-idx)))
				(logandc2f (ch-set-node-entry-mask n) (ash 1 hash-bits))
				(decf (ch-set-node-size n))
				(hash-unmixf (ch-set-node-hash-value n) value-hash)
				n))))
		   (let ((subnode-raw-idx (1-bits-below hash-bits subnode-mask))
			 ((subnode-idx (- (length node) 1 subnode-raw-idx))))
		     (if (not (logbitp hash-bits subnode-mask))
			 node
		       (let ((subnode (svref node subnode-idx))
			     ((new-subnode (rec subnode (ash hash-shifted (- champ-hash-bits-per-level))))))
			 (if (eq new-subnode subnode)
			     node
			   (let ((n (cond ((consp new-subnode)
					   (vector-update node subnode-idx new-subnode))
					  ((and (= 1 (logcount (ch-set-node-entry-mask new-subnode)))
						(= 0 (ch-set-node-subnode-mask new-subnode)))
					   ;; New subnode contains only a single entry: pull it up into this node
					   (let ((new-entry-idx
						   (+ ch-set-node-header-size (1-bits-below hash-bits entry-mask)))
						 ((n (vector-ins-1-rem-1 node new-entry-idx
									 (svref new-subnode ch-set-node-header-size)
									 subnode-idx))))
					     (logiorf (ch-set-node-entry-mask n) (ash 1 hash-bits))
					     (logandc2f (ch-set-node-subnode-mask n) (ash 1 hash-bits))
					     n))
					  ((and (= 0 (ch-set-node-entry-mask new-subnode))
						(= 1 (logcount (ch-set-node-subnode-mask new-subnode)))
						(consp (svref new-subnode ch-set-node-header-size)))
					   ;; New subnode contains only a collision node: pull it up into this node
					   (vector-update node subnode-idx
							  (svref new-subnode ch-set-node-header-size)))
					  (t (vector-update node subnode-idx new-subnode)))))
			     (decf (ch-set-node-size n))
			     (hash-mixf (ch-set-node-hash-value n) (hash-unmix (ch-set-tree-hash-value new-subnode)
									       (ch-set-tree-hash-value subnode)))
			     n)))))))))))))

(defun vector-ins-1-rem-1 (vec ins-idx ins-val rem-idx)
  (declare (optimize (speed 3) (safety 0))
	   (simple-vector vec)
	   (fixnum ins-idx rem-idx))
  (assert (<= ins-idx rem-idx))
  (let ((v (make-array (length vec))))
    (dotimes (i ins-idx)
      (setf (svref v i) (svref vec i)))
    (setf (svref v ins-idx) ins-val)
    (dotimes (i (- rem-idx ins-idx))
      (setf (svref v (+ ins-idx i 1)) (svref vec (+ ins-idx i))))
    (dotimes (i (- (length vec) rem-idx 1))
      (declare (fixnum i))
      (setf (svref v (+ rem-idx i 1)) (svref vec (+ rem-idx i 1))))
    v))

(defun ch-set-tree-arb (tree)
  (declare (optimize (speed 3) (safety 0)))
  (cond ((null tree)
	 (error "'ch-set-tree-arb' called on empty tree"))
	((consp tree)
	 (wb-set-tree-arb (cdr tree)))
	((= 0 (ch-set-node-entry-mask tree))
	 ;; If there are no entries, there must be at least one subnode
	 (ch-set-tree-arb (svref tree (1- (length tree)))))
	(t
	 (svref tree ch-set-node-header-size))))

(defun ch-set-tree-contains? (tree value hash-fn compare-fn &optional (depth 0))
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn)
	   (type (integer 0 64) depth))
  (let ((value-hash (hash-to-fixnum value hash-fn)))
    (declare (fixnum value-hash))
    (rlabels (rec tree value (ash value-hash (- (* champ-hash-bits-per-level depth))))
      (rec (node value hash-shifted)
	(declare (fixnum hash-shifted))
	(and node
	     (if (consp node)
		 (wb-set-tree-find-equal (cdr node) value compare-fn)
	       (let ((hash-bits (logand hash-shifted champ-hash-level-mask))
		     (entry-mask (ch-set-node-entry-mask node)))
		 (if (logbitp hash-bits entry-mask)
		     (let ((entry-idx (+ ch-set-node-header-size (1-bits-below hash-bits entry-mask)))
			   ((ex-value (svref node entry-idx))))
		       (and (equal?-cmp ex-value value compare-fn)
			    (values t ex-value)))
		   (let ((subnode-mask (ch-set-node-subnode-mask node)))
		     (and (logbitp hash-bits subnode-mask)
			  (let ((subnode-idx (- (length node) 1 (1-bits-below hash-bits subnode-mask)))
				((subnode (svref node subnode-idx))))
			    (rec subnode value (ash hash-shifted (- champ-hash-bits-per-level))))))))))))))

(defun ch-set-tree-compare (tree1 tree2 compare-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function compare-fn))
  (if (eq tree1 tree2) ':equal
    (let ((size1 (ch-set-tree-size tree1))
	  (size2 (ch-set-tree-size tree2)))
      ;; There are various ways we could do this, but traditionally, FSet sorts on size first.
      (cond ((< size1 size2) ':less)
	    ((> size1 size2) ':greater)
	    (t
	     (let ((hash1 (ch-set-tree-hash-value tree1))
		   (hash2 (ch-set-tree-hash-value tree2)))
	       (cond ((< hash1 hash2) ':less)
		     ((> hash1 hash2) ':greater)
		     ((consp tree1)
		      (if (consp tree2) (wb-set-tree-compare (cdr tree1) (cdr tree2) compare-fn)
			':less))
		     ((consp tree2) ':greater)
		     (t
		      (let ((entries1 (ch-set-node-entry-mask tree1))
			    (entries2 (ch-set-node-entry-mask tree2))
			    (subnodes1 (ch-set-node-subnode-mask tree1))
			    (subnodes2 (ch-set-node-subnode-mask tree2)))
			(cond ((< entries1 entries2) ':less)
			      ((> entries1 entries2) ':greater)
			      ((< subnodes1 subnodes2) ':less)
			      ((> subnodes1 subnodes2) ':greater)
			      (t
			       ;; It's astronomically unlikely that we'll get here unless the trees are actually
			       ;; equal... but we still have to check.
			       (let ((default ':equal)
				     (len (length tree1)))
				 (dotimes (i (logcount entries1))
				   (let ((v1 (svref tree1 (+ ch-set-node-header-size i)))
					 (v2 (svref tree2 (+ ch-set-node-header-size i)))
					 ((cmp (funcall compare-fn v1 v2))))
				     (ecase cmp
				       (:equal)
				       (:unequal
					 (setq default ':unequal))
				       ((:less :greater)
					 (return-from ch-set-tree-compare cmp)))))
				 (dotimes (i (logcount subnodes1))
				   (let ((cmp (ch-set-tree-compare (svref tree1 (- len i 1))
								   (svref tree2 (- len i 1)) compare-fn)))
				     (ecase cmp
				       (:equal)
				       (:unequal
					 (setq default ':unequal))
				       ((:less :greater)
					 (return-from ch-set-tree-compare cmp)))))
				 default))))))))))))

(defun ch-set-tree-index (tree value hash-fn compare-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn))
  (let ((value-hash (hash-to-fixnum value hash-fn)))
    (declare (fixnum value-hash))
    (rlabels (rec tree value 0 value-hash)
      (rec (node value base hash-shifted)
	(declare (fixnum base hash-shifted))
	(and node
	     (if (consp node)
		 (let ((found? idx (wb-set-tree-rank (cdr node) value compare-fn)))
		   (and found? (the fixnum (+ (the fixnum idx) base))))
	       (let ((hash-bits (logand hash-shifted champ-hash-level-mask))
		     (entry-mask (ch-set-node-entry-mask node)))
		 (if (logbitp hash-bits entry-mask)
		     (let ((ientry (1-bits-below hash-bits entry-mask))
			   ((entry-idx (+ ch-set-node-header-size ientry))
			    ((ex-value (svref node entry-idx)))))
		       (and (equal?-cmp ex-value value compare-fn)
			    (the fixnum (+ base ientry))))
		   (let ((subnode-mask (ch-set-node-subnode-mask node)))
		     (incf base (logcount entry-mask))
		     (and (logbitp hash-bits subnode-mask)
			  (let ((isubnode (1-bits-below hash-bits subnode-mask))
				(len (length (the simple-vector node)))
				((subnode-idx (- len 1 isubnode))
				 ((subnode (svref node subnode-idx)))))
			    (dotimes (i isubnode)
			      (incf base (ch-set-tree-size (svref node (- len 1 i)))))
			    (rec subnode value base
				 (ash hash-shifted (- champ-hash-bits-per-level))))))))))))))

(defun ch-set-tree-index-element (tree index)
  (declare (optimize (speed 3) (safety 0)))
  (rlabels (rec tree index)
    (rec (tree index)
      (declare (fixnum index))
      (if (consp tree)
	  (wb-set-tree-rank-element (cdr tree) index)
	(let ((len (length (the simple-vector tree)))
	      (entry-mask (ch-set-node-entry-mask tree))
	      ((n-entries (logcount entry-mask))))
	  (if (< index n-entries)
	      (svref tree (+ ch-set-node-header-size index))
	    (let ((subnode-mask (ch-set-node-subnode-mask tree)))
	      (decf index n-entries)
	      (dotimes (i (logcount subnode-mask))
		(let ((subnode (svref tree (- len i 1)))
		      ((subnode-size (ch-set-tree-size subnode))))
		  (when (< index subnode-size)
		    (return (rec subnode index)))
		  (decf index subnode-size))))))))))

(defun vector-remove-n-at (vec idx n)
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector vec)
	   (type (unsigned-byte 24) idx n))
  (let ((len (length vec)))
    (declare (type fixnum len))
    (let ((new-vec (make-array (- len n))))
      (dotimes (i idx)
	(setf (svref new-vec i) (svref vec i)))
      (dotimes (i (- len idx n))
	(setf (svref new-vec (+ idx i)) (svref vec (+ idx i n))))
      new-vec)))


;;; --------------------------------
;;; Iteration primitives

;;; This ordering has the slight downside that it can seem unstable; adding or removing an element
;;; can cause a different element to change places (because an entry becomes a subnode or conversely).
;;; But doing it hash-wise is noticeably slower, like a factor of 2 on a straightforward micro-benchmark.
;;; And one of the selling points of CHAMP was supposed to be its better iteration performance.
(defmacro do-ch-set-tree-members ((value-var tree-form &optional value-form)
				  &body body)
  (let ((body-fn (gensymx #:body-))
	(recur-fn (gensymx #:recur-)))
    `(block nil
       (labels ((,body-fn (,value-var)
		  . ,body)
		(,recur-fn (tree)
		  (when tree
		    (if (consp tree)
			(do-wb-set-tree-members (,value-var (cdr tree))
			  (,body-fn ,value-var))
		      (progn
			(dotimes (i (logcount (ch-set-node-entry-mask tree)))
			  (,body-fn (svref tree (+ i ch-set-node-header-size))))
			(dotimes (i (logcount (ch-set-node-subnode-mask tree)))
			  (,recur-fn (svref tree (- (length tree) 1 i)))))))))
	 (declare (inline ,body-fn))
	 (,recur-fn ,tree-form))
       ,value-form)))

;;; ----------------
;;; Stateful iterator

(defun make-ch-set-tree-iterator (tree)
  (let ((iter (make-ch-set-tree-iterator-internal tree)))
    (lambda (op)
      (ecase op
	(:get (ch-set-tree-iterator-get iter))
	(:done? (ch-set-tree-iterator-done? iter))
	(:more? (not (ch-set-tree-iterator-done? iter)))))))

(defun make-ch-set-tree-iterator-internal (tree)
  (declare (optimize (speed 3) (safety 0)))
  ;; Unlike with the WB-trees, the maximum depth here is not a function of the set size.
  (let ((iter (make-array (+ 1 (* 2 (ceiling (integer-length most-positive-fixnum) champ-hash-bits-per-level))))))
    (if (null tree)
	(setf (svref iter 0) -1)
      (progn
	(setf (svref iter 0) 1) ; the stack pointer
	(setf (svref iter 1) tree)
	(setf (svref iter 2) 0)
	(ch-set-tree-iterator-canonicalize iter)))
    iter))

(defun ch-set-tree-iterator-canonicalize (iter)
  (declare (optimize (speed 3) (safety 0)))
  (let ((sp (svref iter 0))
	((node (svref iter sp))
	 (idx (svref iter (1+ sp)))))
    (declare (type (or null fixnum) idx))
    (when (if (null idx)
	      (wb-set-tree-iterator-done? (svref iter sp))
	    (= idx (- (length (the simple-vector node)) ch-set-node-header-size)))
      (decf sp 2)
      (unless (< sp 0)
	(setq node (svref iter sp))
	(setq idx (svref iter (1+ sp)))))
    (unless (< sp 0)
      (loop
	(when (null idx)
	  (return))
	(let ((n-entries (logcount (ch-set-node-entry-mask node))))
	  (when (< idx n-entries)
	    (return))
	  (let ((len (length (the simple-vector node))))
	    (setq node (svref node (- len (- idx n-entries) 1)))
	    (incf idx)
	    (unless (= idx (- len ch-set-node-header-size)) ; TCO
	      (setf (svref iter (1+ sp)) idx)
	      (incf sp 2))
	    (if (consp node)
		(setq node (make-wb-set-tree-iterator-internal (cdr node))
		      idx nil)
	      (setq idx 0))
	    (setf (svref iter sp) node)
	    (setf (svref iter (1+ sp)) idx)))))
    (setf (svref iter 0) sp)))

(defun ch-set-tree-iterator-done? (iter)
  (declare (optimize (speed 3) (safety 0)))
  (< (the fixnum (svref iter 0)) 0))

(defun ch-set-tree-iterator-get (iter)
  (declare (optimize (speed 3) (safety 0)))
  (let ((sp (svref iter 0)))
    (declare (fixnum sp))
    (and (> sp 0)
	 (let ((node (svref iter sp))
	       (idx (svref iter (1+ sp))))
	   (declare (type (or null fixnum) idx))
	   (if (null idx)
	       (let ((val (wb-set-tree-iterator-get node)))
		 (ch-set-tree-iterator-canonicalize iter)
		 (values val t))
	     (progn
	       (setf (svref iter (1+ sp)) (1+ idx))
	       (ch-set-tree-iterator-canonicalize iter)
	       (values (svref node (+ ch-set-node-header-size idx))
		       t)))))))

;;; ----------------
;;; Functional iterator

(defun ch-set-tree-fun-iter (tree)
  (declare (optimize (speed 3) (safety 0)))
  (rlabels (walk tree (lambda (op)
			(ecase op
			  (:first (values nil nil))
			  (:empty? t)
			  (:more? nil))))
    (walk (node cont)
      (if (consp node)
	  (wb-set-tree-fun-iter (cdr node) cont)
	(let ((n-entries (logcount (ch-set-node-entry-mask node)))
	      (n-subnodes (logcount (ch-set-node-subnode-mask node))))
	  (rlabels (entry 0)
	    (entry (i)
	      (declare (fixnum i))
	      (if (< i n-entries)
		  (lambda (op)
		    (ecase op
		      (:first (values (svref node (+ ch-set-node-header-size i)) t))
		      (:rest (entry (1+ i)))
		      (:empty? nil)
		      (:more? t)))
		(subnode 0)))
	    (subnode (i)
	      (declare (fixnum i))
	      (if (< i n-subnodes)
		  (walk (svref node (- (+ ch-set-node-header-size n-entries n-subnodes)
				       i 1))
			(lambda (op) (funcall (the function (subnode (1+ i))) op)))
		cont))))))))

(defun ch-set-tree-rev-fun-iter (tree)
  (declare (optimize (speed 3) (safety 0)))
  (rlabels (walk tree (lambda (op)
			(ecase op
			  (:first (values nil nil))
			  (:empty? t)
			  (:more? nil))))
    (walk (node cont)
      (if (consp node)
	  (wb-set-tree-rev-fun-iter (cdr node) cont)
	(let ((n-entries (logcount (ch-set-node-entry-mask node)))
	      (n-subnodes (logcount (ch-set-node-subnode-mask node))))
	  (rlabels (subnode (1- n-subnodes))
	    (entry (i)
	      (declare (fixnum i))
	      (if (>= i 0)
		  (lambda (op)
		    (ecase op
		      (:first (values (svref node (+ ch-set-node-header-size i)) t))
		      (:rest (entry (1- i)))
		      (:empty? nil)
		      (:more? t)))
		cont))
	    (subnode (i)
	      (declare (fixnum i))
	      (if (>= i 0)
		  (walk (svref node (- (+ ch-set-node-header-size n-entries n-subnodes)
				       i 1))
			(lambda (op) (funcall (the function (subnode (1- i))) op)))
		(entry (1- n-entries))))))))))


;;; --------------------------------
;;; Union, intersection, set-difference, subset?, disjoint?

(declaim (inline ch-set-node-entry))
(defun ch-set-node-entry (n ientry)
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector n)
	   (type champ-entry-index ientry))
  (svref n (+ ch-set-node-header-size ientry)))

(declaim (inline ch-set-node-subnode))
(defun ch-set-node-subnode (n isubnode)
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector n)
	   (type champ-subnode-index isubnode))
  (svref n (- (length n) isubnode 1)))

(declaim (inline ch-set-node-add-entry))
(defun ch-set-node-add-entry (n idx val hash-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type champ-bit-index idx)
	   (type function hash-fn))
  (setf (svref n (+ ch-set-node-header-size (logcount (ch-set-node-entry-mask n)))) val)
  (logiorf (ch-set-node-entry-mask n) (ash 1 idx))
  (incf (ch-set-node-size n))
  (hash-mixf (ch-set-node-hash-value n) (hash-to-fixnum val hash-fn)))

(declaim (inline ch-set-node-add-subnode))
(defun ch-set-node-add-subnode (n idx subnode hash-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type champ-bit-index idx)
	   (type function hash-fn))
  (when subnode
    (if (and (not (consp subnode))
	     (= 1 (logcount (ch-set-node-entry-mask subnode)))
	     (= 0 (ch-set-node-subnode-mask subnode)))
	;; `subnode' contains only an entry -- pull it up.
	(ch-set-node-add-entry n idx (svref subnode ch-set-node-header-size) hash-fn)
      (progn
	(when (and (not (consp subnode))
		   (= 0 (ch-set-node-entry-mask subnode))
		   (= 1 (logcount (ch-set-node-subnode-mask subnode)))
		   (consp (svref subnode (1- (length subnode)))))
	  ;; `subnode' contains only a collision subnode -- pull it up.
	  (setq subnode (svref subnode (1- (length subnode)))))
	(setf (svref n (- (length (the simple-vector n))
			  (logcount (ch-set-node-subnode-mask n)) 1))
	      subnode)
	(logiorf (ch-set-node-subnode-mask n) (ash 1 idx))
	(incf (ch-set-node-size n) (ch-set-tree-size subnode))
	(hash-mixf (ch-set-node-hash-value n) (ch-set-tree-hash-value subnode))))))

(defun ch-set-tree-union (tree1 tree2 hash-fn compare-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn))
  (rlabels (rec tree1 tree2 0)
    (rec (tree1 tree2 depth)
      (declare (type (integer 0 64) depth))
      (cond ((null tree1) tree2)
	    ((null tree2) tree1)
	    ((eq tree1 tree2) tree1)
	    ((and (consp tree1) (consp tree2))
	     (let ((hash1 (the fixnum (car tree1)))
		   (hash2 (the fixnum (car tree2))))
	       (if (= hash1 hash2)
		   (let ((result (wb-set-tree-union (cdr tree1) (cdr tree2) compare-fn)))
		     (ch-set-node-from-wb result hash1 depth))
		 (let ((size (+ (wb-set-tree-size (cdr tree1)) (wb-set-tree-size (cdr tree2))))
		       (bits1 (champ-hash-bits hash1 depth))
		       (bits2 (champ-hash-bits hash2 depth))
		       (chash (hash-mix (car tree1) (car tree2))))
		   (declare (fixnum size))
		   (if (= bits1 bits2)
		       (vector 0 (ash 1 bits1) size chash (rec tree1 tree2 (1+ depth)))
		     (let ((subnode0 subnode1 (swap-if (> bits1 bits2) tree1 tree2)))
		       (vector 0 (logior (ash 1 bits1) (ash 1 bits2)) size chash subnode1 subnode0)))))))
	    ((consp tree1)
	     (do-wb-set-tree-members (x (cdr tree1))
	       (setq tree2 (ch-set-tree-with tree2 x hash-fn compare-fn depth)))
	     tree2)
	    ((consp tree2)
	     (rec tree2 tree1 depth))
	    (t
	     (let ((entries1 (ch-set-node-entry-mask tree1))
		   (entries2 (ch-set-node-entry-mask tree2))
		   (subnodes1 (ch-set-node-subnode-mask tree1))
		   (subnodes2 (ch-set-node-subnode-mask tree2))
		   ((all-entries (logior entries1 entries2))
		    (all-subnodes (logior subnodes1 subnodes2))
		    ;; Entry collisions can change to subnodes, but they can't then collide with existing subnodes.
		    ;; But we do have to subtract out entry/subnode collisions.
		    ((new-len (- (+ ch-set-node-header-size (logcount all-entries) (logcount all-subnodes))
				 (logcount (logand entries1 subnodes2)) (logcount (logand entries2 subnodes1))))
		     ((res-n (make-array new-len :initial-element 0)))))
		   (ientry1 0)
		   (isubnode1 0)
		   (ientry2 0)
		   (isubnode2 0))
	       (declare (fixnum ientry1 isubnode1 ientry2 isubnode2))
	       (flet ((add-entry (idx val)
			(ch-set-node-add-entry res-n idx val hash-fn))
		      (add-subnode (idx subnode)
			(ch-set-node-add-subnode res-n idx subnode hash-fn))
		      (subtree-with (tree value)
			(ch-set-tree-with tree value hash-fn compare-fn (1+ depth))))
		 (do-bit-indices (idx (logior all-entries all-subnodes))
		   (cond ((and (logbitp idx entries1) (logbitp idx entries2))
			  (let ((val1 (ch-set-node-entry tree1 (postincf ientry1)))
				(val2 (ch-set-node-entry tree2 (postincf ientry2))))
			    (if (equal?-cmp val1 val2 compare-fn)
				(add-entry idx val1)
			      (add-subnode idx (subtree-with (subtree-with nil val1) val2)))))
			 ((logbitp idx entries1)
			  (let ((val (ch-set-node-entry tree1 (postincf ientry1))))
			    (if (logbitp idx subnodes2)
				(let ((subnode (ch-set-node-subnode tree2 (postincf isubnode2))))
				  (add-subnode idx (subtree-with subnode val)))
			      (add-entry idx val))))
			 ((logbitp idx entries2)
			  (let ((val (ch-set-node-entry tree2 (postincf ientry2))))
			    (if (logbitp idx subnodes1)
				(let ((subnode (ch-set-node-subnode tree1 (postincf isubnode1))))
				  (add-subnode idx (subtree-with subnode val)))
			      (add-entry idx val))))
			 ((and (logbitp idx subnodes1) (logbitp idx subnodes2))
			  (add-subnode idx (rec (ch-set-node-subnode tree1 (postincf isubnode1))
						(ch-set-node-subnode tree2 (postincf isubnode2))
						(1+ depth))))
			 ((logbitp idx subnodes1)
			  (add-subnode idx (ch-set-node-subnode tree1 (postincf isubnode1))))
			 ((logbitp idx subnodes2)
			  (add-subnode idx (ch-set-node-subnode tree2 (postincf isubnode2))))
			 (t (error "Bug in 'ch-set-tree-union'")))))
	       res-n))))))

(defun ch-set-tree-intersection (tree1 tree2 hash-fn compare-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn))
  (rlabels (rec tree1 tree2 0)
    (rec (tree1 tree2 depth)
      (declare (type (integer 0 64) depth))
      (cond ((or (null tree1) (null tree2)) nil)
	    ((eq tree1 tree2) tree1)
	    ((consp tree1)
	     (if (consp tree2)
		 (and (= (the fixnum (car tree1)) (the fixnum (car tree2)))
		      (let ((result (wb-set-tree-intersect (cdr tree1) (cdr tree2) compare-fn)))
			(ch-set-node-from-wb result (car tree1) depth)))
	       (let ((result nil))
		 (do-wb-set-tree-members (x (cdr tree1))
		   (when (ch-set-tree-contains? tree2 x hash-fn compare-fn depth)
		     (setq result (ch-set-tree-with result x hash-fn compare-fn depth))))
		 result)))
	    ((consp tree2)
	     (rec tree2 tree1 depth))
	    (t
	     (let ((entries1 (ch-set-node-entry-mask tree1))
		   (entries2 (ch-set-node-entry-mask tree2))
		   (subnodes1 (ch-set-node-subnode-mask tree1))
		   (subnodes2 (ch-set-node-subnode-mask tree2))
		   ;; Unlike in the union case, where we can compute the size in advance, for the intersection
		   ;; we can only compute an upper bound -- the result could even be empty.
		   ((res-len (min (length tree1) (length tree2)))
		    ((res-n (make-array res-len :initial-element 0)))))
	       (flet ((add-entry (idx val)
			(ch-set-node-add-entry res-n idx val hash-fn))
		      (add-subnode (idx subnode)
			(ch-set-node-add-subnode res-n idx subnode hash-fn))
		      (subtree-contains? (tree val)
			(ch-set-tree-contains? tree val hash-fn compare-fn (1+ depth))))
		 (do-bit-indices (idx (logior (logand entries1 entries2) (logand subnodes1 subnodes2)
					      (logand entries1 subnodes2) (logand subnodes1 entries2)))
		   ;; Here and in the other algorithms that don't look at every bit in the OR of
		   ;; the masks, we have to use `1-bits-below' instead of counters to get the indices.
		   (cond ((and (logbitp idx entries1) (logbitp idx entries2))
			  (let ((val1 (ch-set-node-entry tree1 (1-bits-below idx entries1)))
				(val2 (ch-set-node-entry tree2 (1-bits-below idx entries2))))
			    (when (equal?-cmp val1 val2 compare-fn)
			      (add-entry idx val1))))
			 ((and (logbitp idx entries1) (logbitp idx subnodes2))
			  (let ((val (ch-set-node-entry tree1 (1-bits-below idx entries1))))
			    (when (subtree-contains? (ch-set-node-subnode tree2 (1-bits-below idx subnodes2)) val)
			      (add-entry idx val))))
			 ((and (logbitp idx subnodes1) (logbitp idx entries2))
			  (let ((val (ch-set-node-entry tree2 (1-bits-below idx entries2))))
			    (when (subtree-contains? (ch-set-node-subnode tree1 (1-bits-below idx subnodes1)) val)
			      (add-entry idx val))))
			 ((and (logbitp idx subnodes1) (logbitp idx subnodes2))
			  (add-subnode idx (rec (ch-set-node-subnode tree1 (1-bits-below idx subnodes1))
						(ch-set-node-subnode tree2 (1-bits-below idx subnodes2))
						(1+ depth)))))))
	       (ch-set-compact-node res-n)))))))

(defun ch-set-tree-diff (tree1 tree2 hash-fn compare-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn))
  (rlabels (rec tree1 tree2 0)
    (rec (tree1 tree2 depth)
      (declare (type (integer 0 64) depth))
      (cond ((null tree1) nil)
	    ((null tree2) tree1)
	    ((eq tree1 tree2) nil)
	    ((consp tree1)
	     (if (consp tree2)
		 (if (= (the fixnum (car tree1)) (the fixnum (car tree2)))
		     (let ((result (wb-set-tree-diff (cdr tree1) (cdr tree2) compare-fn)))
		       (ch-set-node-from-wb result (car tree1) depth))
		   tree1)
	       (let ((result nil))
		 ;; Assuming the collision subtree is likely to be much smaller than the regular one.
		 (do-wb-set-tree-members (v (cdr tree1))
		   (unless (ch-set-tree-contains? tree2 v hash-fn compare-fn depth)
		     (setq result (wb-set-tree-with result v compare-fn))))
		 (ch-set-node-from-wb result (car tree1) depth))))
	    ((consp tree2)
	     (do-wb-set-tree-members (v (cdr tree2))
	       (setq tree1 (ch-set-tree-less tree1 v hash-fn compare-fn depth)))
	     tree1)
	    (t
	     (let ((entries1 (ch-set-node-entry-mask tree1))
		   (entries2 (ch-set-node-entry-mask tree2))
		   (subnodes1 (ch-set-node-subnode-mask tree1))
		   (subnodes2 (ch-set-node-subnode-mask tree2))
		   ((res-len (length (the simple-vector tree1))) ; upper bound
		    ((res-n (make-array res-len :initial-element 0)))))
	       (flet ((add-entry (idx val)
			(ch-set-node-add-entry res-n idx val hash-fn))
		      (add-subnode (idx subnode)
			(ch-set-node-add-subnode res-n idx subnode hash-fn))
		      (subtree-less (subtree val)
			(ch-set-tree-less subtree val hash-fn compare-fn (1+ depth)))
		      (subtree-contains? (subtree val)
			(ch-set-tree-contains? subtree val hash-fn compare-fn (1+ depth))))
		 (do-bit-indices (idx (logior entries1 subnodes1))
		   (cond ((logbitp idx entries1)
			  (let ((val1 (ch-set-node-entry tree1 (1-bits-below idx entries1))))
			    (cond ((logbitp idx entries2)
				   (let ((val2 (ch-set-node-entry tree2 (1-bits-below idx entries2))))
				     (unless (equal?-cmp val1 val2 compare-fn)
				       (add-entry idx val1))))
				  ((logbitp idx subnodes2)
				   (let ((subnode (ch-set-node-subnode tree2 (1-bits-below idx subnodes2))))
				     (unless (subtree-contains? subnode val1)
				       (add-entry idx val1))))
				  (t (add-entry idx val1)))))
			 ((logbitp idx subnodes1)
			  (let ((subnode1 (ch-set-node-subnode tree1 (1-bits-below idx subnodes1))))
			    (cond ((logbitp idx entries2)
				   (let ((val2 (ch-set-node-entry tree2 (1-bits-below idx entries2))))
				     (add-subnode idx (subtree-less subnode1 val2))))
				  ((logbitp idx subnodes2)
				   (let ((subnode2 (ch-set-node-subnode tree2 (1-bits-below idx subnodes2))))
				     (add-subnode idx (rec subnode1 subnode2 (1+ depth)))))
				  (t (add-subnode idx subnode1))))))))
	       (ch-set-compact-node res-n)))))))

(defun ch-set-tree-diff-2 (tree1 tree2 hash-fn compare-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn))
  (rlabels (rec tree1 tree2 0)
    (rec (tree1 tree2 depth)
      (declare (type (integer 0 64) depth))
      (cond ((null tree1) (values nil tree2))
	    ((null tree2) (values tree1 nil))
	    ((eq tree1 tree2) (values nil nil))
	    ((consp tree1)
	     (if (consp tree2)
		 (if (= (the fixnum (car tree1)) (the fixnum (car tree2)))
		     (let ((result1 result2 (wb-set-tree-diff-2 (cdr tree1) (cdr tree2) compare-fn)))
		       (values (ch-set-node-from-wb result1 (car tree1) depth)
			       (ch-set-node-from-wb result2 (car tree2) depth)))
		   (values tree1 tree2))
	       (let ((result1 (cdr tree1)))
		 (do-ch-set-tree-members (v tree2)
		   (setq result1 (wb-set-tree-less result1 v compare-fn)))
		 (do-wb-set-tree-members (v (cdr tree1))
		   (setq tree2 (ch-set-tree-less tree2 v hash-fn compare-fn depth)))
		 (values (ch-set-node-from-wb result1 (car tree1) depth)
			 tree2))))
	    ((consp tree2)
	     (let ((res2 res1 (rec tree2 tree1 depth)))
	       (values res1 res2)))
	    (t
	     (let ((entries1 (ch-set-node-entry-mask tree1))
		   (entries2 (ch-set-node-entry-mask tree2))
		   (subnodes1 (ch-set-node-subnode-mask tree1))
		   (subnodes2 (ch-set-node-subnode-mask tree2))
		   ((res-len1 (length (the simple-vector tree1))) ; upper bound
		    ((res-n1 (make-array res-len1 :initial-element 0))))
		   ((res-len2 (length (the simple-vector tree2)))
		    ((res-n2 (make-array res-len2 :initial-element 0))))
		   (ientry1 0)
		   (isubnode1 0)
		   (ientry2 0)
		   (isubnode2 0))
	       (declare (fixnum ientry1 isubnode1 ientry2 isubnode2))
	       (flet ((add-entry (n idx val)
			(ch-set-node-add-entry n idx val hash-fn))
		      (add-subnode (n idx subnode)
			(ch-set-node-add-subnode n idx subnode hash-fn))
		      (subtree-less (subtree val)
			(ch-set-tree-less subtree val hash-fn compare-fn (1+ depth)))
		      (subtree-contains? (subtree val)
			(ch-set-tree-contains? subtree val hash-fn compare-fn (1+ depth))))
		 (do-bit-indices (idx (logior entries1 subnodes1 entries2 subnodes2))
		   (cond ((logbitp idx entries1)
			  (let ((val1 (ch-set-node-entry tree1 (postincf ientry1))))
			    (cond ((logbitp idx entries2)
				   (let ((val2 (ch-set-node-entry tree2 (postincf ientry2))))
				     (unless (equal?-cmp val1 val2 compare-fn)
				       (add-entry res-n1 idx val1)
				       (add-entry res-n2 idx val2))))
				  ((logbitp idx subnodes2)
				   (let ((subnode2 (ch-set-node-subnode tree2 (postincf isubnode2))))
				     (unless (subtree-contains? subnode2 val1)
				       (add-entry res-n1 idx val1))
				     (add-subnode res-n2 idx (subtree-less subnode2 val1))))
				  (t (add-entry res-n1 idx val1)))))
			 ((logbitp idx subnodes1)
			  (let ((subnode1 (ch-set-node-subnode tree1 (postincf isubnode1))))
			    (cond ((logbitp idx subnodes2)
				   (let ((subnode2 (ch-set-node-subnode tree2 (postincf isubnode2)))
					 ((new-sn1 new-sn2 (rec subnode1 subnode2 (1+ depth)))))
				     (add-subnode res-n1 idx new-sn1)
				     (add-subnode res-n2 idx new-sn2)))
				  ((logbitp idx entries2)
				   (let ((val2 (ch-set-node-entry tree2 (postincf ientry2))))
				     (add-subnode res-n1 idx (subtree-less subnode1 val2))
				     (unless (subtree-contains? subnode1 val2)
				       (add-entry res-n2 idx val2))))
				  (t (add-subnode res-n1 idx subnode1)))))
			 ((logbitp idx entries2)
			  (add-entry res-n2 idx (ch-set-node-entry tree2 (postincf ientry2))))
			 ((logbitp idx subnodes2)
			  (add-subnode res-n2 idx (ch-set-node-subnode tree2 (postincf isubnode2))))
			 (t (error "Bug in ch-set-tree-diff-2")))))
	       (values (ch-set-compact-node res-n1) (ch-set-compact-node res-n2))))))))

(defun ch-set-node-from-wb (wb-set-tree hash depth)
  (declare (optimize (speed 3) (safety 0))
	   (fixnum hash)
	   (type (integer 0 64) depth))
  (case (wb-set-tree-size wb-set-tree)
    (0 nil)
    (1 (vector (ash 1 (champ-hash-bits hash depth)) 0 1 hash (wb-set-tree-arb wb-set-tree)))
    (t (cons hash wb-set-tree))))

(defun ch-set-compact-node (n)
  (declare (optimize (speed 3) (safety 0)))
  (let ((entries (ch-set-node-entry-mask n))
	(subnodes (ch-set-node-subnode-mask n)))
    (and (or (/= entries 0) (/= subnodes 0))
	 (let ((len (length (the simple-vector n)))
	       (n-entries (logcount entries))
	       ((extra (- len ch-set-node-header-size n-entries (logcount subnodes)))))
	   (when (< extra 0)
	     (error "Bug!  Not enough space allocated for ch-map-node"))
	   (if (= extra 0) n
	     (vector-remove-n-at n (+ ch-set-node-header-size n-entries) extra))))))

(defun ch-set-tree-subset? (tree1 tree2 hash-fn compare-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn))
  (rlabels (rec tree1 tree2 0)
    (rec (tree1 tree2 depth)
      (declare (type (integer 0 64) depth))
      (cond ((null tree1) t)
	    ((null tree2) nil)
	    ((eq tree1 tree2) t)
	    ((consp tree1)
	     (if (consp tree2)
		 (wb-set-tree-subset? (cdr tree1) (cdr tree2) compare-fn)
	       (do-wb-set-tree-members (x (cdr tree1) t)
		 (unless (ch-set-tree-contains? tree2 x hash-fn compare-fn depth)
		   (return nil)))))
	    ((consp tree2)
	     (do-ch-set-tree-members (x tree1 t)
	       (unless (wb-set-tree-contains? (cdr tree2) x compare-fn)
		 (return nil))))
	    (t
	     (let ((entries1 (ch-set-node-entry-mask tree1))
		   (entries2 (ch-set-node-entry-mask tree2))
		   (subnodes1 (ch-set-node-subnode-mask tree1))
		   (subnodes2 (ch-set-node-subnode-mask tree2)))
	       (do-bit-indices (idx (logior entries1 subnodes1)
				    t)
		 (cond ((logbitp idx entries1)
			(cond ((logbitp idx entries2)
			       (let ((val1 (ch-set-node-entry tree1 (1-bits-below idx entries1)))
				     (val2 (ch-set-node-entry tree2 (1-bits-below idx entries2))))
				 (unless (equal?-cmp val1 val2 compare-fn)
				   (return nil))))
			      ((logbitp idx subnodes2)
			       (let ((val (ch-set-node-entry tree1 (1-bits-below idx entries1))))
				 (unless (ch-set-tree-contains? (ch-set-node-subnode tree2 (1-bits-below idx subnodes2))
								val hash-fn compare-fn (1+ depth))
				   (return nil))))
			      (t (return nil))))
		       ((logbitp idx subnodes1)
			(cond ((logbitp idx subnodes2)
			       (unless (rec (ch-set-node-subnode tree1 (1-bits-below idx subnodes1))
					    (ch-set-node-subnode tree2 (1-bits-below idx subnodes2))
					    (1+ depth))
				 (return nil)))
			      (t (return nil))))))))))))

(defun ch-set-tree-disjoint? (tree1 tree2 hash-fn compare-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn))
  (rlabels (rec tree1 tree2 0)
    (rec (tree1 tree2 depth)
      (declare (type (integer 0 64) depth))
      (cond ((or (null tree1) (null tree2)) t)
	    ((eq tree1 tree2) nil)
	    ((consp tree1)
	     (if (consp tree2)
		 (wb-set-tree-disjoint? (cdr tree1) (cdr tree2) compare-fn)
	       (do-wb-set-tree-members (x (cdr tree1) t)
		 (when (ch-set-tree-contains? tree2 x hash-fn compare-fn depth)
		   (return nil)))))
	    ((consp tree2)
	     (rec tree2 tree1 depth))
	    (t
	     (let ((entries1 (ch-set-node-entry-mask tree1))
		   (entries2 (ch-set-node-entry-mask tree2))
		   (subnodes1 (ch-set-node-subnode-mask tree1))
		   (subnodes2 (ch-set-node-subnode-mask tree2)))
	       (do-bit-indices (idx (logand (logior entries1 subnodes1) (logior entries2 subnodes2))
				    t)
		 (cond ((and (logbitp idx entries1) (logbitp idx entries2))
			(let ((val1 (ch-set-node-entry tree1 (1-bits-below idx entries1)))
			      (val2 (ch-set-node-entry tree2 (1-bits-below idx entries2))))
			  (when (equal?-cmp val1 val2 compare-fn)
			    (return nil))))
		       ((and (logbitp idx entries1) (logbitp idx subnodes2))
			(let ((val (ch-set-node-entry tree1 (1-bits-below idx entries1))))
			  (when (ch-set-tree-contains? (ch-set-node-subnode tree2 (1-bits-below idx subnodes2))
						       val hash-fn compare-fn (1+ depth))
			    (return nil))))
		       ((and (logbitp idx subnodes1) (logbitp idx entries2))
			(let ((val (ch-set-node-entry tree2 (1-bits-below idx entries2))))
			  (when (ch-set-tree-contains? (ch-set-node-subnode tree1 (1-bits-below idx subnodes1))
						       val hash-fn compare-fn (1+ depth))
			    (return nil))))
		       ((and (logbitp idx subnodes1) (logbitp idx subnodes2))
			(unless (rec (ch-set-node-subnode tree1 (1-bits-below idx subnodes1))
				     (ch-set-node-subnode tree2 (1-bits-below idx subnodes2))
				     (1+ depth))
			  (return nil)))))))))))


;;; --------------------------------
;;; Verifier

(defun ch-set-tree-verify (tree hash-fn)
  (or (null tree)
      (rlabels (rec tree 0 0)
	(rec (node depth partial-hash)
	  (macrolet ((test (form)
		       `(or ,form
			    (progn
			      (cerror "Ignore and proceed."
				      "Test failed at ~:A: ~S" (path depth partial-hash) ',form)
			      nil))))
	    (let ((entry-mask (ch-set-node-entry-mask node))
		  (subnode-mask (ch-set-node-subnode-mask node))
		  ((entry-bits (bit-indices entry-mask))
		   (subnode-bits (bit-indices subnode-mask))))
	      (and (test (= 0 (logand entry-mask subnode-mask)))
		   (test (= 0 (ash entry-mask (- champ-node-radix))))
		   (test (= 0 (ash subnode-mask (- champ-node-radix))))
		   (test (= (length node) (+ ch-set-node-header-size (logcount entry-mask) (logcount subnode-mask))))
		   ;; Check that unless root, this node does not contain only an entry ...
		   (test (not (and (> depth 0) (= 1 (logcount entry-mask)) (= 0 subnode-mask))))
		   ;; ... or only a collision subnode
		   (test (not (and (> depth 0) (= 0 entry-mask) (= 1 (logcount subnode-mask))
				   (consp (svref node (1- (length node)))))))
		   (let ((size (logcount entry-mask))
			 (node-hash 0))
		     (and
		       ;; Check entry value hashes
		       (gmap :and (fn (value-idx hash-bits)
				    (let ((value (svref node (+ ch-set-node-header-size value-idx)))
					  ((value-hash (hash-to-fixnum value hash-fn))))
				      (hash-mixf node-hash value-hash)
				      (test (= (ldb (byte (* champ-hash-bits-per-level (1+ depth)) 0)
						    value-hash)
					       (new-partial-hash hash-bits depth partial-hash)))))
			     (:arg index 0)
			     (:arg list entry-bits))
		       ;; Verify subnodes
		       (gmap :and (fn (subnode-idx hash-bits)
				    (let ((subnode (svref node (- (length node) 1 subnode-idx))))
				      (if (consp subnode)
					  (let ((elt-hash (hash-to-fixnum (wb-set-tree-arb (cdr subnode)) hash-fn)))
					    (test (> (wb-set-tree-size (cdr subnode)) 1))
					    (do-wb-set-tree-members (v (cdr subnode))
					      (test (= (hash-to-fixnum v hash-fn) elt-hash)))
					    (hash-mixf node-hash elt-hash)
					    (incf size (wb-set-tree-size (cdr subnode)))
					    (test (= (car subnode) elt-hash)))
					(and (rec subnode (1+ depth) (new-partial-hash hash-bits depth partial-hash))
					     (progn
					       (incf size (ch-set-node-size subnode))
					       (hash-mixf node-hash (ch-set-node-hash-value subnode))
					       t)))))
			     (:arg index 0)
			     (:arg list subnode-bits))
		       ;; Finally, check size and hash
		       (test (= (ch-set-node-size node) size))
		       (test (= (ch-set-node-hash-value node) node-hash))))))))
	(new-partial-hash (hash-bits depth partial-hash)
	  (dpb hash-bits (byte champ-hash-bits-per-level (* champ-hash-bits-per-level depth))
	       partial-hash))
	(path (depth partial-hash)
	  (let ((path nil))
	    (dotimes (i depth)
	      (push (ldb (byte champ-hash-bits-per-level (* i champ-hash-bits-per-level))
			 partial-hash)
		    path))
	    (nreverse path))))))


;;; ================================================================================
;;; Maps

(defstruct (ch-map-node
	     (:type vector))
  (entry-mask 0 :type fixnum)
  (subnode-mask 0 :type fixnum)
  (size 0 :type fixnum) ; total number of pairs at or below this node
  (key-hash 0 :type fixnum)
  ;; This slot is used in two different ways.  For maps, it is a lazily populated cache of
  ;; the hashes of the values.  For bags, it is the total count (multiplicity).
  (value-hash nil :type (or null integer)))
(defmacro ch-map-node-bag-count (x)
  `(ch-map-node-value-hash ,x))
(defconstant ch-map-node-header-size 5)

;;; A collision node has the form ((key-hash . value-hash) . wb-tree), where `key-hash' is the hash
;;; value of any key -- they're all equal -- and `value-hash', if nonnull, is the mixed hash of all
;;; the values.
(deftype ch-map-tree ()
  '(or null cons simple-vector))

(declaim (ftype (function (ch-map-tree) fixnum) ch-map-tree-size))
(declaim (inline ch-map-tree-size))
(defun ch-map-tree-size (tree)
  (declare (optimize (speed 3) (safety 0)))
  (cond ((null tree) 0)
	((consp tree)
	 (wb-map-tree-size (cdr tree)))
	(t (ch-map-node-size tree))))

(declaim (inline ch-map-node-entry))
(defun ch-map-node-entry (node ientry)
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector node)
	   (type champ-entry-index ientry))
  (let ((entry-idx (+ ch-map-node-header-size (* 2 ientry))))
    (values (svref node entry-idx) (svref node (1+ entry-idx)))))

(declaim (inline ch-map-node-subnode))
(defun ch-map-node-subnode (node isubnode)
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector node)
	   (type champ-subnode-index isubnode))
  (svref node (- (length node) isubnode 1)))

(defun ch-map-tree-with (tree key value key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn &optional (depth 0))
  (declare (optimize (speed 3) (safety 0))
	   (type function key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn)
	   (type (integer 0 64) depth))
  (let ((key-hash (hash-to-fixnum key key-hash-fn)))
    (declare (fixnum key-hash))
    (rlabels (rec tree (ash key-hash (- (* champ-hash-bits-per-level depth))) depth)
      (rec (node hash-shifted depth &optional node-hash)
	(declare (fixnum hash-shifted)
		 (type (integer 0 64) depth)
		 (type (or null fixnum) node-hash))
	(let ((hash-bits (logand hash-shifted champ-hash-level-mask)))
	  (if (null node)
	      (vector (ash 1 hash-bits) 0 1 key-hash nil key value)
	    (if (consp node)
		;; Collision node.
		(let ((node-hash (or node-hash (hash-to-fixnum (wb-map-tree-arb-pair (cdr node)) key-hash-fn)))
		      ((wb-hash-shifted (ash node-hash (* (- champ-hash-bits-per-level) depth))))
		      (size (1+ (wb-map-tree-size (cdr node)))))
		  (declare (fixnum wb-hash-shifted hash-shifted size))
		  (if (= hash-shifted wb-hash-shifted)
		      ;; Update the collision node.
		      (let ((new-wb-tree (wb-map-tree-with (cdr node) key value key-cmp-fn val-cmp-fn)))
			(if (eq new-wb-tree (cdr node))
			    node
			  (let ((value-hash (and (cdar node)
						 (hash-mix (cdar node) (hash-to-fixnum value val-hash-fn)))))
			    (if (= (wb-map-tree-size new-wb-tree) (wb-map-tree-size (cdr node)))
				;; The key was already present, but the value was updated.
				(let ((ig old-value (wb-map-tree-lookup (cdr node) key key-cmp-fn)))
				  (declare (ignore ig))
				  (cons (cons (caar node)
					      (and value-hash
						   (hash-unmix value-hash (hash-to-fixnum old-value val-hash-fn))))
					new-wb-tree))
			      ;; New entry in collision node
			      (cons (cons (caar node) value-hash) new-wb-tree)))))
		    (let ((hash-bits (logand hash-shifted champ-hash-level-mask))
			  (wb-hash-bits (logand wb-hash-shifted champ-hash-level-mask))
			  (key-hash (hash-mix (caar node) key-hash))
			  (value-hash (and (cdar node) (hash-mix (cdar node) (hash-to-fixnum value val-hash-fn)))))
		      (if (= hash-bits wb-hash-bits)
			  (vector 0 (ash 1 hash-bits) size key-hash value-hash
				  (rec node (ash hash-shifted (- champ-hash-bits-per-level)) (1+ depth) node-hash))
			(vector (ash 1 hash-bits) (ash 1 wb-hash-bits) size key-hash value-hash
				key value node)))))
	      ;; Normal case.
	      (let ((entry-mask (ch-map-node-entry-mask node))
		    ((entry-idx (+ ch-map-node-header-size (* 2 (1-bits-below hash-bits entry-mask)))))
		    (subnode-mask (ch-map-node-subnode-mask node))
		    ((subnode-idx (- (length node) 1 (1-bits-below hash-bits subnode-mask)))))
		(if (logbitp hash-bits entry-mask)
		    ;; Entry found
		    (let ((ex-key (svref node entry-idx))
			  (ex-val (svref node (1+ entry-idx))))
		      (if (equal?-cmp key ex-key key-cmp-fn)
			  (if (equal?-cmp value ex-val val-cmp-fn)
			      node ; Key found, value equal: nothing to do
			    ;; Key found, value differs: just update value
			    (let ((n (vector-update node (+ entry-idx 1) value)))
			      (when (ch-map-node-value-hash n)
				(hash-mixf (ch-map-node-value-hash n) (hash-unmix (hash-to-fixnum value val-hash-fn)
										  (hash-to-fixnum ex-val val-hash-fn))))
			      n))
			;; Entry with different key found: make a subnode
			(let ((hash-shifted (ash hash-shifted (- champ-hash-bits-per-level)))
			      (ex-key-hash (hash-to-fixnum ex-key key-hash-fn))
			      ((ex-key-hash-shifted (ash ex-key-hash (* (- champ-hash-bits-per-level) (1+ depth))))
			       ((n2 (if (= hash-shifted ex-key-hash-shifted)
					;; Collision!  Fall back to WB-tree.
					(cons (cons key-hash nil)
					      (wb-map-tree-with (wb-map-tree-with nil ex-key ex-val
										  key-cmp-fn val-cmp-fn)
								key value key-cmp-fn val-cmp-fn))
				      ;; Turn the entry into a subnode and recur.
				      (rec (vector (ash 1 (logand ex-key-hash-shifted champ-hash-level-mask))
						   0 1 ex-key-hash nil ex-key ex-val)
					   hash-shifted (1+ depth))))
				;; The `1+' is because we're inserting _after_ `subnode-idx', because the subnodes
				;; are in reverse order.
				((n (vector-rem-2-ins-1 node entry-idx (1+ subnode-idx) n2))))))
			  (logandc2f (ch-map-node-entry-mask n) (ash 1 hash-bits))
			  (logiorf (ch-map-node-subnode-mask n) (ash 1 hash-bits))
			  (incf (ch-map-node-size n))
			  (unless (consp n2)
			    (hash-mixf (ch-map-node-key-hash n) key-hash))
			  (when (ch-map-node-value-hash n)
			    ;; `ex-val' is now included in `n2'; we mustn't double-count it.
			    (hash-unmixf (ch-map-node-value-hash n) (hash-to-fixnum ex-val val-hash-fn))
			    (hash-mixf (ch-map-node-value-hash n) (ch-map-tree-value-hash n2 val-hash-fn)))
			  n)))
		  ;; No entry found: check for subnode
		  (if (logbitp hash-bits subnode-mask)
		      ;; Subnode found
		      (let ((subnode (svref node subnode-idx))
			    ((new-subnode (rec subnode (ash hash-shifted (- champ-hash-bits-per-level))
					       (1+ depth)))))
			(if (eq new-subnode subnode)
			    node ; no change
			  ;; New subnode
			  (let ((n (vector-update node subnode-idx new-subnode)))
			    ;; If only a value was updated, the subnode won't have changed size.
			    (setf (ch-map-node-size n)
				  (the fixnum (+ (ch-map-node-size n) (- (the fixnum (ch-map-tree-size new-subnode))
									 (the fixnum (ch-map-tree-size subnode))))))
			    (hash-mixf (ch-map-node-key-hash n) (hash-unmix (ch-map-tree-key-hash new-subnode)
									    (ch-map-tree-key-hash subnode)))
			    (when (ch-map-node-value-hash n)
			      (hash-mixf (ch-map-node-value-hash n)
					 (hash-unmix (ch-map-tree-value-hash new-subnode val-hash-fn)
						     (ch-map-tree-value-hash subnode val-hash-fn))))
			    n)))
		    ;; Neither entry nor subnode found: make new entry
		    (let ((n (vector-insert-2 node entry-idx key value)))
		      (logiorf (ch-map-node-entry-mask n) (ash 1 hash-bits))
		      (incf (ch-map-node-size n))
		      (hash-mixf (ch-map-node-key-hash n) key-hash)
		      (when (ch-map-node-value-hash n)
			(hash-mixf (ch-map-node-value-hash n) (hash-to-fixnum value val-hash-fn)))
		      n)))))))))))

(defun vector-rem-2-ins-1 (vec rem-idx ins-idx ins-val)
  (declare (optimize (speed 3) (safety 0))
	   (simple-vector vec)
	   (fixnum rem-idx ins-idx))
  (assert (<= rem-idx (the fixnum (- ins-idx 2))))
  (let ((len (length vec))
	((v (make-array (1- len)))))
    (declare (fixnum len))
    (dotimes (i rem-idx)
      (setf (svref v i) (svref vec i)))
    (dotimes (i (- ins-idx rem-idx 2))
      (declare (fixnum i))
      (setf (svref v (+ rem-idx i)) (svref vec (+ rem-idx i 2))))
    (setf (svref v (- ins-idx 2)) ins-val)
    (dotimes (i (- len ins-idx))
      (declare (fixnum i))
      (setf (svref v (+ ins-idx i -1)) (svref vec (+ ins-idx i))))
    v))

(defun vector-insert-2 (vec idx ins-0 ins-1)
  (declare (optimize (speed 3) (safety 0))
	   (simple-vector vec)
	   (fixnum idx))
  (let ((len (length vec))
	((v (make-array (+ 2 len)))))
    (declare (fixnum len))
    (dotimes (i idx)
      (setf (svref v i) (svref vec i)))
    (setf (svref v idx) ins-0)
    (setf (svref v (1+ idx)) ins-1)
    (dotimes (i (- len idx))
      (setf (svref v (+ idx i 2)) (svref vec (+ idx i))))
    v))

(declaim (ftype (function (ch-map-tree) fixnum) ch-map-tree-key-hash))
(defun ch-map-tree-key-hash (tree)
  (declare (optimize (speed 3) (safety 0)))
  (cond ((null tree) 0)
	((consp tree) (caar tree))
	(t (ch-map-node-key-hash tree))))

(declaim (ftype (function (ch-map-tree function) fixnum) ch-map-tree-value-hash))
(defun ch-map-tree-value-hash (tree val-hash-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function val-hash-fn))
  (cond ((null tree) 0)
	((consp tree)
	 (or (cdar tree)
	     (setf (cdar tree)
		   (let ((vhash 0))
		     (do-wb-map-tree-pairs (k v (cdr tree))
		       (declare (ignore k))
		       (hash-mixf vhash (hash-to-fixnum v val-hash-fn)))
		     vhash))))
	(t
	 (or (ch-map-node-value-hash tree)
	     ;; Could happen in multiple threads, but they'll compute the same result.
	     (setf (ch-map-node-value-hash tree)
		   (let ((vhash 0))
		     (dotimes (i (logcount (ch-map-node-entry-mask tree)))
		       (let ((k v (ch-map-node-entry tree i)))
			 (declare (ignore k))
			 (hash-mixf vhash (hash-to-fixnum v val-hash-fn))))
		     (dotimes (i (logcount (ch-map-node-subnode-mask tree)))
		       (hash-mixf vhash (ch-map-tree-value-hash (ch-map-node-subnode tree i) val-hash-fn)))
		     vhash))))))

(defun ch-map-tree-arb-pair (tree)
  (declare (optimize (speed 3) (safety 0)))
  (cond ((null tree)
	 (error "'ch-map-tree-arb' called on empty tree"))
	((consp tree)
	 (wb-map-tree-arb-pair (cdr tree)))
	((= 0 (ch-map-node-entry-mask tree))
	 ;; If there are no entries, there must be at least one subnode
	 (ch-map-tree-arb-pair (svref tree (1- (length tree)))))
	(t
	 (values (svref tree ch-map-node-header-size) (svref tree (1+ ch-map-node-header-size))))))

(defun ch-map-tree-less (tree key key-hash-fn key-cmp-fn val-hash-fn &optional (depth 0))
  (declare (optimize (speed 1) (safety 0))
	   (type function key-hash-fn key-cmp-fn val-hash-fn)
	   (type (integer 0 64) depth))
  (let ((key-hash (hash-to-fixnum key key-hash-fn)))
    (declare (fixnum key-hash))
    (rlabels (rec tree (ash key-hash (- (* champ-hash-bits-per-level depth))) depth)
      (rec (node hash-shifted depth)
	(declare (fixnum hash-shifted)
		 (type (integer 0 64) depth))
	(and node
	     (if (consp node)
		 (if (/= (the fixnum (caar node)) key-hash)
		     (values node nil)
		   (let ((new-wb-tree ex-value (wb-map-tree-less (cdr node) key key-cmp-fn)))
		     (if (eq new-wb-tree (cdr node))
			 (values node nil)
		       (let ((value-hash (and (cdar node)
					      (hash-unmix (cdar node) (hash-to-fixnum ex-value val-hash-fn)))))
			 (if (= 1 (wb-map-tree-size new-wb-tree))
			     (let ((k v (wb-map-tree-arb-pair new-wb-tree)))
			       (values (vector (ash 1 (logcount (logand hash-shifted champ-hash-level-mask)))
					       0 1 key-hash value-hash k v)
				       ex-value))
			   (values (cons (cons (caar node) value-hash) new-wb-tree)
				   ex-value))))))
	       (let ((hash-bits (logand hash-shifted champ-hash-level-mask))
		     (entry-mask (ch-map-node-entry-mask node))
		     ((entry-raw-idx (1-bits-below hash-bits entry-mask))
		      ((entry-idx (+ ch-map-node-header-size (* 2 entry-raw-idx)))))
		     (subnode-mask (ch-map-node-subnode-mask node)))
		 (if (logbitp hash-bits entry-mask)
		     (let ((ex-key (svref node entry-idx)))
		       (cond ((not (equal?-cmp ex-key key key-cmp-fn))
			      (values node nil))
			     ((and (= (logcount entry-mask) 1) (= 0 subnode-mask))
			      (assert (= depth 0))
			      (values nil (svref node (1+ entry-idx))))
			     (t
			      (let ((n (vector-remove-2-at node entry-idx)))
				(logandc2f (ch-map-node-entry-mask n) (ash 1 hash-bits))
				(decf (ch-map-node-size n))
				(hash-unmixf (ch-map-node-key-hash n) key-hash)
				(when (ch-map-node-value-hash n)
				  (hash-unmixf (ch-map-node-value-hash n)
					       (hash-to-fixnum (svref node (1+ entry-idx)) val-hash-fn)))
				(values n (svref node (1+ entry-idx)))))))
		   (let ((subnode-raw-idx (1-bits-below hash-bits subnode-mask))
			 ((subnode-idx (- (the fixnum (length node)) 1 subnode-raw-idx))))
		     (declare (fixnum subnode-raw-idx subnode-idx))
		     (if (not (logbitp hash-bits subnode-mask))
			 (values node 0)
		       (let ((subnode (svref node subnode-idx)))
			 (let ((new-subnode lookup-val
				 (rec subnode (ash hash-shifted (- champ-hash-bits-per-level)) (1+ depth))))
			   (if (eq new-subnode subnode)
			       (values node 0)
			     (let ((n (cond ((consp new-subnode)
					     (vector-update node subnode-idx new-subnode))
					    ((and (= 1 (logcount (ch-map-node-entry-mask new-subnode)))
						  (= 0 (ch-map-node-subnode-mask new-subnode)))
					     ;; New subnode contains only a single entry: pull it up into this node
					     (let ((new-entry-idx
						     (+ ch-map-node-header-size
							(* 2 (1-bits-below hash-bits entry-mask))))
						   ((n (vector-ins-2-rem-1
							 node new-entry-idx (svref new-subnode ch-map-node-header-size)
							 (svref new-subnode (1+ ch-map-node-header-size))
							 subnode-idx))))
					       (logiorf (ch-map-node-entry-mask n) (ash 1 hash-bits))
					       (logandc2f (ch-map-node-subnode-mask n) (ash 1 hash-bits))
					       n))
					    ((and (= 0 (ch-map-node-entry-mask new-subnode))
						  (= 1 (logcount (ch-map-node-subnode-mask new-subnode)))
						  (consp (svref new-subnode ch-map-node-header-size)))
					     ;; New subnode contains only a collision node: pull it up into this node
					     (vector-update node subnode-idx
							    (svref new-subnode ch-map-node-header-size)))
					    (t (vector-update node subnode-idx new-subnode)))))
			       (decf (ch-map-node-size n))
			       (hash-mixf (ch-map-node-key-hash n) (hash-unmix (ch-map-tree-key-hash new-subnode)
									       (ch-map-tree-key-hash subnode)))
			       (when (ch-map-node-value-hash n)
				 (hash-mixf (ch-map-node-value-hash n)
					    (hash-unmix (ch-map-tree-value-hash new-subnode val-hash-fn)
							(ch-map-tree-value-hash subnode val-hash-fn))))
			       (values n lookup-val)))))))))))))))

(defun vector-remove-2-at (vec idx)
  (declare (optimize (speed 3) (safety 0))
	   (simple-vector vec)
	   (fixnum idx))
  (let ((len (length vec))
	((v (make-array (- len 2)))))
    (declare (fixnum len))
    (dotimes (i idx)
      (setf (svref v i) (svref vec i)))
    (dotimes (i (- len idx 2))
      (declare (fixnum i))
      (setf (svref v (+ idx i)) (svref vec (+ idx i 2))))
    v))

(defun vector-ins-2-rem-1 (vec ins-idx ins-0 ins-1 rem-idx)
  (declare (optimize (speed 3) (safety 0))
	   (simple-vector vec)
	   (fixnum ins-idx rem-idx))
  (assert (<= ins-idx rem-idx))
  (let ((len (length vec))
	((v (make-array (1+ (length vec))))))
    (declare (fixnum len))
    (dotimes (i ins-idx)
      (setf (svref v i) (svref vec i)))
    (setf (svref v ins-idx) ins-0)
    (setf (svref v (1+ ins-idx)) ins-1)
    (dotimes (i (- rem-idx ins-idx))
      (setf (svref v (+ ins-idx i 2)) (svref vec (+ ins-idx i))))
    (dotimes (i (- len rem-idx 1))
      (declare (fixnum i))
      (setf (svref v (the fixnum (+ rem-idx i 2))) (svref vec (+ rem-idx i 1))))
    v))

(defun ch-map-tree-lookup (tree key key-hash-fn key-cmp-fn &optional (depth 0))
  (declare (optimize (speed 3) (safety 0))
	   (type function key-hash-fn key-cmp-fn)
	   (type (integer 0 64) depth))
  (let ((key-hash (hash-to-fixnum key key-hash-fn)))
    (declare (fixnum key-hash))
    (rlabels (rec tree key (ash key-hash (- (* champ-hash-bits-per-level depth))))
      (rec (node key hash-shifted)
	(declare (fixnum hash-shifted))
	(and node
	     (if (consp node)
		 (wb-map-tree-lookup (cdr node) key key-cmp-fn)
	       (let ((hash-bits (logand hash-shifted champ-hash-level-mask))
		     (entry-mask (ch-map-node-entry-mask node)))
		 (if (logbitp hash-bits entry-mask)
		     (let ((entry-idx (+ ch-map-node-header-size
					 (* 2 (1-bits-below hash-bits entry-mask))))
			   ((ex-key (svref node entry-idx))))
		       (and (equal?-cmp ex-key key key-cmp-fn)
			    (values t (svref node (1+ entry-idx)))))
		   (let ((subnode-mask (ch-map-node-subnode-mask node)))
		     (and (logbitp hash-bits subnode-mask)
			  (let ((subnode-idx (- (the fixnum (length node))
						1 (1-bits-below hash-bits subnode-mask)))
				((subnode (svref node subnode-idx))))
			    (rec subnode key (ash hash-shifted (- champ-hash-bits-per-level))))))))))))))

(defun ch-map-tree-index (tree key key-hash-fn key-cmp-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function key-hash-fn key-cmp-fn))
  (let ((key-hash (hash-to-fixnum key key-hash-fn)))
    (declare (fixnum key-hash))
    (rlabels (rec tree key 0 key-hash)
      (rec (node key base hash-shifted)
	(declare (fixnum base hash-shifted))
	(and node
	     (if (consp node)
		 (let ((found? idx (wb-map-tree-rank (cdr node) key key-cmp-fn)))
		   (and found? (the fixnum (+ (the fixnum idx) base))))
	       (let ((hash-bits (logand hash-shifted champ-hash-level-mask))
		     (entry-mask (ch-map-node-entry-mask node)))
		 (if (logbitp hash-bits entry-mask)
		     (let ((ientry (1-bits-below hash-bits entry-mask))
			   ((entry-idx (+ ch-map-node-header-size (* 2 ientry)))
			    ((ex-key (svref node entry-idx)))))
		       (and (equal?-cmp ex-key key key-cmp-fn)
			    (the fixnum (+ base ientry))))
		   (let ((subnode-mask (ch-map-node-subnode-mask node)))
		     (incf base (logcount entry-mask))
		     (and (logbitp hash-bits subnode-mask)
			  (let ((isubnode (1-bits-below hash-bits subnode-mask))
				(len (length (the simple-vector node)))
				((subnode-idx (- len 1 isubnode))
				 ((subnode (svref node subnode-idx)))))
			    (dotimes (i isubnode)
			      (incf base (ch-map-tree-size (svref node (- len 1 i)))))
			    (rec subnode key base (ash hash-shifted (- champ-hash-bits-per-level))))))))))))))

(defun ch-map-tree-index-pair (tree index)
  (declare (optimize (speed 3) (safety 0)))
  (rlabels (rec tree index)
    (rec (tree index)
      (declare (fixnum index))
      (if (consp tree)
	  (wb-map-tree-rank-pair (cdr tree) index)
	(let ((len (length (the simple-vector tree)))
	      (entry-mask (ch-map-node-entry-mask tree))
	      ((n-entries (logcount entry-mask))))
	  (if (< index n-entries)
	      (let ((idx (+ ch-map-node-header-size (* 2 index))))
		(values (svref tree idx) (svref tree (1+ idx))))
	    (let ((subnode-mask (ch-map-node-subnode-mask tree)))
	      (decf index n-entries)
	      (dotimes (i (logcount subnode-mask))
		(let ((subnode (svref tree (- len i 1)))
		      ((subnode-size (ch-map-tree-size subnode))))
		  (when (< index subnode-size)
		    (return (rec subnode index)))
		  (decf index subnode-size))))))))))

(defun ch-map-tree-domain (tree key-hash-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function key-hash-fn))
  (if (null tree) nil
    (rlabels (rec tree)
      (rec (node)
	(if (consp node)
	    (let ((wb-dom (wb-map-tree-domain (cdr node))))
	      (cons (hash-to-fixnum (wb-set-tree-arb wb-dom) key-hash-fn) wb-dom))
	  (let ((len (length (the simple-vector node)))
		(entry-mask (ch-map-node-entry-mask node))
		(subnode-mask (ch-map-node-subnode-mask node))
		((nentries (logcount entry-mask))
		 (nsubnodes (logcount subnode-mask))
		 ((res-len (+ ch-set-node-header-size nentries nsubnodes))
		  ((n (make-array res-len)))))
		(hash 0))
	    (setf (ch-set-node-entry-mask n) entry-mask)
	    (setf (ch-set-node-subnode-mask n) subnode-mask)
	    (setf (ch-set-node-size n) (ch-map-node-size node))
	    (dotimes (i nentries)
	      (let ((x (svref node (+ ch-map-node-header-size (* 2 i)))))
		(setf (svref n (+ ch-set-node-header-size i)) x)
		(hash-mixf hash (hash-to-fixnum x key-hash-fn))))
	    (dotimes (i nsubnodes)
	      (let ((new-subnode (rec (svref node (- len i 1)))))
		(setf (svref n (- res-len i 1)) new-subnode)
		(hash-mixf hash (ch-set-tree-hash-value new-subnode))))
	    (setf (ch-set-node-hash-value n) hash)
	    n))))))

(defun ch-map-tree-compare (tree1 tree2 key-cmp-fn val-hash-fn val-cmp-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function key-cmp-fn val-hash-fn val-cmp-fn))
  (if (eq tree1 tree2) ':equal
    (let ((size1 (ch-map-tree-size tree1))
	  (size2 (ch-map-tree-size tree2)))
      (cond
	((< size1 size2) ':less)
	((> size1 size2) ':greater)
	(t
	 (let ((khash1 (ch-map-tree-key-hash tree1))
	       (khash2 (ch-map-tree-key-hash tree2)))
	   (cond
	     ((< khash1 khash2) ':less)
	     ((> khash1 khash2) ':greater)
	     (t
	      (let ((vhash1 (ch-map-tree-value-hash tree1 val-hash-fn))
		    (vhash2 (ch-map-tree-value-hash tree2 val-hash-fn)))
		(cond
		  ((< vhash1 vhash2) ':less)
		  ((> vhash1 vhash2) ':greater)
		  ((consp tree1)
		   (if (consp tree2) (wb-map-tree-compare (cdr tree1) (cdr tree2) key-cmp-fn val-cmp-fn)
		     ':less))
		  ((consp tree2) ':greater)
		  (t
		   (let ((entries1 (ch-map-node-entry-mask tree1))
			 (entries2 (ch-map-node-entry-mask tree2))
			 (subnodes1 (ch-map-node-subnode-mask tree1))
			 (subnodes2 (ch-map-node-subnode-mask tree2)))
		     (cond ((< entries1 entries2) ':less)
			   ((> entries1 entries2) ':greater)
			   ((< subnodes1 subnodes2) ':less)
			   ((> subnodes1 subnodes2) ':greater)
			   (t
			    ;; It's astronomically unlikely that we'll get here unless the trees are actually
			    ;; equal... but we still have to check.
			    (let ((default ':equal)
				  (len (length (the simple-vector tree1))))
			      (dotimes (i (logcount entries1))
				(let ((k1 (svref tree1 (+ ch-map-node-header-size (* 2 i))))
				      (v1 (svref tree1 (+ ch-map-node-header-size (1+ (* 2 i)))))
				      (k2 (svref tree2 (+ ch-map-node-header-size (* 2 i))))
				      (v2 (svref tree2 (+ ch-map-node-header-size (1+ (* 2 i)))))
				      ((key-cmp (funcall key-cmp-fn k1 k2))))
				  (when (member key-cmp '(:less :greater))
				    (return-from ch-map-tree-compare key-cmp))
				  (when (eq key-cmp ':unequal)
				    (setq default ':unequal))
				  (let ((val-cmp (funcall val-cmp-fn v1 v2)))
				    (when (member val-cmp '(:less :greater))
				      (return-from ch-map-tree-compare val-cmp))
				    (when (eq val-cmp ':unequal)
				      (setq default ':unequal)))))
			      (dotimes (i (logcount subnodes1))
				(let ((cmp (ch-map-tree-compare (svref tree1 (- len i 1)) (svref tree2 (- len i 1))
								key-cmp-fn val-hash-fn val-cmp-fn)))
				  (ecase cmp
				    (:equal)
				    (:unequal
				      (setq default ':unequal))
				    ((:less :greater)
				      (return-from ch-map-tree-compare cmp)))))
			      default)))))))))))))))


;;; --------------------------------
;;; Iteration primitives

(defmacro do-ch-map-tree-pairs ((key-var value-var tree-form &optional value-form)
				&body body)
  (let ((body-fn (gensymx #:body-))
	(recur-fn (gensymx #:recur-)))
    `(block nil
       (labels ((,body-fn (,key-var ,value-var)
		  . ,body)
		(,recur-fn (tree)
		  (when tree
		    (if (consp tree)
			(do-wb-map-tree-pairs (,key-var ,value-var (cdr tree))
			  (,body-fn ,key-var ,value-var))
		      (let ((len (the fixnum (length (the simple-vector tree)))))
			(dotimes (i (logcount (ch-map-node-entry-mask tree)))
			  (let ((idx (+ (* 2 i) ch-map-node-header-size)))
			    (,body-fn (svref tree idx) (svref tree (1+ idx)))))
			(dotimes (i (logcount (ch-map-node-subnode-mask tree)))
			  (,recur-fn (svref tree (- len 1 i)))))))))
	 (declare (inline ,body-fn))
	 (,recur-fn ,tree-form))
       ,value-form)))

;;; ----------------
;;; Stateful iterator

(defun make-ch-map-tree-iterator (tree)
  (let ((iter (make-ch-map-tree-iterator-internal tree)))
    (lambda (op)
      (ecase op
	(:get (ch-map-tree-iterator-get iter))
	(:done? (ch-map-tree-iterator-done? iter))
	(:more? (not (ch-map-tree-iterator-done? iter)))))))

(defun make-ch-map-tree-iterator-internal (tree)
  (declare (optimize (speed 3) (safety 0)))
  (let ((iter (make-array (+ 1 (* 2 (ceiling (integer-length most-positive-fixnum) champ-hash-bits-per-level))))))
    (if (null tree)
	(setf (svref iter 0) -1)
      (progn
	(setf (svref iter 0) 1) ; the stack pointer
	(setf (svref iter 1) tree)
	(setf (svref iter 2) 0)
	(ch-map-tree-iterator-canonicalize iter)))
    iter))

(defun ch-map-tree-iterator-canonicalize (iter)
  (declare (optimize (speed 3) (safety 0)))
  (let ((sp (svref iter 0))
	((node (svref iter sp))
	 (idx (svref iter (1+ sp)))))
    (declare (type (or null fixnum) idx))
    (when (if (null idx)
	      (wb-map-tree-iterator-done? (svref iter sp))
	    (= idx (logcount (logior (ch-map-node-entry-mask node) (ch-map-node-subnode-mask node)))))
      (decf sp 2)
      (unless (< sp 0)
	(setq node (svref iter sp))
	(setq idx (svref iter (1+ sp)))))
    (unless (< sp 0)
      (loop
	(when (null idx)
	  (return))
	(let ((n-entries (logcount (ch-map-node-entry-mask node)))
	      (n-subnodes (logcount (ch-map-node-subnode-mask node))))
	  (when (< idx n-entries)
	    (return))
	  (let ((len (length (the simple-vector node))))
	    (setq node (svref node (- len (- idx n-entries) 1)))
	    (incf idx)
	    (unless (= idx (+ n-entries n-subnodes)) ; TCO
	      (setf (svref iter (1+ sp)) idx)
	      (incf sp 2))
	    (if (consp node)
		(setq node (make-wb-map-tree-iterator-internal (cdr node))
		      idx nil)
	      (setq idx 0))
	    (setf (svref iter sp) node)
	    (setf (svref iter (1+ sp)) idx)))))
    (setf (svref iter 0) sp)))

(defun ch-map-tree-iterator-done? (iter)
  (declare (optimize (speed 3) (safety 0)))
  (< (the fixnum (svref iter 0)) 0))

(defun ch-map-tree-iterator-get (iter)
  (declare (optimize (speed 3) (safety 0)))
  (let ((sp (svref iter 0)))
    (declare (fixnum sp))
    (and (> sp 0)
	 (let ((node (svref iter sp))
	       (idx (svref iter (1+ sp))))
	   (declare (type (or null fixnum) idx))
	   (if (null idx)
	       (let ((key val (wb-map-tree-iterator-get node)))
		 (ch-map-tree-iterator-canonicalize iter)
		 (values key val t))
	     (let ((entry-idx (+ ch-map-node-header-size (the fixnum (* 2 idx)))))
	       (setf (svref iter (1+ sp)) (1+ idx))
	       (ch-map-tree-iterator-canonicalize iter)
	       (values (svref node entry-idx) (svref node (1+ entry-idx))
		       t)))))))

;;; ----------------
;;; Functional iterator

(defun ch-map-tree-fun-iter (tree)
  (declare (optimize (speed 3) (safety 0)))
  (rlabels (walk tree (lambda (op)
			(ecase op
			  (:first (values nil nil))
			  (:empty? t)
			  (:more? nil))))
    (walk (node cont)
      (if (consp node)
	  (wb-map-tree-fun-iter (cdr node) cont)
	(let ((n-entries (logcount (ch-map-node-entry-mask node)))
	      (n-subnodes (logcount (ch-map-node-subnode-mask node))))
	  (rlabels (entry 0)
	    (entry (i)
	      (declare (fixnum i))
	      (if (< i n-entries)
		  (lambda (op)
		    (ecase op
		      (:first (let ((entry-idx (+ ch-map-node-header-size (the fixnum (* 2 i)))))
				(values (svref node entry-idx) (svref node (1+ entry-idx)) t)))
		      (:rest (entry (1+ i)))
		      (:empty? nil)
		      (:more? t)))
		(subnode 0)))
	    (subnode (i)
	      (declare (fixnum i))
	      (if (< i n-subnodes)
		  (walk (svref node (- (+ ch-map-node-header-size (* 2 n-entries) n-subnodes)
				       i 1))
			(lambda (op) (funcall (the function (subnode (1+ i))) op)))
		cont))))))))

(defun ch-map-tree-rev-fun-iter (tree)
  (declare (optimize (speed 3) (safety 0)))
  (rlabels (walk tree (lambda (op)
			(ecase op
			  (:first (values nil nil))
			  (:empty? t)
			  (:more? nil))))
    (walk (node cont)
      (if (consp node)
	  (wb-map-tree-rev-fun-iter (cdr node) cont)
	(let ((n-entries (logcount (ch-map-node-entry-mask node)))
	      (n-subnodes (logcount (ch-map-node-subnode-mask node))))
	  (rlabels (subnode (1- n-subnodes))
	    (entry (i)
	      (declare (fixnum i))
	      (if (>= i 0)
		  (lambda (op)
		    (ecase op
		      (:first (let ((entry-idx (+ ch-map-node-header-size (the fixnum (* 2 i)))))
				(values (svref node entry-idx) (svref node (1+ entry-idx)) t)))
		      (:rest (entry (1- i)))
		      (:empty? nil)
		      (:more? t)))
		cont))
	    (subnode (i)
	      (declare (fixnum i))
	      (if (>= i 0)
		  (walk (svref node (- (+ ch-map-node-header-size (* 2 n-entries) n-subnodes)
				       i 1))
			(lambda (op) (funcall (the function (subnode (1- i))) op)))
		(entry (1- n-entries))))))))))


;;; --------------------------------
;;; Union, intersection, set-difference, subset?, disjoint?

(declaim (inline ch-map-node-add-entry))
(defun ch-map-node-add-entry (n idx key val key-hash-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type champ-bit-index idx)
	   (type function key-hash-fn))
  (let ((entry-idx (+ ch-map-node-header-size (* 2 (logcount (ch-map-node-entry-mask n))))))
    (setf (svref n entry-idx) key)
    (setf (svref n (1+ entry-idx)) val))
  (logiorf (ch-map-node-entry-mask n) (ash 1 idx))
  (incf (ch-map-node-size n))
  (hash-mixf (ch-map-node-key-hash n) (hash-to-fixnum key key-hash-fn)))

(declaim (inline ch-map-node-add-subnode))
(defun ch-map-node-add-subnode (n idx subnode key-hash-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type champ-bit-index idx)
	   (type function key-hash-fn))
  (when subnode
    (if (and (not (consp subnode))
	     (= 1 (logcount (ch-map-node-entry-mask subnode)))
	     (= 0 (ch-map-node-subnode-mask subnode)))
	;; `subnode' contains only an entry -- pull it up.
	(ch-map-node-add-entry n idx (svref subnode ch-map-node-header-size)
			       (svref subnode (1+ ch-map-node-header-size)) key-hash-fn)
      (progn
	(when (and (not (consp subnode))
		   (= 0 (ch-map-node-entry-mask subnode))
		   (= 1 (logcount (ch-map-node-subnode-mask subnode)))
		   (consp (svref subnode (1- (length subnode)))))
	  ;; `subnode' contains only a collision subnode -- pull it up.
	  (setq subnode (svref subnode (1- (length subnode)))))
	(setf (svref n (- (length (the simple-vector n))
			  (logcount (ch-map-node-subnode-mask n)) 1))
	      subnode)
	(logiorf (ch-map-node-subnode-mask n) (ash 1 idx))
	(incf (ch-map-node-size n) (ch-map-tree-size subnode))
	(hash-mixf (ch-map-node-key-hash n) (ch-map-tree-key-hash subnode))))))

(defun ch-map-tree-union (tree1 tree2 val-fn key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function val-fn key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn))
  (rlabels (rec tree1 tree2 val-fn 0)
    (rec (tree1 tree2 val-fn depth)
      (declare (type (integer 0 64) depth)
	       (type function val-fn))
      (cond ((null tree1) tree2)
	    ((null tree2) tree1)
	    ((eq tree1 tree2) tree1)
	    ((and (consp tree1) (consp tree2))
	     (if (= (the fixnum (caar tree1)) (the fixnum (caar tree2)))
		 (let ((result (wb-map-tree-union (cdr tree1) (cdr tree2) val-fn key-cmp-fn)))
		   (ch-map-node-from-wb result (caar tree1) depth))
	       (let ((bits1 (champ-hash-bits (the fixnum (caar tree1)) depth))
		     (bits2 (champ-hash-bits (the fixnum (caar tree2)) depth))
		     (size (+ (wb-map-tree-size (cdr tree1)) (wb-map-tree-size (cdr tree2))))
		     (key-hash (hash-mix (caar tree1) (caar tree2))))
		 (declare (fixnum size))
		 (if (= bits1 bits2)
		     (vector 0 (ash 1 bits1) size key-hash nil (rec tree1 tree2 val-fn (1+ depth)))
		   (let ((subnode0 subnode1 (swap-if (> bits1 bits2) tree1 tree2)))
		     (vector 0 (logior (ash 1 bits1) (ash 1 bits2)) size key-hash nil subnode1 subnode0))))))
	    ((consp tree1)
	     (do-wb-map-tree-pairs (k1 v1 (cdr tree1))
	       (let ((v2? v2 (ch-map-tree-lookup tree2 k1 key-hash-fn key-cmp-fn depth)))
		 (if v2?
		     (let ((new-v second-val (funcall val-fn v1 v2)))
		       (if (eq second-val ':no-value)
			   (setq tree2 (ch-map-tree-less tree2 k1 key-hash-fn key-cmp-fn val-hash-fn depth))
			 (setq tree2 (ch-map-tree-with tree2 k1 new-v key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn
						       depth))))
		   (setq tree2 (ch-map-tree-with tree2 k1 v1 key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn depth)))))
	     tree2)
	    ((consp tree2)
	     (rec tree2 tree1 (fn (x y) (funcall val-fn y x)) depth))
	    (t
	     (let ((entries1 (ch-map-node-entry-mask tree1))
		   (entries2 (ch-map-node-entry-mask tree2))
		   (subnodes1 (ch-map-node-subnode-mask tree1))
		   (subnodes2 (ch-map-node-subnode-mask tree2))
		   ((all-entries (logior entries1 entries2))
		    (all-subnodes (logior subnodes1 subnodes2))
		    ((everything (logior all-entries all-subnodes))
		     ;; The `:no-value' feature creates the possibility that a subnode, on one or both sides,
		     ;; will change to an entry; in the worst case, this could happen to all of them.
		     ((res-len (+ ch-map-node-header-size (* 2 (logcount everything))))
		      ((res-n (make-array res-len :initial-element 0))))))
		   (ientry1 0)
		   (isubnode1 0)
		   (ientry2 0)
		   (isubnode2 0))
	       (declare (fixnum ientry1 isubnode1 ientry2 isubnode2))
	       (setf (ch-map-node-value-hash res-n) nil)
	       (flet ((add-entry (idx key val)
			(ch-map-node-add-entry res-n idx key val key-hash-fn))
		      (add-subnode (idx subnode)
			(ch-map-node-add-subnode res-n idx subnode key-hash-fn)
			nil)  ; hush, SBCL
		      (subtree-lookup (tree key)
			(ch-map-tree-lookup tree key key-hash-fn key-cmp-fn (1+ depth)))
		      (subtree-with (subtree key value)
			(ch-map-tree-with subtree key value key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn
					  (1+ depth)))
		      (subtree-less (subtree key)
			(ch-map-tree-less subtree key key-hash-fn key-cmp-fn val-hash-fn (1+ depth))))
		 (do-bit-indices (idx everything)
		   (cond ((and (logbitp idx entries1) (logbitp idx entries2))
			  (let ((key1 val1 (ch-map-node-entry tree1 (postincf ientry1)))
				(key2 val2 (ch-map-node-entry tree2 (postincf ientry2))))
			    (if (equal?-cmp key1 key2 key-cmp-fn)
				(let ((new-val second-val (funcall val-fn val1 val2)))
				  (unless (eq second-val ':no-value)
				    (add-entry idx key1 new-val)))
			      (add-subnode idx (subtree-with (subtree-with nil key1 val1) key2 val2)))))
			 ((logbitp idx entries1)
			  (let ((key1 val1 (ch-map-node-entry tree1 (postincf ientry1))))
			    (if (logbitp idx subnodes2)
				(let ((subnode2 (ch-map-node-subnode tree2 (postincf isubnode2)))
				      ((val2? val2 (subtree-lookup subnode2 key1))))
				  (if val2?
				      (let ((new-val second-val (funcall val-fn val1 val2)))
					(if (eq second-val ':no-value)
					    (add-subnode idx (subtree-less subnode2 key1))
					  (add-subnode idx (subtree-with subnode2 key1 new-val))))
				    (add-subnode idx (subtree-with subnode2 key1 val1))))
			      (add-entry idx key1 val1))))
			 ((logbitp idx entries2)
			  (let ((key2 val2 (ch-map-node-entry tree2 (postincf ientry2))))
			    (if (logbitp idx subnodes1)
				(let ((subnode1 (ch-map-node-subnode tree1 (postincf isubnode1)))
				      ((val1? val1 (subtree-lookup subnode1 key2))))
				  (if val1?
				      (let ((new-val second-val (funcall val-fn val1 val2)))
					(if (eq second-val ':no-value)
					    (add-subnode idx (subtree-less subnode1 key2))
					  (add-subnode idx (subtree-with subnode1 key2 new-val))))
				    (add-subnode idx (subtree-with subnode1 key2 val2))))
			      (add-entry idx key2 val2))))
			 ((and (logbitp idx subnodes1) (logbitp idx subnodes2))
			  (add-subnode idx (rec (ch-map-node-subnode tree1 (postincf isubnode1))
						(ch-map-node-subnode tree2 (postincf isubnode2))
						val-fn (1+ depth))))
			 ((logbitp idx subnodes1)
			  (add-subnode idx (ch-map-node-subnode tree1 (postincf isubnode1))))
			 ((logbitp idx subnodes2)
			  (add-subnode idx (ch-map-node-subnode tree2 (postincf isubnode2))))
			 (t (error "Bug in 'ch-map-tree-union'")))))
	       ;; When two entries meet and become a subnode, we no longer need the value slot.
	       (ch-map-compact-node res-n)))))))

(defun ch-map-tree-intersection (tree1 tree2 val-fn key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function val-fn key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn))
  (rlabels (rec tree1 tree2 val-fn 0)
    (rec (tree1 tree2 val-fn depth)
      (declare (type (integer 0 64) depth)
	       (type function val-fn))
      (cond ((or (null tree1) (null tree2)) nil)
	    ((eq tree1 tree2) tree1)
	    ((and (consp tree1) (consp tree2))
	     (and (= (the fixnum (caar tree1)) (the fixnum (caar tree2)))
		  (let ((result (wb-map-tree-intersect (cdr tree1) (cdr tree2) val-fn key-cmp-fn)))
		    (ch-map-node-from-wb result (caar tree1) depth))))
	    ((consp tree1)
	     (let ((result nil))
	       (do-wb-map-tree-pairs (k1 v1 (cdr tree1))
		 (let ((v2? v2 (ch-map-tree-lookup tree2 k1 key-hash-fn key-cmp-fn depth)))
		   (when v2?
		     (let ((new-v second-val (funcall val-fn v1 v2)))
		       (unless (eq second-val ':no-value)
			 (setq result (ch-map-tree-with result k1 new-v key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn
							depth)))))))
	       result))
	    ((consp tree2)
	     (rec tree2 tree1 (fn (x y) (funcall val-fn y x)) depth))
	    (t
	     (let ((entries1 (ch-map-node-entry-mask tree1))
		   (entries2 (ch-map-node-entry-mask tree2))
		   (subnodes1 (ch-map-node-subnode-mask tree1))
		   (subnodes2 (ch-map-node-subnode-mask tree2))
		   ((combined-mask (logand (logior entries1 subnodes1) (logior entries2 subnodes2)))
		    ;; The result can be longer than either input, because the intersection of two subnodes
		    ;; could be an entry.
		    ((res-len (+ ch-map-node-header-size (* 2 (logcount combined-mask))))
		     ((res-n (make-array res-len :initial-element 0))))))
	       (setf (ch-map-node-value-hash res-n) nil)
	       (flet ((add-entry (idx key val)
			(ch-map-node-add-entry res-n idx key val key-hash-fn))
		      (add-subnode (idx subnode)
			(ch-map-node-add-subnode res-n idx subnode key-hash-fn))
		      (subtree-lookup (tree key)
			(ch-map-tree-lookup tree key key-hash-fn key-cmp-fn (1+ depth))))
		 (do-bit-indices (idx combined-mask)
		   (cond ((and (logbitp idx entries1) (logbitp idx entries2))
			  (let ((key1 val1 (ch-map-node-entry tree1 (1-bits-below idx entries1)))
				(key2 val2 (ch-map-node-entry tree2 (1-bits-below idx entries2))))
			    (when (equal?-cmp key1 key2 key-cmp-fn)
			      (let ((new-val second-val (funcall val-fn val1 val2)))
				(unless (eq second-val ':no-value)
				  (add-entry idx key1 new-val))))))
			 ((and (logbitp idx entries1) (logbitp idx subnodes2))
			  (let ((key1 val1 (ch-map-node-entry tree1 (1-bits-below idx entries1)))
				(subnode2 (ch-map-node-subnode tree2 (1-bits-below idx subnodes2)))
				((val2? val2 (subtree-lookup subnode2 key1))))
			    (when val2?
			      (let ((new-val second-val (funcall val-fn val1 val2)))
				(unless (eq second-val ':no-value)
				  (add-entry idx key1 new-val))))))
			 ((and (logbitp idx subnodes1) (logbitp idx entries2))
			  (let ((key2 val2 (ch-map-node-entry tree2 (1-bits-below idx entries2)))
				(subnode1 (ch-map-node-subnode tree1 (1-bits-below idx subnodes1)))
				((val1? val1 (subtree-lookup subnode1 key2))))
			    (when val1?
			      (let ((new-val second-val (funcall val-fn val1 val2)))
				(unless (eq second-val ':no-value)
				  (add-entry idx key2 new-val))))))
			 ((and (logbitp idx subnodes1) (logbitp idx subnodes2))
			  (add-subnode idx (rec (ch-map-node-subnode tree1 (1-bits-below idx subnodes1))
						(ch-map-node-subnode tree2 (1-bits-below idx subnodes2))
						val-fn (1+ depth))))))
		 (ch-map-compact-node res-n))))))))

(defun ch-map-tree-diff-2 (tree1 tree2 key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn))
  (rlabels (rec tree1 tree2 0)
    (rec (tree1 tree2 depth)
      (declare (type (integer 0 64) depth))
      (cond ((null tree1) (values nil tree2))
	    ((null tree2) (values tree1 nil))
	    ((eq tree1 tree2) (values nil nil))
	    ((consp tree1)
	     (if (consp tree2)
		 (if (= (the fixnum (caar tree1)) (the fixnum (caar tree2)))
		     (let ((result1 result2 (wb-map-tree-diff-2 (cdr tree1) (cdr tree2) key-cmp-fn val-cmp-fn)))
		       (values (ch-map-node-from-wb result1 (caar tree1) depth)
			       (ch-map-node-from-wb result2 (caar tree2) depth)))
		   (values tree1 tree2))
	       (let ((result1 nil)
		     (result2 nil))
		 (do-wb-map-tree-pairs (k v1 (cdr tree1))
		   (let ((v2? v2 (ch-map-tree-lookup tree2 k key-hash-fn key-cmp-fn depth)))
		     (unless (and v2? (equal?-cmp v1 v2 val-cmp-fn))
		       (setq result1 (wb-map-tree-with result1 k v1 key-cmp-fn val-cmp-fn)))))
		 (do-ch-map-tree-pairs (k v2 tree2)
		   (let ((v1? v1 (wb-map-tree-lookup (cdr tree1) k key-cmp-fn)))
		     (unless (and v1? (equal?-cmp v1 v2 val-cmp-fn))
		       (setq result2 (ch-map-tree-with result2 k v2 key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn
						       depth)))))
		 (values (ch-map-node-from-wb result1 (caar tree1) depth)
			 result2))))
	    ((consp tree2)
	     (let ((res2 res1 (rec tree2 tree1 depth)))
	       (values res1 res2)))
	    (t
	     (let ((entries1 (ch-map-node-entry-mask tree1))
		   (entries2 (ch-map-node-entry-mask tree2))
		   (subnodes1 (ch-map-node-subnode-mask tree1))
		   (subnodes2 (ch-map-node-subnode-mask tree2))
		   ((res-len1 (+ ch-map-node-header-size (* 2 (logcount (logior entries1 subnodes1)))))
		    ((res-n1 (make-array res-len1 :initial-element 0))))
		   ((res-len2 (+ ch-map-node-header-size (* 2 (logcount (logior entries2 subnodes2)))))
		    ((res-n2 (make-array res-len2 :initial-element 0))))
		   (ientry1 0)
		   (isubnode1 0)
		   (ientry2 0)
		   (isubnode2 0))
	       (declare (fixnum ientry1 isubnode1 ientry2 isubnode2))
	       (setf (ch-map-node-value-hash res-n1) nil)
	       (setf (ch-map-node-value-hash res-n2) nil)
	       (flet ((add-entry (n idx key val)
			(ch-map-node-add-entry n idx key val key-hash-fn))
		      (add-subnode (n idx subnode)
			(ch-map-node-add-subnode n idx subnode key-hash-fn))
		      (subtree-less (subtree key)
			(ch-map-tree-less subtree key key-hash-fn key-cmp-fn val-hash-fn (1+ depth)))
		      (subtree-lookup (subtree key)
			(ch-map-tree-lookup subtree key key-hash-fn key-cmp-fn (1+ depth))))
		 (do-bit-indices (idx (logior entries1 subnodes1 entries2 subnodes2))
		   (cond ((logbitp idx entries1)
			  (let ((key1 val1 (ch-map-node-entry tree1 (postincf ientry1))))
			    (cond ((logbitp idx entries2)
				   (let ((key2 val2 (ch-map-node-entry tree2 (postincf ientry2))))
				     (unless (and (equal?-cmp key1 key2 key-cmp-fn) (equal?-cmp val1 val2 val-cmp-fn))
				       (add-entry res-n1 idx key1 val1)
				       (add-entry res-n2 idx key2 val2))))
				  ((logbitp idx subnodes2)
				   (let ((subnode2 (ch-map-node-subnode tree2 (postincf isubnode2)))
					 ((val2? val2 (subtree-lookup subnode2 key1))))
				     (if (and val2? (equal?-cmp val1 val2 val-cmp-fn))
					 (add-subnode res-n2 idx (subtree-less subnode2 key1))
				       (progn
					 (add-entry res-n1 idx key1 val1)
					 (add-subnode res-n2 idx subnode2)))))
				  (t (add-entry res-n1 idx key1 val1)))))
			 ((logbitp idx subnodes1)
			  (let ((subnode1 (ch-map-node-subnode tree1 (postincf isubnode1))))
			    (cond ((logbitp idx subnodes2)
				   (let ((subnode2 (ch-map-node-subnode tree2 (postincf isubnode2)))
					 ((new-sn1 new-sn2 (rec subnode1 subnode2 (1+ depth)))))
				     (add-subnode res-n1 idx new-sn1)
				     (add-subnode res-n2 idx new-sn2)))
				  ((logbitp idx entries2)
				   (let ((key2 val2 (ch-map-node-entry tree2 (postincf ientry2)))
					 ((val1? val1 (subtree-lookup subnode1 key2))))
				     (if (and val1? (equal?-cmp val1 val2 val-cmp-fn))
					 (add-subnode res-n1 idx (subtree-less subnode1 key2))
				       (progn
					 (add-subnode res-n1 idx subnode1)
					 (add-entry res-n2 idx key2 val2)))))
				  (t (add-subnode res-n1 idx subnode1)))))
			 ((logbitp idx entries2)
			  (let ((key val (ch-map-node-entry tree2 (postincf ientry2))))
			    (add-entry res-n2 idx key val)))
			 ((logbitp idx subnodes2)
			  (add-subnode res-n2 idx (ch-map-node-subnode tree2 (postincf isubnode2))))
			 (t (error "Bug in ch-map-tree-diff")))))
	       (values (ch-map-compact-node res-n1) (ch-map-compact-node res-n2))))))))

(defun ch-map-tree-restrict (map-tree set-tree key-hash-fn key-cmp-fn val-hash-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function key-hash-fn key-cmp-fn val-hash-fn))
  (rlabels (rec map-tree set-tree 0)
    (rec (map-tree set-tree depth)
      (declare (type (integer 0 64) depth))
      (cond ((or (null map-tree) (null set-tree)) nil)
	    ((and (consp map-tree) (consp set-tree))
	     (and (= (the fixnum (caar map-tree)) (the fixnum (car set-tree)))
		  (let ((result (wb-map-tree-restrict (cdr map-tree) (cdr set-tree) key-cmp-fn)))
		    (ch-map-node-from-wb result (car set-tree) depth))))
	    ;; I figure the collision nodes are probably the smaller of the two.
	    ((consp map-tree)
	     (let ((result nil))
	       (do-wb-map-tree-pairs (k v (cdr map-tree))
		 (when (ch-set-tree-contains? set-tree k key-hash-fn key-cmp-fn depth)
		   (setq result (ch-map-tree-with result k v key-hash-fn key-cmp-fn val-hash-fn (fn (_ _)) depth))))
	       result))
	    ((consp set-tree)
	     (let ((result nil))
	       (do-wb-set-tree-members (k (cdr set-tree))
		 (let ((v? v (ch-map-tree-lookup map-tree k key-hash-fn key-cmp-fn depth)))
		   (when v?
		     (setq result (ch-map-tree-with result k v key-hash-fn key-cmp-fn val-hash-fn (fn (_ _))
						    depth)))))
	       result))
	    (t
	     (let ((entries1 (ch-map-node-entry-mask map-tree))
		   (entries2 (ch-set-node-entry-mask set-tree))
		   (subnodes1 (ch-map-node-subnode-mask map-tree))
		   (subnodes2 (ch-set-node-subnode-mask set-tree))
		   ((combined-mask (logand (logior entries1 subnodes1) (logior entries2 subnodes2)))
		    ;; The result can be longer than either input, because the restriction of two subnodes
		    ;; could be an entry.
		    ((res-len (+ ch-map-node-header-size (* 2 (logcount combined-mask))))
		     ((res-n (make-array res-len :initial-element 0))))))
	       (setf (ch-map-node-value-hash res-n) nil)
	       (flet ((add-entry (idx key val)
			(ch-map-node-add-entry res-n idx key val key-hash-fn))
		      (add-subnode (idx subnode)
			(ch-map-node-add-subnode res-n idx subnode key-hash-fn))
		      (map-lookup (map-subtree key)
			(ch-map-tree-lookup map-subtree key key-hash-fn key-cmp-fn (1+ depth)))
		      (set-contains? (set-subtree key)
			(ch-set-tree-contains? set-subtree key key-hash-fn key-cmp-fn (1+ depth))))
		 (do-bit-indices (idx combined-mask)
		   (cond ((and (logbitp idx entries1) (logbitp idx entries2))
			  (let ((key1 val1 (ch-map-node-entry map-tree (1-bits-below idx entries1)))
				(key2 (ch-set-node-entry set-tree (1-bits-below idx entries2))))
			    (when (equal?-cmp key1 key2 key-cmp-fn)
			      (add-entry idx key1 val1))))
			 ((and (logbitp idx entries1) (logbitp idx subnodes2))
			  (let ((key1 val1 (ch-map-node-entry map-tree (1-bits-below idx entries1)))
				(subnode2 (ch-set-node-subnode set-tree (1-bits-below idx subnodes2))))
			    (when (set-contains? subnode2 key1)
			      (add-entry idx key1 val1))))
			 ((and (logbitp idx subnodes1) (logbitp idx entries2))
			  (let ((subnode1 (ch-map-node-subnode map-tree (1-bits-below idx subnodes1)))
				(key2 (ch-set-node-entry set-tree (1-bits-below idx entries2)))
				((val1? val1 (map-lookup subnode1 key2))))
			    (when val1?
			      (add-entry idx key2 val1))))
			 ((and (logbitp idx subnodes1) (logbitp idx subnodes2))
			  (add-subnode idx (rec (ch-map-node-subnode map-tree (1-bits-below idx subnodes1))
						(ch-map-node-subnode set-tree (1-bits-below idx subnodes2))
						(1+ depth))))))
		 (ch-map-compact-node res-n))))))))

(defun ch-map-tree-restrict-not (map-tree set-tree key-hash-fn key-cmp-fn val-hash-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function key-hash-fn key-cmp-fn val-hash-fn))
  (rlabels (rec map-tree set-tree 0)
    (rec (map-tree set-tree depth)
      (declare (type (integer 0 64) depth))
      (cond ((or (null map-tree) (null set-tree)) nil)
	    ((and (consp map-tree) (consp set-tree))
	     (if (= (the fixnum (caar map-tree)) (the fixnum (car set-tree)))
		 (let ((result (wb-map-tree-restrict-not (cdr map-tree) (cdr set-tree) key-cmp-fn)))
		   (ch-map-node-from-wb result (car set-tree) depth))
	       map-tree))
	    ((consp map-tree)
	     (let ((result nil))
	       (do-wb-map-tree-pairs (k v (cdr map-tree))
		 (unless (ch-set-tree-contains? set-tree k key-hash-fn key-cmp-fn depth)
		   (setq result (wb-map-tree-with result k v key-cmp-fn (fn (_ _))))))
	       (ch-map-node-from-wb result (caar map-tree) depth)))
	    ((consp set-tree)
	     (do-wb-set-tree-members (k (cdr set-tree))
	       (setq map-tree (ch-map-tree-less map-tree k key-hash-fn key-cmp-fn val-hash-fn depth)))
	     map-tree)
	    (t
	     (let ((entries1 (ch-map-node-entry-mask map-tree))
		   (entries2 (ch-set-node-entry-mask set-tree))
		   (subnodes1 (ch-map-node-subnode-mask map-tree))
		   (subnodes2 (ch-set-node-subnode-mask set-tree))
		   ;; The result can be longer than `map-tree', because the restriction of two subnodes
		   ;; could be an entry.
		   ((res-len (+ ch-map-node-header-size
				(* 2 (+ (logcount entries1) (logcount subnodes1)))))
		    ((res-n (make-array res-len :initial-element 0)))))
	       (setf (ch-map-node-value-hash res-n) nil)
	       (flet ((add-entry (idx key val)
			(ch-map-node-add-entry res-n idx key val key-hash-fn))
		      (add-subnode (idx subnode)
			(ch-map-node-add-subnode res-n idx subnode key-hash-fn))
		      (map-subtree-less (subtree key)
			(ch-map-tree-less subtree key key-hash-fn key-cmp-fn val-hash-fn (1+ depth)))
		      (set-contains? (set-subtree key)
			(ch-set-tree-contains? set-subtree key key-hash-fn key-cmp-fn (1+ depth))))
		 (do-bit-indices (idx (logior entries1 subnodes1))
		   (cond ((logbitp idx entries1)
			  (let ((key1 val1 (ch-map-node-entry map-tree (1-bits-below idx entries1))))
			    (cond ((logbitp idx entries2)
				   (let ((key2 (ch-set-node-entry set-tree (1-bits-below idx entries2))))
				     (unless (equal?-cmp key1 key2 key-cmp-fn)
				       (add-entry idx key1 val1))))
				  ((logbitp idx subnodes2)
				   (let ((subnode2 (ch-set-node-subnode set-tree (1-bits-below idx subnodes2))))
				     (unless (set-contains? subnode2 key1)
				       (add-entry idx key1 val1))))
				  (t (add-entry idx key1 val1)))))
			 ((logbitp idx subnodes1)
			  (let ((subnode1 (ch-map-node-subnode map-tree (1-bits-below idx subnodes1))))
			    (cond ((logbitp idx entries2)
				   (let ((key2 (ch-set-node-entry set-tree (1-bits-below idx entries2))))
				     (add-subnode idx (map-subtree-less subnode1 key2))))
				  ((logbitp idx subnodes2)
				   (let ((subnode2 (ch-set-node-subnode set-tree (1-bits-below idx subnodes2))))
				     (add-subnode idx (rec subnode1 subnode2 (1+ depth)))))
				  (t (add-subnode idx subnode1)))))))
		 (ch-map-compact-node res-n))))))))

(defun ch-map-node-from-wb (wb-map-tree key-hash depth)
  (declare (optimize (speed 3) (safety 0)))
  (case (wb-map-tree-size wb-map-tree)
    (0 nil)
    (1 (let ((k v (wb-map-tree-arb-pair wb-map-tree)))
	 (vector (ash 1 (champ-hash-bits key-hash depth))
		 0 1 key-hash nil k v)))
    (t (cons (cons key-hash nil) wb-map-tree))))

(defun ch-map-compact-node (n)
  (declare (optimize (speed 3) (safety 0)))
  (let ((entries (ch-map-node-entry-mask n))
	(subnodes (ch-map-node-subnode-mask n)))
    (and (or (/= entries 0) (/= subnodes 0))
	 (let ((len (length (the simple-vector n)))
	       (n-entries (logcount entries))
	       ((extra (- len ch-map-node-header-size (* 2 n-entries) (logcount subnodes)))))
	   (when (< extra 0)
	     (error "Bug!  Not enough space allocated for ch-map-node"))
	   (if (= extra 0) n
	     (vector-remove-n-at n (+ ch-map-node-header-size (* 2 n-entries)) extra))))))

(defun ch-map-tree-compose (tree fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function fn))
  (cond ((null tree) nil)
	((consp tree)
	 (wb-map-tree-compose tree fn))
	(t
	 (let ((n (make-array (length (the simple-vector tree)) :initial-element 0)))
	   (dotimes (i (logcount (ch-map-node-entry-mask tree)))
	     (let ((entry-idx (+ ch-map-node-header-size (* 2 i))))
	       (setf (svref n entry-idx) (svref tree entry-idx))
	       (setf (svref n (1+ entry-idx)) (funcall fn (svref tree (1+ entry-idx))))))
	   (dotimes (i (logcount (ch-map-node-subnode-mask tree)))
	     (let ((subnode-idx (- (length (the simple-vector tree)) i 1)))
	       (setf (svref n subnode-idx)
		     (ch-map-tree-compose (svref tree subnode-idx) fn))))
	   (setf (ch-map-node-entry-mask n) (ch-map-node-entry-mask tree))
	   (setf (ch-map-node-subnode-mask n) (ch-map-node-subnode-mask tree))
	   (setf (ch-map-node-size n) (ch-map-node-size tree))
	   (setf (ch-map-node-key-hash n) (ch-map-node-key-hash tree))
	   (setf (ch-map-node-value-hash n) nil)
	   n))))

(defun ch-map-tree-verify (tree key-hash-fn val-hash-fn)
  (or (null tree)
      (rlabels (rec tree 0 0)
	(rec (node depth partial-hash)
	  (macrolet ((test (form)
		       `(or ,form
			    (progn
			      (cerror "Ignore and proceed."
				      "Verification check failed at ~:A: ~S" (path depth partial-hash) ',form)
			      nil))))
	    (let ((entry-mask (ch-map-node-entry-mask node))
		  (subnode-mask (ch-map-node-subnode-mask node))
		  ((entry-bits (bit-indices entry-mask))
		   (subnode-bits (bit-indices subnode-mask))))
	      (and (test (= 0 (logand entry-mask subnode-mask)))
		   (test (= 0 (ash entry-mask (- champ-node-radix))))
		   (test (= 0 (ash subnode-mask (- champ-node-radix))))
		   (test (= (length node)
			    (+ ch-map-node-header-size (* 2 (logcount entry-mask)) (logcount subnode-mask))))
		   ;; Check that unless root, this node does not contain only an entry ...
		   (test (not (and (> depth 0) (= 1 (logcount entry-mask)) (= 0 subnode-mask))))
		   ;; ... or only a collision subnode
		   (test (not (and (> depth 0) (= 0 entry-mask) (= 1 (logcount subnode-mask))
				   (consp (svref node (1- (length node)))))))
		   (let ((size (logcount entry-mask))
			 (node-key-hash 0)
			 (node-value-hash 0))
		     (and
		       ;; Check entry key hashes
		       (gmap :and (fn (key-idx hash-bits)
				    (let ((key (svref node (+ ch-map-node-header-size (* 2 key-idx))))
					  ((key-hash (hash-to-fixnum key key-hash-fn)))
					  (value (svref node (+ ch-map-node-header-size (1+ (* 2 key-idx))))))
				      (hash-mixf node-key-hash key-hash)
				      (when (ch-map-node-value-hash node)
					(hash-mixf node-value-hash (hash-to-fixnum value val-hash-fn)))
				      (test (= (ldb (byte (* champ-hash-bits-per-level (1+ depth)) 0)
						    key-hash)
					       (new-partial-hash hash-bits depth partial-hash)))))
			     (:arg index 0)
			     (:arg list entry-bits))
		       ;; Verify subnodes
		       (gmap :and (fn (subnode-idx hash-bits)
				    (let ((subnode (svref node (- (length node) 1 subnode-idx))))
				      (if (consp subnode)
					  (let ((key-hash (hash-to-fixnum (wb-map-tree-arb-pair (cdr subnode))
									  key-hash-fn))
						(vhash 0))
					    (test (consp (car subnode)))
					    (test (> (wb-map-tree-size (cdr subnode)) 1))
					    (do-wb-map-tree-pairs (k v (cdr subnode))
					      (let ((kh (hash-to-fixnum k key-hash-fn)))
						(test (= kh key-hash))
						(when (cdar subnode)
						  (hash-mixf vhash (hash-to-fixnum v val-hash-fn)))))
					    (hash-mixf node-key-hash key-hash)
					    (incf size (wb-map-tree-size (cdr subnode)))
					    (when (cdar subnode)
					      (test (= (cdar subnode) vhash))
					      (hash-mixf node-value-hash vhash))
					    (test (= (caar subnode) key-hash)))
					(and (rec subnode (1+ depth) (new-partial-hash hash-bits depth partial-hash))
					     (progn
					       (incf size (ch-map-node-size subnode))
					       (hash-mixf node-key-hash (ch-map-node-key-hash subnode))
					       (when (ch-map-node-value-hash node)
						 (hash-mixf node-value-hash (ch-map-node-value-hash subnode)))
					       t)))))
			     (:arg index 0)
			     (:arg list subnode-bits))
		       ;; Finally, check size and hashes
		       (test (= (ch-map-node-size node) size))
		       (test (= (ch-map-node-key-hash node) node-key-hash))
		       (or (null (ch-map-node-value-hash node))
			   (test (= (ch-map-node-value-hash node) node-value-hash)))))))))
	(new-partial-hash (hash-bits depth partial-hash)
	  (dpb hash-bits (byte champ-hash-bits-per-level (* champ-hash-bits-per-level depth))
	       partial-hash))
	(path (depth partial-hash)
	  (let ((path nil))
	    (dotimes (i depth)
	      (push (ldb (byte champ-hash-bits-per-level (* i champ-hash-bits-per-level))
			 partial-hash)
		    path))
	    (nreverse path))))))

    
