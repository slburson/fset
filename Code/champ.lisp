;;; -*- Mode: Lisp; Package: FSet; Syntax: ANSI-Common-Lisp -*-

;;; File: champ.lisp
;;; Contents: CHAMP implementation for FSet.
;;; See: https://michael.steindorfer.name/publications/phd-thesis-efficient-immutable-collections.pdf
;;;
;;; This file is part of FSet.  Copyright (c) 2024-2025 Scott L. Burson.
;;; FSet is licensed under the 2-clause BSD license; see LICENSE.
;;; This license provides NO WARRANTY.

(in-package :fset)

#||

Our implementation differs slightly from the published CHAMP algorithm.  It is agnostic as to the
number of bits in the hash values; it will use as many as are provided, up to the fixnum size.  A
collision can be detected at any level, when two members/keys hash to the same value but `equal?'
is false on them.  When that happens, we fall back to using a WB-tree for those entries.  The
resulting collision node will be as high in the tree as possible given that it can contain only
keys with that hash value; this can require pushing it down an arbitrary number of levels when
adding a new key.

As Steindorfer recommends, we do go to the trouble to canonicalize on deletion, so that the shape of
the tree is a function of the members/keys, i.e., is independent of how the tree was constructed.
The two-tree algorithms (`compare', `union', etc.) take considerable advantage of this fact.

||#


;;; ================================================================================
;;; Global constants

;;; `eval-when' needed in Allegro to make the `deftype' work.
(eval-when (:compile-toplevel :load-toplevel :execute)
  (defconstant champ-hash-bits-per-level
    ;; Drops to 4 on 32-bit implementations.
    (min 5 (- (integer-length (1+ (* 2 (integer-length most-positive-fixnum)))) 2)))
  (defconstant champ-node-radix (ash 1 champ-hash-bits-per-level))
  (defconstant champ-hash-level-mask (1- champ-node-radix)))
(deftype champ-bit-index () `(integer 0 ,(1- champ-node-radix)))
;;; These have the same bounds but are logically different types.
(deftype champ-entry-index () `(integer 0 ,(1- champ-node-radix)))
(deftype champ-subnode-index () `(integer 0 ,(1- champ-node-radix)))

(declaim (inline champ-hash-bits)
	 (ftype (function (fixnum fixnum) champ-bit-index) champ-hash-bits))
(defun champ-hash-bits (hash depth)
  (ldb (byte champ-hash-bits-per-level (* depth champ-hash-bits-per-level))
       hash))

(declaim (inline 1-bits-below))
(defun 1-bits-below (idx mask)
  "The number of 1 bits in `mask' at bit positions (strictly) less than `idx'."
  (declare (optimize (speed 3))
	   (type champ-bit-index idx)
	   (fixnum mask))
  (logcount (logand (1- (the fixnum (ash 1 idx))) mask)))

(declaim (inline least-1-bit))
(defun least-1-bit (n)
  (declare (optimize (speed 3) (safety 0))
	   (fixnum n))
  ;; Suggested by Stas Boukarev for SBCL.
  #+sbcl
  (the champ-bit-index (logcount (ldb (byte 64 0) (lognor n (- n)))))
  ;; This gives better code on CCL (and yes, `the fixnum' helps).  I haven't checked any others.
  #-sbcl
  (1- (logcount (logxor n (the fixnum (1- n))))))

(defmacro do-bit-indices ((idx-var val &optional result) &body body)
  (let ((val-var (gensymx #:val-)))
    `(let ((,val-var ,val))
       (declare (fixnum ,val-var))
       (do ((,idx-var (least-1-bit ,val-var) (least-1-bit ,val-var)))
	   ((= 0 ,val-var) ,result)
	 (logandc2f ,val-var (ash 1 ,idx-var))
	. ,body))))

;;; Verification utility, used to recover hash bits from masks.
(defun bit-indices (mask)
  "A list of the indices of the 1 bits of `mask', in ascending order."
  (let ((result nil))
    (do-bit-indices (i mask (nreverse result))
      (push i result))))


;;; Although we tell people that the hash function must return a fixnum, we
;;; have no way to enforce that, so just to be sure, we check the return value.
;;; A fixnum test is pretty cheap on most platforms.
(defmacro hash-to-fixnum (val hash-fn)
  `(let ((h (funcall ,hash-fn ,val)))
     (if (typep h 'fixnum)
	 h
       (the fixnum (squash-bignum-hash h)))))


;;; ================================================================================
;;; Sets

(defstruct (ch-set-node
	     (:constructor nil)
	     (:type vector))
  ;; It's more convenient for these slots to be mutable... since the nodes are just vectors anyway, we
  ;; can't completely prevent a client from stupidly bashing them.
  (entry-mask 0 :type fixnum)
  (subnode-mask 0 :type fixnum)
  (size 0 :type fixnum) ; total number of elements at or below this node
  (hash-value 0 :type fixnum))
(defconstant ch-set-node-header-size 4)
;;; Includes one slot for the transient-id.
(defconstant ch-set-node-transient-space 5
  "The number of extra slots to allocate in a transient set node.")

(deftype ch-set-tree ()
  '(or null cons simple-vector))

(declaim (ftype (function (ch-set-tree) fixnum) ch-set-tree-size))
(declaim (inline ch-set-tree-size))
(defun ch-set-tree-size (tree)
  (cond ((null tree) 0)
	((consp tree)
	 (wb-set-tree-size (cdr tree)))
	(t (ch-set-node-size tree))))

(declaim (inline ch-set-tree-hash-value))
(defun ch-set-tree-hash-value (tree)
  (cond ((null tree) 0)
	((consp tree) (the fixnum (car tree)))
	(t (ch-set-node-hash-value tree))))

(declaim (inline make-ch-set-node))
(defun make-ch-set-node (transient-id entry-mask subnode-mask size hash-value &rest contents)
  (declare (optimize (speed 3) (safety 0))
	   (dynamic-extent contents))
  (if transient-id
      (make-transient-ch-set-node transient-id entry-mask subnode-mask size hash-value contents)
    (apply #'vector entry-mask subnode-mask size hash-value contents)))

(defun make-transient-ch-set-node (transient-id entry-mask subnode-mask size hash-value contents)
  (declare (optimize (speed 3) (safety 0))
	   (fixnum entry-mask subnode-mask))
  (let ((n-entries (logcount entry-mask))
	((n (make-array (+ ch-set-node-header-size n-entries (logcount subnode-mask)
			   ch-set-node-transient-space))))
	(idx 0))
    (setf (ch-set-node-entry-mask n) entry-mask)
    (setf (ch-set-node-subnode-mask n) subnode-mask)
    (setf (ch-set-node-size n) size)
    (setf (ch-set-node-hash-value n) hash-value)
    (dolist (x contents)
      (when (= idx n-entries)
	(incf idx ch-set-node-transient-space))
      (setf (svref n (+ idx ch-set-node-header-size)) x)
      (incf idx))
    (setf (svref n (+ ch-set-node-header-size n-entries)) transient-id)
    n))

(declaim (inline ch-set-node-entry))
(defun ch-set-node-entry (n ientry)
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector n)
	   (type champ-entry-index ientry))
  (svref n (+ ch-set-node-header-size ientry)))

(declaim (inline ch-set-node-subnode))
(defun ch-set-node-subnode (n isubnode)
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector n)
	   (type champ-subnode-index isubnode))
  (svref n (- (length n) isubnode 1)))

(defun ch-set-tree-with (tree value hash-fn compare-fn &optional transient-id (depth 0) replace?)
  "Second value is true iff the tree changed; the result can be eq to `tree', even
if it changed, if `transient-id' is supplied."
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn)
	   (type (integer 0 64) depth))
  (let ((value-hash (hash-to-fixnum value hash-fn)))
    (declare (fixnum value-hash))
    (rlabels (rec tree (ash value-hash (- (* champ-hash-bits-per-level depth))) depth)
      (rec (node hash-shifted depth)
	(declare (fixnum hash-shifted)
		 (type (integer 0 64) depth))
	(let ((hash-bits (logand hash-shifted champ-hash-level-mask)))
	  (if (null node)
	      (values (make-ch-set-node transient-id (ash 1 hash-bits) 0 1 value-hash value) t)
	    (if (consp node)
		;; We can create collision nodes at any level (see below).  -- Well, not at the root.  But
		;; this is called from elsewhere (e.g. `-union') on subtrees, which might be collision nodes.
		(let ((wb-hash-shifted (ash (the fixnum (car node)) (- (* champ-hash-bits-per-level depth))))
		      (size (1+ (wb-set-tree-size (cdr node)))))
		  (declare (fixnum wb-hash-shifted size))
		  (if (= hash-shifted wb-hash-shifted)
		      ;; Update the collision node.
		      (let ((new-wb-tree (wb-set-tree-with (if replace? (wb-set-tree-less (cdr node) value compare-fn)
							     (cdr node))
							   value compare-fn)))
			(if (eq new-wb-tree (cdr node))
			    (values node nil)
			  ;; New entry in collision node
			  (values (cons (car node) new-wb-tree) t)))
		    (let ((hash-bits (logand hash-shifted champ-hash-level-mask))
			  (wb-hash-bits (logand wb-hash-shifted champ-hash-level-mask))
			  (content-hash (hash-mix (car node) value-hash)))
		      (values (if (= hash-bits wb-hash-bits)
				  (make-ch-set-node transient-id 0 (ash 1 hash-bits) size content-hash
						    (rec node (ash hash-shifted (- champ-hash-bits-per-level))
							 (1+ depth)))
				(make-ch-set-node transient-id (ash 1 hash-bits) (ash 1 wb-hash-bits) size content-hash
						  value node))
			      t))))
	      ;; Normal case
	      (let ((entry-mask (ch-set-node-entry-mask node))
		    ((entry-raw-idx (1-bits-below hash-bits entry-mask))
		     ((entry-idx (+ ch-set-node-header-size entry-raw-idx))))
		    (subnode-mask (ch-set-node-subnode-mask node))
		    ((subnode-raw-idx (1-bits-below hash-bits subnode-mask))
		     ((subnode-idx (- (the fixnum (length node)) 1 subnode-raw-idx)))))
		(declare (fixnum entry-mask entry-raw-idx entry-idx subnode-mask subnode-raw-idx subnode-idx))
		(if (logbitp hash-bits entry-mask)
		    ;; Entry found
		    (let ((ex-value (svref node entry-idx)))
		      (if (equal?-cmp value ex-value compare-fn)
			  (if (and replace? (not (gen eql value ex-value)))
			      (values (ch-set-node-update transient-id node entry-idx value) t)
			    (values node nil))
			;; Entry with different value found: make a subnode
			(let ((hash-shifted (ash hash-shifted (- champ-hash-bits-per-level)))
			      (ex-value-hash (hash-to-fixnum ex-value hash-fn))
			      ((ex-value-hash-shifted (ash ex-value-hash (* (- champ-hash-bits-per-level) (1+ depth))))
			       ((n2 (if (= hash-shifted ex-value-hash-shifted)
					;; Collision!  Fall back to WB-tree.
					(cons value-hash (wb-set-tree-with (wb-set-tree-with nil ex-value compare-fn)
									   value compare-fn))
				      ;; Turn the entry into a subnode and recur.
				      (rec (make-ch-set-node transient-id (ash 1 (logand ex-value-hash-shifted
											 champ-hash-level-mask))
							     0 1 ex-value-hash ex-value)
					   hash-shifted (1+ depth))))
				((n (ch-set-node-rem-1-ins-1 transient-id node entry-idx subnode-idx n2))))))
			  (logandc2f (ch-set-node-entry-mask n) (ash 1 hash-bits))
			  (logiorf (ch-set-node-subnode-mask n) (ash 1 hash-bits))
			  (incf (ch-set-node-size n))
			  (unless (consp n2)
			    (hash-mixf (ch-set-node-hash-value n) value-hash))
			  (if (and (> depth 0) (consp n2)
				   (zerop (ch-set-node-entry-mask n))
				   (= 1 (logcount (ch-set-node-subnode-mask n))))
			      (values n2 t)
			    (values n t)))))
		  ;; No entry found: check for subnode
		  (if (logbitp hash-bits subnode-mask)
		      ;; Subnode found
		      (let ((subnode (svref node subnode-idx))
			    ((old-subnode-size (ch-set-tree-size subnode))
			     (old-subnode-hash (ch-set-tree-hash-value subnode))
			     (new-subnode changed?
			       (rec subnode (ash hash-shifted (- champ-hash-bits-per-level)) (1+ depth)))))
			(if (not changed?)
			    (values node nil)
			  ;; New subnode
     			  (let ((n (ch-set-node-update transient-id node subnode-idx new-subnode)))
			    (incf (ch-set-node-size n)
				  (- (ch-set-tree-size new-subnode) old-subnode-size))
			    (hash-mixf (ch-set-node-hash-value n)
				       (hash-unmix (ch-set-tree-hash-value new-subnode) old-subnode-hash))
			    (values n t))))
		    ;; Neither entry nor subnode found: make new entry
		    (let ((n (ch-set-node-insert transient-id node entry-idx value)))
		      (logiorf (ch-set-node-entry-mask n) (ash 1 hash-bits))
		      (incf (ch-set-node-size n))
		      (hash-mixf (ch-set-node-hash-value n) value-hash)
		      (values n t))))))))))))

(declaim (inline reuse-ch-set-node?))
(defun reuse-ch-set-node? (transient-id node node-len)
  (declare (optimize (speed 3) (safety 0))
	   (simple-vector node)
	   (fixnum node-len)
	   (type (or null fixnum) transient-id))
  (and transient-id
       (let ((n-entries (logcount (ch-set-node-entry-mask node)))
	     (n-subnodes (logcount (ch-set-node-subnode-mask node))))
	 (and (> node-len (+ ch-set-node-header-size n-entries n-subnodes))
	      (eql transient-id (the fixnum (svref node (+ ch-set-node-header-size n-entries))))))))

(defun ch-set-node-insert (transient-id node idx val)
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector node)
	   (type (and fixnum unsigned-byte) idx))
  (let ((len (length node))
	(n-entries (logcount (ch-set-node-entry-mask node)))
	(n-subnodes (logcount (ch-set-node-subnode-mask node)))
	((hdr+entries (+ ch-set-node-header-size n-entries))))
    (if (reuse-ch-set-node? transient-id node len)
	;; When there's exactly one extra element, it must contain the transient-id, which we will now
	;; overwrite; the node is about to become persistent anyway, when the new entry mask bit is set.
	(let ((move-end (min (1+ hdr+entries) (- len n-subnodes 1))))	; include transient-id unless full
	  (dotimes (i (- move-end idx))
	    (setf (svref node (- move-end i)) (svref node (- move-end i 1))))
	  (setf (svref node idx) val)
	  node)
      (let ((min-len (+ hdr+entries n-subnodes 1))
	    ((new-len (if transient-id (min (+ min-len ch-set-node-transient-space)
					    (+ ch-set-node-header-size champ-node-radix 1))
			min-len))
	     ((n (make-array new-len)))))
	(when transient-id
	  (setf (svref n (1+ hdr+entries)) transient-id))
	(dotimes (i idx)
	  (setf (svref n i) (svref node i)))
	(setf (svref n idx) val)
	(dotimes (i (- hdr+entries idx))
	  (setf (svref n (+ idx i 1)) (svref node (+ idx i))))
	(dotimes (i n-subnodes)
	  (setf (svref n (- new-len i 1)) (svref node (- len i 1))))
	n))))

(defun ch-set-node-update (transient-id node idx val)
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector node)
	   (type fixnum idx))
  (let ((len (length node)))
    (if (reuse-ch-set-node? transient-id node len)
	(progn
	  (setf (svref node idx) val)
	  node)
      (let ((n-entries (logcount (ch-set-node-entry-mask node)))
	    (n-subnodes (logcount (ch-set-node-subnode-mask node)))
	    ((hdr+entries (+ ch-set-node-header-size n-entries))
	     ((min-len (+ hdr+entries n-subnodes))
	      ((new-len (if transient-id (min (+ min-len ch-set-node-transient-space)
					      (+ ch-set-node-header-size champ-node-radix 1))
			  min-len))
	       ((n (make-array new-len)))))))
	(when transient-id
	  (setf (svref n hdr+entries) transient-id))
	(dotimes (i hdr+entries)
	  (setf (svref n i) (svref node i)))
	(dotimes (i n-subnodes)
	  (setf (svref n (- new-len i 1)) (svref node (- len i 1))))
	(if (< idx hdr+entries)
	    (setf (svref n idx) val)
	  (setf (svref n (+ idx (- new-len len))) val))
	n))))

(defun ch-set-node-rem-1-ins-1 (transient-id node rem-idx ins-idx ins-val)
  "`ins-idx' is where `ins-val' will end up, i.e., the index of the existing
element it will be inserted _after_."
  (declare (optimize (speed 3) (safety 0))
	   (simple-vector node)
	   (type (and fixnum unsigned-byte) rem-idx ins-idx))
  (assert (<= rem-idx ins-idx))
  (let ((len (length node)))
    (if (reuse-ch-set-node? transient-id node len)
	(progn
	  (dotimes (i (- ins-idx rem-idx))
	    (setf (svref node (+ rem-idx i)) (svref node (+ rem-idx i 1))))
	  (setf (svref node ins-idx) ins-val)
	  node)
      (let ((n-entries (logcount (ch-set-node-entry-mask node)))
	    (n-subnodes (logcount (ch-set-node-subnode-mask node)))
	    ((hdr+entries (+ ch-set-node-header-size n-entries))   ; value before removal
	     ((min-len (+ hdr+entries n-subnodes))
	      ((new-len (if transient-id (min (+ min-len ch-set-node-transient-space)
					      (+ ch-set-node-header-size champ-node-radix 1))
			  min-len))
	       ((n (make-array new-len))
		(new-ins-idx (+ ins-idx (- new-len len))))))))
	(when transient-id
	  (setf (svref n (1- hdr+entries)) transient-id))
	(assert (and (< rem-idx hdr+entries) (>= ins-idx (1- hdr+entries))))
	(dotimes (i rem-idx)							; copy [0..rem-idx)
	  (setf (svref n i) (svref node i)))
	(dotimes (i (- hdr+entries rem-idx 1))					; move (rem-idx..hdr+entries) down 1
	  (setf (svref n (+ rem-idx i)) (svref node (+ rem-idx i 1))))
	(dotimes (i (- len ins-idx 1))						; copy (ins-idx..len)
	  (setf (svref n (- new-len i 1)) (svref node (- len i 1))))
	(setf (svref n new-ins-idx) ins-val)					; store ins-idx
	(dotimes (i (- n-subnodes (- len ins-idx 1)))				; copy remaining subnodes
	  (setf (svref n (- new-ins-idx i 1)) (svref node (- ins-idx i))))
	n))))

(defun ch-set-tree-less (tree value hash-fn compare-fn &optional transient-id (depth 0))
  "Second value is true iff the tree changed; the result can be eq to `tree', even
if it changed, if `transient-id' is supplied."
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn)
	   (type (integer 0 64) depth))
  (let ((value-hash (hash-to-fixnum value hash-fn)))
    (declare (fixnum value-hash))
    (rlabels (rec tree (ash value-hash (- (* champ-hash-bits-per-level depth))))
      (rec (node hash-shifted)
	(declare (fixnum hash-shifted))
	(and node
	     (if (consp node)
		 (let ((new-wb-tree (wb-set-tree-less (cdr node) value compare-fn)))
		   (if (eq new-wb-tree (cdr node))
		       (values node nil)
		     (if (= 1 (wb-set-tree-size new-wb-tree))
			 ;; Removing next-to-last entry of collision node: turn remaining value into entry
			 (let ((rem-val (wb-set-tree-arb new-wb-tree))
			       (hash-bits (logand hash-shifted champ-hash-level-mask)))
			   (values (make-ch-set-node transient-id (ash 1 hash-bits) 0 1 value-hash rem-val) t))
		       (values (cons (car node) new-wb-tree) t))))
	       (let ((hash-bits (logand hash-shifted champ-hash-level-mask))
		     (entry-mask (ch-set-node-entry-mask node))
		     ((entry-raw-idx (1-bits-below hash-bits entry-mask))
		      ((entry-idx (+ ch-set-node-header-size entry-raw-idx))))
		     (subnode-mask (ch-set-node-subnode-mask node)))
		 (if (logbitp hash-bits entry-mask)
		     (let ((ex-value (svref node entry-idx)))
		       (cond ((not (equal?-cmp ex-value value compare-fn))
			      (values node nil))
			     ((and (= (logcount entry-mask) 1) (= 0 subnode-mask))
			      (assert (= depth 0))
			      (values nil t))
			     (t
			      (let ((n (ch-set-node-remove transient-id node entry-idx)))
				(logandc2f (ch-set-node-entry-mask n) (ash 1 hash-bits))
				(decf (ch-set-node-size n))
				(hash-unmixf (ch-set-node-hash-value n) value-hash)
				(values n t)))))
		   (let ((subnode-raw-idx (1-bits-below hash-bits subnode-mask))
			 ((subnode-idx (- (length node) 1 subnode-raw-idx))))
		     (if (not (logbitp hash-bits subnode-mask))
			 (values node nil)
		       (let ((subnode (svref node subnode-idx))
			     ((old-subnode-size (ch-set-tree-size subnode))
			      (old-subnode-hash (ch-set-tree-hash-value subnode))
			      (new-subnode changed?
				(rec subnode (ash hash-shifted (- champ-hash-bits-per-level))))))
			 (if (not changed?)
			     (values node nil)
			   (let ((n (cond ((consp new-subnode)
					   (ch-set-node-update transient-id node subnode-idx new-subnode))
					  ((and (= 1 (logcount (ch-set-node-entry-mask new-subnode)))
						(= 0 (ch-set-node-subnode-mask new-subnode)))
					   ;; New subnode contains only a single entry: pull it up into this node
					   (let ((new-entry-idx
						   (+ ch-set-node-header-size (1-bits-below hash-bits entry-mask)))
						 ((n (ch-set-node-ins-1-rem-1
						       transient-id node new-entry-idx
						       (svref new-subnode ch-set-node-header-size) subnode-idx))))
					     (logiorf (ch-set-node-entry-mask n) (ash 1 hash-bits))
					     (logandc2f (ch-set-node-subnode-mask n) (ash 1 hash-bits))
					     n))
					  ((let ((only-subnode))  ; wow, I actually needed `new-let:cond' here!
					     (and (= 0 (ch-set-node-entry-mask new-subnode))
						  (= 1 (logcount (ch-set-node-subnode-mask new-subnode)))
						  (consp (setq only-subnode (ch-set-node-subnode new-subnode 0)))))
					   ;; New subnode contains only a collision node: pull it up into this node
					   (ch-set-node-update transient-id node subnode-idx only-subnode))
					  (t (ch-set-node-update transient-id node subnode-idx new-subnode)))))
			     (incf (ch-set-node-size n)
				   (- (ch-set-tree-size new-subnode) old-subnode-size))
			     (hash-mixf (ch-set-node-hash-value n)
					(hash-unmix (ch-set-tree-hash-value new-subnode) old-subnode-hash))
			     (values n t))))))))))))))

(defun ch-set-node-remove (transient-id node idx)
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector node)
	   (type (unsigned-byte 24) idx))
  (let ((len (length node)))
    (if (reuse-ch-set-node? transient-id node len)
	(let ((n-entries (logcount (ch-set-node-entry-mask node)))
	      ((move-end (+ ch-set-node-header-size n-entries 1))))
	  (dotimes (i (- move-end idx 1))
	    (setf (svref node (+ idx i)) (svref node (+ idx i 1))))
	  node)
      (let ((n-entries (logcount (ch-set-node-entry-mask node)))
	    (n-subnodes (logcount (ch-set-node-subnode-mask node)))
	    ((hdr+entries (+ ch-set-node-header-size n-entries)) ; value before removal
	     ((min-len (+ hdr+entries n-subnodes -1))
	      ((new-len (if transient-id (min (+ min-len ch-set-node-transient-space)
					      (+ ch-set-node-header-size champ-node-radix 1))
			  min-len))
	       ((n (make-array new-len)))))))
	(when transient-id
	  (setf (svref n (1- hdr+entries)) transient-id))
	(dotimes (i idx)
	  (setf (svref n i) (svref node i)))
	(dotimes (i (- hdr+entries idx 1))
	  (setf (svref n (+ idx i)) (svref node (+ idx i 1))))
	(dotimes (i n-subnodes)
	  (setf (svref n (- new-len i 1)) (svref node (- len i 1))))
	n))))

(defun ch-set-node-ins-1-rem-1 (transient-id node ins-idx ins-val rem-idx)
  (declare (optimize (speed 3) (safety 0))
	   (simple-vector node)
	   (type (and fixnum unsigned-byte) rem-idx ins-idx))
  (assert (<= ins-idx rem-idx))
  (let ((len (length node)))
    (if (reuse-ch-set-node? transient-id node len)
	(progn
	  (dotimes (i (- rem-idx ins-idx))
	    (setf (svref node (- rem-idx i)) (svref node (- rem-idx i 1))))
	  (setf (svref node ins-idx) ins-val)
	  node)
      (let ((n-entries (logcount (ch-set-node-entry-mask node)))
	    (n-subnodes (logcount (ch-set-node-subnode-mask node)))
	    ((hdr+entries (+ ch-set-node-header-size n-entries))   ; value before insertion
	     ((min-len (+ hdr+entries n-subnodes))
	      ((new-len (if transient-id (min (+ min-len ch-set-node-transient-space)
					      (+ ch-set-node-header-size champ-node-radix 1))
			  min-len))
	       ((n (make-array new-len))
		(new-rem-idx (+ rem-idx (- new-len len))))))))
	(when transient-id
	  (setf (svref n (1+ hdr+entries)) transient-id))
	(assert (and (<= ins-idx hdr+entries) (>= rem-idx hdr+entries)))
	(dotimes (i ins-idx)							; copy [0..ins-idx)
	  (setf (svref n i) (svref node i)))
	(setf (svref n ins-idx) ins-val)					; store ins-idx
	(dotimes (i (- hdr+entries ins-idx))					; move [ins-idx..hdr+entries) up 1
	  (setf (svref n (- hdr+entries i)) (svref node (- hdr+entries i 1))))
	(dotimes (i (- len rem-idx 1))						; copy (rem-idx..len)
	  (setf (svref n (- new-len i 1)) (svref node (- len i 1))))
	(dotimes (i (- n-subnodes (- len rem-idx)))				; copy remaining subnodes
	  (setf (svref n (- new-rem-idx i)) (svref node (- rem-idx i 1))))
	n))))

(defun ch-set-tree-arb (tree)
  (declare (optimize (speed 3) (safety 0)))
  (cond ((null tree)
	 (error "'ch-set-tree-arb' called on empty tree"))
	((consp tree)
	 (wb-set-tree-arb (cdr tree)))
	((= 0 (ch-set-node-entry-mask tree))
	 ;; If there are no entries, there must be at least one subnode
	 (ch-set-tree-arb (svref tree (1- (length tree)))))
	(t
	 (svref tree ch-set-node-header-size))))

(defun ch-set-tree-contains? (tree value hash-fn compare-fn &optional (depth 0))
  "On success, returns the set element as the second value."
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn)
	   (type (integer 0 64) depth))
  (let ((value-hash (hash-to-fixnum value hash-fn)))
    (declare (fixnum value-hash))
    (rlabels (rec tree value (ash value-hash (- (* champ-hash-bits-per-level depth))))
      (rec (node value hash-shifted)
	(declare (fixnum hash-shifted))
	(and node
	     (if (consp node)
		 (wb-set-tree-find-equal (cdr node) value compare-fn)
	       (let ((hash-bits (logand hash-shifted champ-hash-level-mask))
		     (entry-mask (ch-set-node-entry-mask node)))
		 (if (logbitp hash-bits entry-mask)
		     (let ((entry-idx (+ ch-set-node-header-size (1-bits-below hash-bits entry-mask)))
			   ((ex-value (svref node entry-idx))))
		       (and (equal?-cmp ex-value value compare-fn)
			    (values t ex-value)))
		   (let ((subnode-mask (ch-set-node-subnode-mask node)))
		     (and (logbitp hash-bits subnode-mask)
			  (let ((subnode-idx (- (length node) 1 (1-bits-below hash-bits subnode-mask)))
				((subnode (svref node subnode-idx))))
			    (rec subnode value (ash hash-shifted (- champ-hash-bits-per-level))))))))))))))

(defun ch-set-tree-compare (tree1 tree2 compare-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function compare-fn))
  (if (eq tree1 tree2) ':equal
    (let ((size1 (ch-set-tree-size tree1))
	  (size2 (ch-set-tree-size tree2)))
      ;; There are various ways we could do this, but traditionally, FSet sorts on size first.
      (cond ((< size1 size2) ':less)
	    ((> size1 size2) ':greater)
	    (t
	     (let ((hash1 (ch-set-tree-hash-value tree1))
		   (hash2 (ch-set-tree-hash-value tree2)))
	       (cond ((< hash1 hash2) ':less)
		     ((> hash1 hash2) ':greater)
		     ((consp tree1)
		      (if (consp tree2) (wb-set-tree-compare (cdr tree1) (cdr tree2) compare-fn)
			':less))
		     ((consp tree2) ':greater)
		     (t
		      (let ((entries1 (ch-set-node-entry-mask tree1))
			    (entries2 (ch-set-node-entry-mask tree2))
			    (subnodes1 (ch-set-node-subnode-mask tree1))
			    (subnodes2 (ch-set-node-subnode-mask tree2)))
			(cond ((< entries1 entries2) ':less)
			      ((> entries1 entries2) ':greater)
			      ((< subnodes1 subnodes2) ':less)
			      ((> subnodes1 subnodes2) ':greater)
			      (t
			       ;; It's astronomically unlikely that we'll get here unless the trees are actually
			       ;; equal... but we still have to check.
			       (let ((default ':equal))
				 (dotimes (i (logcount entries1))
				   (let ((v1 (svref tree1 (+ ch-set-node-header-size i)))
					 (v2 (svref tree2 (+ ch-set-node-header-size i)))
					 ((cmp (funcall compare-fn v1 v2))))
				     (ecase cmp
				       (:equal)
				       (:unequal
					 (setq default ':unequal))
				       ((:less :greater)
					 (return-from ch-set-tree-compare cmp)))))
				 (let ((len1 (length tree1))   ; may be unequal because of transients
				       (len2 (length tree2)))
				   (dotimes (i (logcount subnodes1))
				     (let ((cmp (ch-set-tree-compare (svref tree1 (- len1 i 1))
								     (svref tree2 (- len2 i 1)) compare-fn)))
				       (ecase cmp
					 (:equal)
					 (:unequal
					   (setq default ':unequal))
					 ((:less :greater)
					   (return-from ch-set-tree-compare cmp))))))
				 default))))))))))))

(defun ch-set-tree-index (tree value hash-fn compare-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn))
  (let ((value-hash (hash-to-fixnum value hash-fn)))
    (declare (fixnum value-hash))
    (rlabels (rec tree value 0 value-hash)
      (rec (node value base hash-shifted)
	(declare (fixnum base hash-shifted))
	(and node
	     (if (consp node)
		 (let ((found? idx (wb-set-tree-rank (cdr node) value compare-fn)))
		   (and found? (the fixnum (+ (the fixnum idx) base))))
	       (let ((hash-bits (logand hash-shifted champ-hash-level-mask))
		     (entry-mask (ch-set-node-entry-mask node)))
		 (if (logbitp hash-bits entry-mask)
		     (let ((ientry (1-bits-below hash-bits entry-mask))
			   ((entry-idx (+ ch-set-node-header-size ientry))
			    ((ex-value (svref node entry-idx)))))
		       (and (equal?-cmp ex-value value compare-fn)
			    (the fixnum (+ base ientry))))
		   (let ((subnode-mask (ch-set-node-subnode-mask node)))
		     (incf base (logcount entry-mask))
		     (and (logbitp hash-bits subnode-mask)
			  (let ((isubnode (1-bits-below hash-bits subnode-mask))
				(len (length (the simple-vector node)))
				((subnode-idx (- len 1 isubnode))
				 ((subnode (svref node subnode-idx)))))
			    (dotimes (i isubnode)
			      (incf base (ch-set-tree-size (svref node (- len 1 i)))))
			    (rec subnode value base
				 (ash hash-shifted (- champ-hash-bits-per-level))))))))))))))

(defun ch-set-tree-index-element (tree index)
  (declare (optimize (speed 3) (safety 0)))
  (rlabels (rec tree index)
    (rec (tree index)
      (declare (fixnum index))
      (if (consp tree)
	  (wb-set-tree-rank-element (cdr tree) index)
	(let ((len (length (the simple-vector tree)))
	      (entry-mask (ch-set-node-entry-mask tree))
	      ((n-entries (logcount entry-mask))))
	  (if (< index n-entries)
	      (svref tree (+ ch-set-node-header-size index))
	    (let ((subnode-mask (ch-set-node-subnode-mask tree)))
	      (decf index n-entries)
	      (dotimes (i (logcount subnode-mask))
		(let ((subnode (svref tree (- len i 1)))
		      ((subnode-size (ch-set-tree-size subnode))))
		  (when (< index subnode-size)
		    (return (rec subnode index)))
		  (decf index subnode-size))))))))))

(defun vector-remove-n-at (vec idx n)
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector vec)
	   (type (unsigned-byte 24) idx n))
  (let ((len (length vec)))
    (declare (type fixnum len))
    (let ((new-vec (make-array (- len n))))
      (dotimes (i idx)
	(setf (svref new-vec i) (svref vec i)))
      (dotimes (i (- len idx n))
	(setf (svref new-vec (+ idx i)) (svref vec (+ idx i n))))
      new-vec)))


;;; --------------------------------
;;; Iteration primitives

;;; This ordering has the slight downside that it can seem unstable; adding or removing an element
;;; can cause a different element to change places (because an entry becomes a subnode or conversely).
;;; But doing it hash-wise is noticeably slower, like a factor of 2 on a straightforward micro-benchmark.
;;; And one of the selling points of CHAMP was supposed to be its better iteration performance.
(defmacro do-ch-set-tree-members ((value-var tree-form &optional value-form)
				  &body body)
  (let ((body-fn (gensymx #:body-))
	(recur-fn (gensymx #:recur-)))
    `(block nil
       (labels ((,body-fn (,value-var)
		  . ,body)
		(,recur-fn (tree)
		  (when tree
		    (if (consp tree)
			(do-wb-set-tree-members (,value-var (cdr tree))
			  (,body-fn ,value-var))
		      (progn
			(dotimes (i (logcount (ch-set-node-entry-mask tree)))
			  (,body-fn (svref tree (+ i ch-set-node-header-size))))
			(dotimes (i (logcount (ch-set-node-subnode-mask tree)))
			  (,recur-fn (svref tree (- (length tree) 1 i)))))))))
	 (declare (inline ,body-fn))
	 (,recur-fn ,tree-form))
       ,value-form)))

;;; ----------------
;;; Stateful iterator

(defun make-ch-set-tree-iterator (tree)
  (let ((iter (make-ch-set-tree-iterator-internal tree)))
    (lambda (op)
      (ecase op
	(:get (ch-set-tree-iterator-get iter))
	(:done? (ch-set-tree-iterator-done? iter))
	(:more? (not (ch-set-tree-iterator-done? iter)))))))

(defun make-ch-set-tree-iterator-internal (tree)
  (declare (optimize (speed 3) (safety 0)))
  ;; Unlike with the WB-trees, the maximum depth here is not a function of the set size.
  (let ((iter (make-array (+ 1 (* 2 (ceiling (integer-length most-positive-fixnum) champ-hash-bits-per-level))))))
    (if (null tree)
	(setf (svref iter 0) -1)
      (progn
	(setf (svref iter 0) 1) ; the stack pointer
	(setf (svref iter 1) tree)
	(setf (svref iter 2) 0)
	(ch-set-tree-iterator-canonicalize iter)))
    iter))

(defun ch-set-tree-iterator-canonicalize (iter)
  (declare (optimize (speed 3) (safety 0)))
  (let ((sp (svref iter 0))
	((node (svref iter sp))
	 (idx (svref iter (1+ sp)))))
    (declare (type (or null fixnum) idx))
    (when (if (null idx)
	      (wb-set-tree-iterator-done? (svref iter sp))
	    (= idx (- (length (the simple-vector node)) ch-set-node-header-size)))
      (decf sp 2)
      (unless (< sp 0)
	(setq node (svref iter sp))
	(setq idx (svref iter (1+ sp)))))
    (unless (< sp 0)
      (loop
	(when (null idx)
	  (return))
	(let ((n-entries (logcount (ch-set-node-entry-mask node))))
	  (when (< idx n-entries)
	    (return))
	  (let ((len (length (the simple-vector node))))
	    (setq node (svref node (- len (- idx n-entries) 1)))
	    (incf idx)
	    (unless (= idx (- len ch-set-node-header-size)) ; TCO
	      (setf (svref iter (1+ sp)) idx)
	      (incf sp 2))
	    (if (consp node)
		(setq node (make-wb-set-tree-iterator-internal (cdr node))
		      idx nil)
	      (setq idx 0))
	    (setf (svref iter sp) node)
	    (setf (svref iter (1+ sp)) idx)))))
    (setf (svref iter 0) sp)))

(defun ch-set-tree-iterator-done? (iter)
  (declare (optimize (speed 3) (safety 0)))
  (< (the fixnum (svref iter 0)) 0))

(defun ch-set-tree-iterator-get (iter)
  (declare (optimize (speed 3) (safety 0)))
  (let ((sp (svref iter 0)))
    (declare (fixnum sp))
    (and (> sp 0)
	 (let ((node (svref iter sp))
	       (idx (svref iter (1+ sp))))
	   (declare (type (or null fixnum) idx))
	   (if (null idx)
	       (let ((val (wb-set-tree-iterator-get node)))
		 (ch-set-tree-iterator-canonicalize iter)
		 (values val t))
	     (progn
	       (setf (svref iter (1+ sp)) (1+ idx))
	       (ch-set-tree-iterator-canonicalize iter)
	       (values (svref node (+ ch-set-node-header-size idx))
		       t)))))))

;;; ----------------
;;; Functional iterator

(defun ch-set-tree-fun-iter (tree)
  (declare (optimize (speed 3) (safety 0)))
  (rlabels (walk tree (lambda (op)
			(ecase op
			  (:first (values nil nil))
			  (:empty? t)
			  (:more? nil))))
    (walk (node cont)
      (if (consp node)
	  (wb-set-tree-fun-iter (cdr node) cont)
	(let ((n-entries (logcount (ch-set-node-entry-mask node)))
	      (n-subnodes (logcount (ch-set-node-subnode-mask node))))
	  (rlabels (entry 0)
	    (entry (i)
	      (declare (fixnum i))
	      (if (< i n-entries)
		  (lambda (op)
		    (ecase op
		      (:first (values (svref node (+ ch-set-node-header-size i)) t))
		      (:rest (entry (1+ i)))
		      (:empty? nil)
		      (:more? t)))
		(subnode 0)))
	    (subnode (i)
	      (declare (fixnum i))
	      (if (< i n-subnodes)
		  (walk (svref node (- (+ ch-set-node-header-size n-entries n-subnodes)
				       i 1))
			(lambda (op) (funcall (the function (subnode (1+ i))) op)))
		cont))))))))

;;; LOL, this is pretty pointless since the ordering is so obscure.  Oh well, it's written...
(defun ch-set-tree-rev-fun-iter (tree)
  (declare (optimize (speed 3) (safety 0)))
  (rlabels (walk tree (lambda (op)
			(ecase op
			  (:first (values nil nil))
			  (:empty? t)
			  (:more? nil))))
    (walk (node cont)
      (if (consp node)
	  (wb-set-tree-rev-fun-iter (cdr node) cont)
	(let ((n-entries (logcount (ch-set-node-entry-mask node)))
	      (n-subnodes (logcount (ch-set-node-subnode-mask node))))
	  (rlabels (subnode (1- n-subnodes))
	    (entry (i)
	      (declare (fixnum i))
	      (if (>= i 0)
		  (lambda (op)
		    (ecase op
		      (:first (values (svref node (+ ch-set-node-header-size i)) t))
		      (:rest (entry (1- i)))
		      (:empty? nil)
		      (:more? t)))
		cont))
	    (subnode (i)
	      (declare (fixnum i))
	      (if (>= i 0)
		  (walk (svref node (- (+ ch-set-node-header-size n-entries n-subnodes)
				       i 1))
			(lambda (op) (funcall (the function (subnode (1- i))) op)))
		(entry (1- n-entries))))))))))


;;; --------------------------------
;;; Union, intersection, set-difference, subset?, disjoint?

(declaim (inline ch-set-node-add-entry!))
(defun ch-set-node-add-entry! (n idx val hash-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type champ-bit-index idx)
	   (type function hash-fn))
  (setf (svref n (+ ch-set-node-header-size (logcount (ch-set-node-entry-mask n)))) val)
  (logiorf (ch-set-node-entry-mask n) (ash 1 idx))
  (incf (ch-set-node-size n))
  (hash-mixf (ch-set-node-hash-value n) (hash-to-fixnum val hash-fn)))

(declaim (inline ch-set-node-add-subnode!))
(defun ch-set-node-add-subnode! (n idx subnode hash-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type champ-bit-index idx)
	   (type function hash-fn))
  (when subnode
    (if (and (not (consp subnode))
	     (= 1 (logcount (ch-set-node-entry-mask subnode)))
	     (= 0 (ch-set-node-subnode-mask subnode)))
	;; `subnode' contains only an entry -- pull it up.
	(ch-set-node-add-entry! n idx (svref subnode ch-set-node-header-size) hash-fn)
      (progn
	(when (and (not (consp subnode))
		   (= 0 (ch-set-node-entry-mask subnode))
		   (= 1 (logcount (ch-set-node-subnode-mask subnode)))
		   (consp (svref subnode (1- (length subnode)))))
	  ;; `subnode' contains only a collision subnode -- pull it up.
	  (setq subnode (svref subnode (1- (length subnode)))))
	(setf (svref n (- (length (the simple-vector n))
			  (logcount (ch-set-node-subnode-mask n)) 1))
	      subnode)
	(logiorf (ch-set-node-subnode-mask n) (ash 1 idx))
	(incf (ch-set-node-size n) (ch-set-tree-size subnode))
	(hash-mixf (ch-set-node-hash-value n) (ch-set-tree-hash-value subnode))))))

(defun ch-set-tree-union (tree1 tree2 hash-fn compare-fn)
  (declare (optimize (speed 1) (safety 0))
	   (type function hash-fn compare-fn))
  (rlabels (rec tree1 tree2 0)
    (rec (tree1 tree2 depth)
      (declare (type (integer 0 64) depth))
      (cond ((null tree1) tree2)
	    ((null tree2) tree1)
	    ((eq tree1 tree2) tree1)
	    ((and (consp tree1) (consp tree2))
	     (let ((hash1 (the fixnum (car tree1)))
		   (hash2 (the fixnum (car tree2))))
	       (if (= hash1 hash2)
		   (let ((result (wb-set-tree-union (cdr tree1) (cdr tree2) compare-fn)))
		     (ch-set-node-from-wb result hash1 depth))
		 (let ((size (+ (wb-set-tree-size (cdr tree1)) (wb-set-tree-size (cdr tree2))))
		       (bits1 (champ-hash-bits hash1 depth))
		       (bits2 (champ-hash-bits hash2 depth))
		       (chash (hash-mix (car tree1) (car tree2))))
		   (declare (fixnum size))
		   (if (= bits1 bits2)
		       (vector 0 (ash 1 bits1) size chash (rec tree1 tree2 (1+ depth)))
		     (let ((subnode0 subnode1 (swap-if (> bits1 bits2) tree1 tree2)))
		       (vector 0 (logior (ash 1 bits1) (ash 1 bits2)) size chash subnode1 subnode0)))))))
	    ((or (consp tree1) (consp tree2))
	     ;; Left preference: we prefer values from `tree1' when they're equal.
	     ;; This took even more code, and was even more of a PITA, than I expected.
	     (let ((tree1-collision? (consp tree1))
		   ((norm-node coll-node (swap-if tree1-collision? tree1 tree2))
		    ((hash-bits (champ-hash-bits (the fixnum (car coll-node)) depth))
		     (entry-mask (ch-set-node-entry-mask norm-node))
		     (subnode-mask (ch-set-node-subnode-mask norm-node)))))
	       (declare (type simple-vector norm-node))
	       (cond ((logbitp hash-bits entry-mask)
		      (let ((ientry (1-bits-below hash-bits entry-mask))
			    (isubnode (1-bits-below hash-bits subnode-mask))
			    ((value (ch-set-node-entry norm-node ientry))
			     ((new-subnode
				(ch-set-tree-with coll-node value hash-fn compare-fn nil (1+ depth)
						  (not tree1-collision?))))))
			(ch-set-node-change-entry-to-subnode norm-node ientry isubnode hash-bits new-subnode hash-fn)))
		     ((logbitp hash-bits subnode-mask)
		      (let ((isubnode (1-bits-below hash-bits subnode-mask))
			    ((old-subnode (ch-set-node-subnode norm-node isubnode))))
			(ch-set-node-replace-subnode norm-node isubnode
						     (if tree1-collision? (rec coll-node old-subnode (1+ depth))
						       (rec old-subnode coll-node (1+ depth))))))
		     (t
		      (ch-set-node-insert-subnode norm-node (1-bits-below hash-bits subnode-mask) hash-bits
						  coll-node)))))
	    (t
	     (let ((entries1 (ch-set-node-entry-mask tree1))
		   (entries2 (ch-set-node-entry-mask tree2))
		   (subnodes1 (ch-set-node-subnode-mask tree1))
		   (subnodes2 (ch-set-node-subnode-mask tree2))
		   ((all-entries (logior entries1 entries2))
		    (all-subnodes (logior subnodes1 subnodes2))
		    ;; Entry collisions can change to subnodes, but they can't then collide with existing subnodes.
		    ;; But we do have to subtract out entry/subnode collisions.
		    ((new-len (- (+ ch-set-node-header-size (logcount all-entries) (logcount all-subnodes))
				 (logcount (logand entries1 subnodes2)) (logcount (logand entries2 subnodes1))))
		     ((res-n (make-array new-len :initial-element 0)))))
		   (ientry1 0)
		   (isubnode1 0)
		   (ientry2 0)
		   (isubnode2 0))
	       (declare (fixnum ientry1 isubnode1 ientry2 isubnode2))
	       (flet ((add-entry (idx val)
			(ch-set-node-add-entry! res-n idx val hash-fn))
		      (add-subnode (idx subnode)
			(ch-set-node-add-subnode! res-n idx subnode hash-fn))
		      (subtree-with (tree value &optional replace?)
			(ch-set-tree-with tree value hash-fn compare-fn nil (1+ depth) replace?)))
		 (do-bit-indices (idx (logior all-entries all-subnodes))
		   (cond ((and (logbitp idx entries1) (logbitp idx entries2))
			  (let ((val1 (ch-set-node-entry tree1 (postincf ientry1)))
				(val2 (ch-set-node-entry tree2 (postincf ientry2))))
			    (if (equal?-cmp val1 val2 compare-fn)
				(add-entry idx val1)
			      (add-subnode idx (subtree-with (subtree-with nil val1) val2)))))
			 ((logbitp idx entries1)
			  (let ((val (ch-set-node-entry tree1 (postincf ientry1))))
			    (if (logbitp idx subnodes2)
				(let ((subnode (ch-set-node-subnode tree2 (postincf isubnode2))))
				  ;; Must replace for left preference.
				  (add-subnode idx (subtree-with subnode val t)))
			      (add-entry idx val))))
			 ((logbitp idx entries2)
			  (let ((val (ch-set-node-entry tree2 (postincf ientry2))))
			    (if (logbitp idx subnodes1)
				(let ((subnode (ch-set-node-subnode tree1 (postincf isubnode1))))
				  (add-subnode idx (subtree-with subnode val)))
			      (add-entry idx val))))
			 ((and (logbitp idx subnodes1) (logbitp idx subnodes2))
			  (add-subnode idx (rec (ch-set-node-subnode tree1 (postincf isubnode1))
						(ch-set-node-subnode tree2 (postincf isubnode2))
						(1+ depth))))
			 ((logbitp idx subnodes1)
			  (add-subnode idx (ch-set-node-subnode tree1 (postincf isubnode1))))
			 ((logbitp idx subnodes2)
			  (add-subnode idx (ch-set-node-subnode tree2 (postincf isubnode2))))
			 (t (error "Bug in 'ch-set-tree-union'")))))
	       res-n))))))

(defun ch-set-tree-intersection (tree1 tree2 hash-fn compare-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn))
  (rlabels (rec tree1 tree2 0)
    (rec (tree1 tree2 depth)
      (declare (type (integer 0 64) depth))
      (cond ((or (null tree1) (null tree2)) nil)
	    ((eq tree1 tree2) tree1)
	    ((consp tree1)
	     (if (consp tree2)
		 (and (= (the fixnum (car tree1)) (the fixnum (car tree2)))
		      (let ((result (wb-set-tree-intersect (cdr tree1) (cdr tree2) compare-fn)))
			(ch-set-node-from-wb result (car tree1) depth)))
	       (let ((result nil))
		 (do-wb-set-tree-members (x (cdr tree1))
		   (when (ch-set-tree-contains? tree2 x hash-fn compare-fn depth)
		     (setq result (ch-set-tree-with result x hash-fn compare-fn nil depth))))
		 result)))
	    ((consp tree2)
	     (let ((hash-bits (champ-hash-bits (the fixnum (car tree2)) depth))
		   (entry-mask (ch-set-node-entry-mask tree1))
		   (subnode-mask (ch-set-node-subnode-mask tree1)))
	       (cond ((logbitp hash-bits entry-mask)
		      (let ((ientry (1-bits-below hash-bits entry-mask))
			    ((value (ch-set-node-entry tree1 ientry))))
			(and (wb-set-tree-contains? (cdr tree2) value compare-fn)
			     (ch-set-tree-with nil value hash-fn compare-fn nil depth))))
		     ((logbitp hash-bits subnode-mask)
		      (let ((isubnode (1-bits-below hash-bits subnode-mask))
			    ((old-subnode (ch-set-node-subnode tree1 isubnode)))
			    (result nil))
			(do-wb-set-tree-members (x (cdr tree2))
			  (let ((v1? v1 (ch-set-tree-contains? old-subnode x hash-fn compare-fn (1+ depth))))
			    (when v1?
			      (setq result (ch-set-tree-with result v1 hash-fn compare-fn nil depth)))))
			result))
		     (t nil))))
	    (t
	     (let ((entries1 (ch-set-node-entry-mask tree1))
		   (entries2 (ch-set-node-entry-mask tree2))
		   (subnodes1 (ch-set-node-subnode-mask tree1))
		   (subnodes2 (ch-set-node-subnode-mask tree2))
		   ;; Unlike in the union case, where we can compute the size in advance, for the intersection
		   ;; we can only compute an upper bound -- the result could even be empty.
		   ((res-len (min (length tree1) (length tree2)))
		    ((res-n (make-array res-len :initial-element 0)))))
	       (flet ((add-entry (idx val)
			(ch-set-node-add-entry! res-n idx val hash-fn))
		      (add-subnode (idx subnode)
			(ch-set-node-add-subnode! res-n idx subnode hash-fn))
		      (subtree-contains? (tree val)
			(ch-set-tree-contains? tree val hash-fn compare-fn (1+ depth))))
		 (do-bit-indices (idx (logior (logand entries1 entries2) (logand subnodes1 subnodes2)
					      (logand entries1 subnodes2) (logand subnodes1 entries2)))
		   ;; Here and in the other algorithms that don't look at every bit in the OR of
		   ;; the masks, we have to use `1-bits-below' instead of counters to get the indices.
		   (cond ((and (logbitp idx entries1) (logbitp idx entries2))
			  (let ((val1 (ch-set-node-entry tree1 (1-bits-below idx entries1)))
				(val2 (ch-set-node-entry tree2 (1-bits-below idx entries2))))
			    (when (equal?-cmp val1 val2 compare-fn)
			      (add-entry idx val1))))
			 ((and (logbitp idx entries1) (logbitp idx subnodes2))
			  (let ((val1 (ch-set-node-entry tree1 (1-bits-below idx entries1))))
			    (when (subtree-contains? (ch-set-node-subnode tree2 (1-bits-below idx subnodes2)) val1)
			      (add-entry idx val1))))
			 ((and (logbitp idx subnodes1) (logbitp idx entries2))
			  (let ((val2 (ch-set-node-entry tree2 (1-bits-below idx entries2)))
				((val1? val1 (subtree-contains? (ch-set-node-subnode tree1 (1-bits-below idx subnodes1))
								val2))))
			    (when val1?
			      (add-entry idx val1))))
			 ((and (logbitp idx subnodes1) (logbitp idx subnodes2))
			  (add-subnode idx (rec (ch-set-node-subnode tree1 (1-bits-below idx subnodes1))
						(ch-set-node-subnode tree2 (1-bits-below idx subnodes2))
						(1+ depth)))))))
	       (ch-set-compact-node res-n)))))))

(defun ch-set-tree-diff (tree1 tree2 hash-fn compare-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn))
  (rlabels (rec tree1 tree2 0)
    (rec (tree1 tree2 depth)
      (declare (type (integer 0 64) depth))
      (cond ((null tree1) nil)
	    ((null tree2) tree1)
	    ((eq tree1 tree2) nil)
	    ((consp tree1)
	     (if (consp tree2)
		 (if (= (the fixnum (car tree1)) (the fixnum (car tree2)))
		     (let ((result (wb-set-tree-diff (cdr tree1) (cdr tree2) compare-fn)))
		       (ch-set-node-from-wb result (car tree1) depth))
		   tree1)
	       (let ((result nil))
		 ;; Assuming the collision subtree is likely to be much smaller than the regular one.
		 (do-wb-set-tree-members (v (cdr tree1))
		   (unless (ch-set-tree-contains? tree2 v hash-fn compare-fn depth)
		     (setq result (wb-set-tree-with result v compare-fn))))
		 (ch-set-node-from-wb result (car tree1) depth))))
	    ((consp tree2)
	     (do-wb-set-tree-members (v (cdr tree2))
	       (setq tree1 (ch-set-tree-less tree1 v hash-fn compare-fn nil depth)))
	     tree1)
	    (t
	     (let ((entries1 (ch-set-node-entry-mask tree1))
		   (entries2 (ch-set-node-entry-mask tree2))
		   (subnodes1 (ch-set-node-subnode-mask tree1))
		   (subnodes2 (ch-set-node-subnode-mask tree2))
		   ((res-len (length (the simple-vector tree1))) ; upper bound
		    ((res-n (make-array res-len :initial-element 0)))))
	       (flet ((add-entry (idx val)
			(ch-set-node-add-entry! res-n idx val hash-fn))
		      (add-subnode (idx subnode)
			(ch-set-node-add-subnode! res-n idx subnode hash-fn))
		      (subtree-less (subtree val)
			(ch-set-tree-less subtree val hash-fn compare-fn nil (1+ depth)))
		      (subtree-contains? (subtree val)
			(ch-set-tree-contains? subtree val hash-fn compare-fn (1+ depth))))
		 (do-bit-indices (idx (logior entries1 subnodes1))
		   (cond ((logbitp idx entries1)
			  (let ((val1 (ch-set-node-entry tree1 (1-bits-below idx entries1))))
			    (cond ((logbitp idx entries2)
				   (let ((val2 (ch-set-node-entry tree2 (1-bits-below idx entries2))))
				     (unless (equal?-cmp val1 val2 compare-fn)
				       (add-entry idx val1))))
				  ((logbitp idx subnodes2)
				   (let ((subnode (ch-set-node-subnode tree2 (1-bits-below idx subnodes2))))
				     (unless (subtree-contains? subnode val1)
				       (add-entry idx val1))))
				  (t (add-entry idx val1)))))
			 ((logbitp idx subnodes1)
			  (let ((subnode1 (ch-set-node-subnode tree1 (1-bits-below idx subnodes1))))
			    (cond ((logbitp idx entries2)
				   (let ((val2 (ch-set-node-entry tree2 (1-bits-below idx entries2))))
				     (add-subnode idx (subtree-less subnode1 val2))))
				  ((logbitp idx subnodes2)
				   (let ((subnode2 (ch-set-node-subnode tree2 (1-bits-below idx subnodes2))))
				     (add-subnode idx (rec subnode1 subnode2 (1+ depth)))))
				  (t (add-subnode idx subnode1))))))))
	       (ch-set-compact-node res-n)))))))

(defun ch-set-tree-diff-2 (tree1 tree2 hash-fn compare-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn))
  (rlabels (rec tree1 tree2 0)
    (rec (tree1 tree2 depth)
      (declare (type (integer 0 64) depth))
      (cond ((null tree1) (values nil tree2))
	    ((null tree2) (values tree1 nil))
	    ((eq tree1 tree2) (values nil nil))
	    ((consp tree1)
	     (if (consp tree2)
		 (if (= (the fixnum (car tree1)) (the fixnum (car tree2)))
		     (let ((result1 result2 (wb-set-tree-diff-2 (cdr tree1) (cdr tree2) compare-fn)))
		       (values (ch-set-node-from-wb result1 (car tree1) depth)
			       (ch-set-node-from-wb result2 (car tree2) depth)))
		   (values tree1 tree2))
	       (let ((result1 (cdr tree1)))
		 (do-ch-set-tree-members (v tree2)
		   (setq result1 (wb-set-tree-less result1 v compare-fn)))
		 (do-wb-set-tree-members (v (cdr tree1))
		   (setq tree2 (ch-set-tree-less tree2 v hash-fn compare-fn nil depth)))
		 (values (ch-set-node-from-wb result1 (car tree1) depth)
			 tree2))))
	    ((consp tree2)
	     (let ((res2 res1 (rec tree2 tree1 depth)))
	       (values res1 res2)))
	    (t
	     (let ((entries1 (ch-set-node-entry-mask tree1))
		   (entries2 (ch-set-node-entry-mask tree2))
		   (subnodes1 (ch-set-node-subnode-mask tree1))
		   (subnodes2 (ch-set-node-subnode-mask tree2))
		   ((res-len1 (length (the simple-vector tree1))) ; upper bound
		    ((res-n1 (make-array res-len1 :initial-element 0))))
		   ((res-len2 (length (the simple-vector tree2)))
		    ((res-n2 (make-array res-len2 :initial-element 0))))
		   (ientry1 0)
		   (isubnode1 0)
		   (ientry2 0)
		   (isubnode2 0))
	       (declare (fixnum ientry1 isubnode1 ientry2 isubnode2))
	       (flet ((add-entry (n idx val)
			(ch-set-node-add-entry! n idx val hash-fn))
		      (add-subnode (n idx subnode)
			(ch-set-node-add-subnode! n idx subnode hash-fn))
		      (subtree-less (subtree val)
			(ch-set-tree-less subtree val hash-fn compare-fn nil (1+ depth)))
		      (subtree-contains? (subtree val)
			(ch-set-tree-contains? subtree val hash-fn compare-fn (1+ depth))))
		 (do-bit-indices (idx (logior entries1 subnodes1 entries2 subnodes2))
		   (cond ((logbitp idx entries1)
			  (let ((val1 (ch-set-node-entry tree1 (postincf ientry1))))
			    (cond ((logbitp idx entries2)
				   (let ((val2 (ch-set-node-entry tree2 (postincf ientry2))))
				     (unless (equal?-cmp val1 val2 compare-fn)
				       (add-entry res-n1 idx val1)
				       (add-entry res-n2 idx val2))))
				  ((logbitp idx subnodes2)
				   (let ((subnode2 (ch-set-node-subnode tree2 (postincf isubnode2))))
				     (unless (subtree-contains? subnode2 val1)
				       (add-entry res-n1 idx val1))
				     (add-subnode res-n2 idx (subtree-less subnode2 val1))))
				  (t (add-entry res-n1 idx val1)))))
			 ((logbitp idx subnodes1)
			  (let ((subnode1 (ch-set-node-subnode tree1 (postincf isubnode1))))
			    (cond ((logbitp idx subnodes2)
				   (let ((subnode2 (ch-set-node-subnode tree2 (postincf isubnode2)))
					 ((new-sn1 new-sn2 (rec subnode1 subnode2 (1+ depth)))))
				     (add-subnode res-n1 idx new-sn1)
				     (add-subnode res-n2 idx new-sn2)))
				  ((logbitp idx entries2)
				   (let ((val2 (ch-set-node-entry tree2 (postincf ientry2))))
				     (add-subnode res-n1 idx (subtree-less subnode1 val2))
				     (unless (subtree-contains? subnode1 val2)
				       (add-entry res-n2 idx val2))))
				  (t (add-subnode res-n1 idx subnode1)))))
			 ((logbitp idx entries2)
			  (add-entry res-n2 idx (ch-set-node-entry tree2 (postincf ientry2))))
			 ((logbitp idx subnodes2)
			  (add-subnode res-n2 idx (ch-set-node-subnode tree2 (postincf isubnode2))))
			 (t (error "Bug in ch-set-tree-diff-2")))))
	       (values (ch-set-compact-node res-n1) (ch-set-compact-node res-n2))))))))

(defun ch-set-node-from-wb (wb-set-tree hash depth)
  (declare (optimize (speed 3) (safety 0))
	   (fixnum hash)
	   (type (integer 0 64) depth))
  (case (wb-set-tree-size wb-set-tree)
    (0 nil)
    (1 (vector (ash 1 (champ-hash-bits hash depth)) 0 1 hash (wb-set-tree-arb wb-set-tree)))
    (t (cons hash wb-set-tree))))

(defun ch-set-node-replace-subnode (node isubnode new-subnode)
  "Returns a new node with `new-subnode' replacing the subnode at `isubnode'."
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector node)
	   (type champ-subnode-index isubnode))
  (let ((old-subnode (ch-set-node-subnode node isubnode))
	(n (vector-update node (- (length node) isubnode 1) new-subnode)))
    (declare (type simple-vector n))
    (setf (svref n (- (length n) isubnode 1)) new-subnode)
    (incf (ch-set-node-size n) (- (ch-set-tree-size new-subnode) (ch-set-tree-size old-subnode)))
    (hash-mixf (ch-set-node-hash-value n)
	       (hash-unmix (ch-set-tree-hash-value new-subnode)
			   (ch-set-tree-hash-value old-subnode)))
    n))

(defun ch-set-node-insert-subnode (node isubnode hash-bits new-subnode)
  "Returns a new node with `new-subnode' inserted just before `isubnode'."
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector node)
	   (type champ-bit-index hash-bits)
	   (type champ-subnode-index isubnode))
  (let ((n (vector-insert node (- (length node) isubnode) new-subnode)))
    (logiorf (ch-set-node-subnode-mask n) (ash 1 hash-bits))
    (incf (ch-set-node-size n) (ch-set-tree-size new-subnode))
    (hash-mixf (ch-set-node-hash-value n) (ch-set-tree-hash-value new-subnode))
    n))

(defun ch-set-node-change-entry-to-subnode (node ientry isubnode hash-bits new-subnode hash-fn)
  "Returns a new node with entry `ientry' removed, and `new-subnode' inserted just
before `isubnode'."
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector node)
	   (type champ-bit-index hash-bits)
	   (type champ-entry-index ientry)
	   (type champ-subnode-index isubnode)
	   (type function hash-fn))
  (let ((value (ch-set-node-entry node ientry))
	(n (ch-set-node-rem-1-ins-1 nil node (+ ch-set-node-header-size ientry)
				    (- (length node) isubnode 1) new-subnode)))
    (logandc2f (ch-set-node-entry-mask n) (ash 1 hash-bits))
    (logiorf (ch-set-node-subnode-mask n) (ash 1 hash-bits))
    (incf (ch-set-node-size n) (1- (ch-set-tree-size new-subnode)))
    (hash-mixf (ch-set-node-hash-value n)
	       (hash-unmix (ch-set-tree-hash-value new-subnode)
			   (hash-to-fixnum value hash-fn)))
    n))

(defun ch-set-compact-node (n)
  (declare (optimize (speed 3) (safety 0)))
  (let ((entries (ch-set-node-entry-mask n))
	(subnodes (ch-set-node-subnode-mask n)))
    (and (or (/= entries 0) (/= subnodes 0))
	 (let ((len (length (the simple-vector n)))
	       (n-entries (logcount entries))
	       ((extra (- len ch-set-node-header-size n-entries (logcount subnodes)))))
	   (when (< extra 0)
	     (error "Bug!  Not enough space allocated for ch-set-node"))
	   (if (= extra 0) n
	     (vector-remove-n-at n (+ ch-set-node-header-size n-entries) extra))))))

(defun ch-set-compact-tree (tree)
  (declare (optimize (speed 3) (safety 0)))
  (cond ((null tree) nil)
	((consp tree) tree)
	(t
	 (let ((n-entries (logcount (ch-set-node-entry-mask tree)))
	       (n-subnodes (logcount (ch-set-node-subnode-mask tree)))
	       (len (length (the simple-vector tree)))
	       ((min-len (+ ch-set-node-header-size n-entries n-subnodes)))
	       (copied? nil))
	   (flet ((copy ()
		    (unless copied?
		      (let ((new (make-array min-len)))
			(dotimes (i (+ ch-set-node-header-size n-entries))
			  (setf (svref new i) (svref tree i)))
			(dotimes (i n-subnodes)
			  (setf (svref new (- min-len i 1)) (svref tree (- len i 1))))
			(setq tree new)
			(setq len min-len)
			(setq copied? t)))))
	     (when (< len min-len)
	       (error "Bug!  Not enough space allocated for ch-set-node"))
	     (when (> len min-len)
	       (copy))
	     (dotimes (i n-subnodes)
	       (let ((subnode (svref tree (- len i 1)))
		     ((new-subnode (ch-set-compact-tree subnode))))
		 (unless (eq new-subnode subnode)
		   (copy)
		   (setf (svref tree (- len i 1)) new-subnode))))
	     tree)))))

(defun ch-set-tree-subset? (tree1 tree2 hash-fn compare-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn))
  (rlabels (rec tree1 tree2 0)
    (rec (tree1 tree2 depth)
      (declare (type (integer 0 64) depth))
      (cond ((null tree1) t)
	    ((null tree2) nil)
	    ((eq tree1 tree2) t)
	    ((consp tree1)
	     (if (consp tree2)
		 (wb-set-tree-subset? (cdr tree1) (cdr tree2) compare-fn)
	       (do-wb-set-tree-members (x (cdr tree1) t)
		 (unless (ch-set-tree-contains? tree2 x hash-fn compare-fn depth)
		   (return nil)))))
	    ((consp tree2)
	     (do-ch-set-tree-members (x tree1 t)
	       (unless (wb-set-tree-contains? (cdr tree2) x compare-fn)
		 (return nil))))
	    (t
	     (let ((entries1 (ch-set-node-entry-mask tree1))
		   (entries2 (ch-set-node-entry-mask tree2))
		   (subnodes1 (ch-set-node-subnode-mask tree1))
		   (subnodes2 (ch-set-node-subnode-mask tree2)))
	       (do-bit-indices (idx (logior entries1 subnodes1)
				    t)
		 (cond ((logbitp idx entries1)
			(cond ((logbitp idx entries2)
			       (let ((val1 (ch-set-node-entry tree1 (1-bits-below idx entries1)))
				     (val2 (ch-set-node-entry tree2 (1-bits-below idx entries2))))
				 (unless (equal?-cmp val1 val2 compare-fn)
				   (return nil))))
			      ((logbitp idx subnodes2)
			       (let ((val (ch-set-node-entry tree1 (1-bits-below idx entries1))))
				 (unless (ch-set-tree-contains? (ch-set-node-subnode tree2 (1-bits-below idx subnodes2))
								val hash-fn compare-fn (1+ depth))
				   (return nil))))
			      (t (return nil))))
		       ((logbitp idx subnodes1)
			(cond ((logbitp idx subnodes2)
			       (unless (rec (ch-set-node-subnode tree1 (1-bits-below idx subnodes1))
					    (ch-set-node-subnode tree2 (1-bits-below idx subnodes2))
					    (1+ depth))
				 (return nil)))
			      (t (return nil))))))))))))

(defun ch-set-tree-disjoint? (tree1 tree2 hash-fn compare-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function hash-fn compare-fn))
  (rlabels (rec tree1 tree2 0)
    (rec (tree1 tree2 depth)
      (declare (type (integer 0 64) depth))
      (cond ((or (null tree1) (null tree2)) t)
	    ((eq tree1 tree2) nil)
	    ((consp tree1)
	     (if (consp tree2)
		 (wb-set-tree-disjoint? (cdr tree1) (cdr tree2) compare-fn)
	       (do-wb-set-tree-members (x (cdr tree1) t)
		 (when (ch-set-tree-contains? tree2 x hash-fn compare-fn depth)
		   (return nil)))))
	    ((consp tree2)
	     (rec tree2 tree1 depth))
	    (t
	     (let ((entries1 (ch-set-node-entry-mask tree1))
		   (entries2 (ch-set-node-entry-mask tree2))
		   (subnodes1 (ch-set-node-subnode-mask tree1))
		   (subnodes2 (ch-set-node-subnode-mask tree2)))
	       (do-bit-indices (idx (logand (logior entries1 subnodes1) (logior entries2 subnodes2))
				    t)
		 (cond ((and (logbitp idx entries1) (logbitp idx entries2))
			(let ((val1 (ch-set-node-entry tree1 (1-bits-below idx entries1)))
			      (val2 (ch-set-node-entry tree2 (1-bits-below idx entries2))))
			  (when (equal?-cmp val1 val2 compare-fn)
			    (return nil))))
		       ((and (logbitp idx entries1) (logbitp idx subnodes2))
			(let ((val (ch-set-node-entry tree1 (1-bits-below idx entries1))))
			  (when (ch-set-tree-contains? (ch-set-node-subnode tree2 (1-bits-below idx subnodes2))
						       val hash-fn compare-fn (1+ depth))
			    (return nil))))
		       ((and (logbitp idx subnodes1) (logbitp idx entries2))
			(let ((val (ch-set-node-entry tree2 (1-bits-below idx entries2))))
			  (when (ch-set-tree-contains? (ch-set-node-subnode tree1 (1-bits-below idx subnodes1))
						       val hash-fn compare-fn (1+ depth))
			    (return nil))))
		       ((and (logbitp idx subnodes1) (logbitp idx subnodes2))
			(unless (rec (ch-set-node-subnode tree1 (1-bits-below idx subnodes1))
				     (ch-set-node-subnode tree2 (1-bits-below idx subnodes2))
				     (1+ depth))
			  (return nil)))))))))))


;;; --------------------------------
;;; Verifier

(defun ch-set-tree-verify (tree hash-fn &optional (depth 0) (partial-hash 0))
  (declare (optimize (debug 3)))
  (or (null tree)
      (rlabels (rec tree depth partial-hash)
	(rec (node depth partial-hash)
	  (macrolet ((test (form)
		       `(or ,form
			    (progn
			      (cerror "Ignore and proceed."
				      "Test failed at ~:A: ~S" (path depth partial-hash) ',form)
			      nil))))
	    (let ((entry-mask (ch-set-node-entry-mask node))
		  (subnode-mask (ch-set-node-subnode-mask node))
		  ((entry-bits (bit-indices entry-mask))
		   (subnode-bits (bit-indices subnode-mask))))
	      (and (test (= 0 (logand entry-mask subnode-mask)))
		   (test (= 0 (ash entry-mask (- champ-node-radix))))
		   (test (= 0 (ash subnode-mask (- champ-node-radix))))
		   (test (>= (length node) (+ ch-set-node-header-size (logcount entry-mask) (logcount subnode-mask))))
		   ;; Check that unless root, this node does not contain only an entry ...
		   (test (not (and (> depth 0) (= 1 (logcount entry-mask)) (= 0 subnode-mask))))
		   ;; ... or only a collision subnode
		   (test (not (and (> depth 0) (= 0 entry-mask) (= 1 (logcount subnode-mask))
				   (consp (svref node (1- (length node)))))))
		   (let ((size (logcount entry-mask))
			 (node-hash 0))
		     (and
		       ;; Check entry value hashes
		       (gmap :and (fn (value-idx hash-bits)
				    (let ((value (svref node (+ ch-set-node-header-size value-idx)))
					  ((value-hash (hash-to-fixnum value hash-fn))))
				      (hash-mixf node-hash value-hash)
				      (test (= (ldb (byte (* champ-hash-bits-per-level (1+ depth)) 0)
						    value-hash)
					       (new-partial-hash hash-bits depth partial-hash)))))
			     (:arg index 0)
			     (:arg list entry-bits))
		       ;; Verify subnodes
		       (gmap :and (fn (subnode-idx hash-bits)
				    (let ((subnode (svref node (- (length node) 1 subnode-idx))))
				      (if (consp subnode)
					  (let ((elt-hash (hash-to-fixnum (wb-set-tree-arb (cdr subnode)) hash-fn)))
					    (test (> (wb-set-tree-size (cdr subnode)) 1))
					    (do-wb-set-tree-members (v (cdr subnode))
					      (test (= (hash-to-fixnum v hash-fn) elt-hash)))
					    (hash-mixf node-hash elt-hash)
					    (incf size (wb-set-tree-size (cdr subnode)))
					    (test (= (car subnode) elt-hash)))
					(and (rec subnode (1+ depth) (new-partial-hash hash-bits depth partial-hash))
					     (progn
					       (incf size (ch-set-node-size subnode))
					       (hash-mixf node-hash (ch-set-node-hash-value subnode))
					       t)))))
			     (:arg index 0)
			     (:arg list subnode-bits))
		       ;; Finally, check size and hash
		       (test (= (ch-set-node-size node) size))
		       (test (= (ch-set-node-hash-value node) node-hash))))))))
	(new-partial-hash (hash-bits depth partial-hash)
	  (dpb hash-bits (byte champ-hash-bits-per-level (* champ-hash-bits-per-level depth))
	       partial-hash))
	(path (depth partial-hash)
	  (let ((path nil))
	    (dotimes (i depth)
	      (push (ldb (byte champ-hash-bits-per-level (* i champ-hash-bits-per-level))
			 partial-hash)
		    path))
	    (nreverse path))))))


;;; ================================================================================
;;; Maps

(defstruct (ch-map-node
	     (:constructor nil)
	     (:type vector))
  (entry-mask 0 :type fixnum)
  (subnode-mask 0 :type fixnum)
  (size 0 :type fixnum) ; total number of pairs at or below this node
  (key-hash 0 :type fixnum)
  ;; This slot is used in two different ways.  For maps, it is a lazily populated cache of
  ;; the hashes of the values.  For bags, it is the total count (multiplicity).
  (value-hash nil :type (or null integer)))
(defmacro ch-map-node-bag-count (x)
  `(ch-map-node-value-hash ,x))
(defconstant ch-map-node-header-size 5)
;;; Near (0, 0), we want this to be 8, to allow 4 entries.
;;; As the sum approaches 32 we want it to go to 0.
;;; As `n-entries' approaches 16, we also want it to be small (2?), because that's where
;;; entry->subnode conversions become likely.
;;; &&& Just a first cut; will tune later.
(declaim (inline ch-map-node-transient-space))
(defun ch-map-node-transient-space (n-entries n-subnodes)
  "The number of extra slots to allocate in a transient map node."
  (declare (optimize (speed 3))
	   (type champ-entry-index n-entries)
	   (type champ-subnode-index n-subnodes))
  (+ (ceiling (max 0 (- 16 n-entries)) 4)
     (ceiling (- 32 n-subnodes) 8)
     1))				; for the transient-id

;;; A collision node has the form ((key-hash . value-hash) . wb-tree), where `key-hash' is the hash
;;; value of any key -- they're all equal -- and `value-hash', if nonnull, is the mixed hash of all
;;; the values.
(deftype ch-map-tree ()
  '(or null cons simple-vector))

(declaim (inline make-ch-map-node))
(defun make-ch-map-node (transient-id entry-mask subnode-mask size key-hash value-hash &rest contents)
  (declare (optimize (speed 3) (safety 0))
	   (dynamic-extent contents))
  (if transient-id
      (make-transient-ch-map-node transient-id entry-mask subnode-mask size key-hash value-hash contents)
    (apply #'vector entry-mask subnode-mask size key-hash value-hash contents)))

(defun make-transient-ch-map-node (transient-id entry-mask subnode-mask size key-hash value-hash contents)
  (declare (optimize (speed 3) (safety 0))
	   (fixnum entry-mask subnode-mask))
  (let ((n-entries (logcount entry-mask))
	(n-subnodes (logcount subnode-mask))
	((transient-space (ch-map-node-transient-space n-entries n-subnodes))
	 ((n (make-array (+ ch-map-node-header-size (* 2 n-entries) n-subnodes transient-space)))))
	(idx 0))
    (setf (ch-map-node-entry-mask n) entry-mask)
    (setf (ch-map-node-subnode-mask n) subnode-mask)
    (setf (ch-map-node-size n) size)
    (setf (ch-map-node-key-hash n) key-hash)
    (setf (ch-map-node-value-hash n) value-hash)
    (dolist (x contents)
      (when (= idx (* 2 n-entries))
	(incf idx transient-space))
      (setf (svref n (+ idx ch-map-node-header-size)) x)
      (incf idx))
    (setf (svref n (+ ch-map-node-header-size (* 2 n-entries))) transient-id)
    n))

(declaim (ftype (function (ch-map-tree) fixnum) ch-map-tree-size))
(declaim (inline ch-map-tree-size))
(defun ch-map-tree-size (tree)
  (declare (optimize (speed 3) (safety 0)))
  (cond ((null tree) 0)
	((consp tree)
	 (wb-map-tree-size (cdr tree)))
	(t (ch-map-node-size tree))))

(declaim (inline ch-map-node-entry))
(defun ch-map-node-entry (node ientry)
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector node)
	   (type champ-entry-index ientry))
  (let ((entry-idx (+ ch-map-node-header-size (* 2 ientry))))
    (values (svref node entry-idx) (svref node (1+ entry-idx)))))

(declaim (inline ch-map-node-subnode))
(defun ch-map-node-subnode (node isubnode)
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector node)
	   (type champ-subnode-index isubnode))
  (svref node (- (length node) isubnode 1)))

(defun ch-map-tree-with (tree key value key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn
			 &optional transient-id (depth 0) replace?)
  "Second value is true iff the tree changed; the result can be eq to `tree', even
if it changed, if `transient-id' is supplied."
  (declare (optimize (speed 3) (safety 0))
	   (type function key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn)
	   (type (integer 0 64) depth))
  (let ((key-hash (hash-to-fixnum key key-hash-fn)))
    (declare (fixnum key-hash))
    (rlabels (rec tree (ash key-hash (- (* champ-hash-bits-per-level depth))) depth)
      (rec (node hash-shifted depth)
	(declare (fixnum hash-shifted)
		 (type (integer 0 64) depth))
	(let ((hash-bits (logand hash-shifted champ-hash-level-mask)))
	  (if (null node)
	      (values (make-ch-map-node transient-id (ash 1 hash-bits) 0 1 key-hash nil key value) t)
	    (if (consp node)
		;; Collision node.
		(let ((wb-hash-shifted (ash (the fixnum (caar node)) (* (- champ-hash-bits-per-level) depth)))
		      (size (1+ (wb-map-tree-size (cdr node)))))
		  (declare (fixnum wb-hash-shifted size))
		  (if (= hash-shifted wb-hash-shifted)
		      ;; Update the collision node.
		      (let ((new-wb-tree (wb-map-tree-with (if replace? (wb-map-tree-less (cdr node) key key-cmp-fn)
							     (cdr node))
							   key value key-cmp-fn val-cmp-fn)))
			(if (eq new-wb-tree (cdr node))
			    (values node nil)
			  (let ((value-hash (and (cdar node)
						 (hash-mix (cdar node) (hash-to-fixnum value val-hash-fn)))))
			    (if (= (wb-map-tree-size new-wb-tree) (wb-map-tree-size (cdr node)))
				;; The key was already present, but the value was updated.
				(let ((ig old-value (wb-map-tree-lookup (cdr node) key key-cmp-fn))
				      ((new-val-hash
					 (and value-hash
					      (hash-unmix value-hash (hash-to-fixnum old-value val-hash-fn))))))
				  (declare (ignore ig))
				  (values (cons (cons (caar node) new-val-hash) new-wb-tree) t))
			      ;; New entry in collision node
			      (values (cons (cons (caar node) value-hash) new-wb-tree) t)))))
		    (let ((hash-bits (logand hash-shifted champ-hash-level-mask))
			  (wb-hash-bits (logand wb-hash-shifted champ-hash-level-mask))
			  (key-hash (hash-mix (caar node) key-hash))
			  (value-hash (and (cdar node) (hash-mix (cdar node) (hash-to-fixnum value val-hash-fn)))))
		      (values (if (= hash-bits wb-hash-bits)
				  (make-ch-map-node transient-id 0 (ash 1 hash-bits) size key-hash value-hash
						    (rec node (ash hash-shifted (- champ-hash-bits-per-level))
							 (1+ depth)))
				(make-ch-map-node transient-id (ash 1 hash-bits) (ash 1 wb-hash-bits)
						  size key-hash value-hash key value node))
			      t))))
	      ;; Normal case.
	      (let ((entry-mask (ch-map-node-entry-mask node))
		    ((entry-idx (+ ch-map-node-header-size (* 2 (1-bits-below hash-bits entry-mask)))))
		    (subnode-mask (ch-map-node-subnode-mask node))
		    ((subnode-idx (- (length node) 1 (1-bits-below hash-bits subnode-mask)))))
		(if (logbitp hash-bits entry-mask)
		    ;; Entry found
		    (let ((ex-key (svref node entry-idx))
			  (ex-val (svref node (1+ entry-idx))))
		      (if (equal?-cmp key ex-key key-cmp-fn)
			  (if (equal?-cmp value ex-val val-cmp-fn)
			      ;; Key found, value equal: nothing to do (unless `replace?' requested)
			      (if (and replace? (not (and (gen eql key ex-key) (gen eql value ex-val))))
				  (values (ch-map-node-update-2 transient-id node entry-idx key value) t)
				(values node nil))
			    ;; Key found, value differs: just update value
			    (let ((n (ch-map-node-update-2 transient-id node entry-idx key value)))
			      (when (ch-map-node-value-hash n)
				(hash-mixf (ch-map-node-value-hash n) (hash-unmix (hash-to-fixnum value val-hash-fn)
										  (hash-to-fixnum ex-val val-hash-fn))))
			      (values n t)))
			;; Entry with different key found: make a subnode
			(let ((hash-shifted (ash hash-shifted (- champ-hash-bits-per-level)))
			      (ex-key-hash (hash-to-fixnum ex-key key-hash-fn))
			      ((ex-key-hash-shifted (ash ex-key-hash (* (- champ-hash-bits-per-level) (1+ depth))))
			       ((n2 (if (= hash-shifted ex-key-hash-shifted)
					;; Collision!  Fall back to WB-tree.
					(cons (cons key-hash nil)
					      (wb-map-tree-with (wb-map-tree-with nil ex-key ex-val
										  key-cmp-fn val-cmp-fn)
								key value key-cmp-fn val-cmp-fn))
				      ;; Turn the entry into a subnode and recur.
				      (rec (make-ch-map-node transient-id
							     (ash 1 (logand ex-key-hash-shifted champ-hash-level-mask))
							     0 1 ex-key-hash nil ex-key ex-val)
					   hash-shifted (1+ depth))))
				((n (ch-map-node-rem-2-ins-1 transient-id node entry-idx subnode-idx n2))))))
			  (logandc2f (ch-map-node-entry-mask n) (ash 1 hash-bits))
			  (logiorf (ch-map-node-subnode-mask n) (ash 1 hash-bits))
			  (incf (ch-map-node-size n))
			  (unless (consp n2)
			    (hash-mixf (ch-map-node-key-hash n) key-hash))
			  (when (ch-map-node-value-hash n)
			    ;; `ex-val' is now included in `n2'; we mustn't double-count it.
			    (hash-unmixf (ch-map-node-value-hash n) (hash-to-fixnum ex-val val-hash-fn))
			    (hash-mixf (ch-map-node-value-hash n) (ch-map-tree-value-hash n2 val-hash-fn)))
			  (values n t))))
		  ;; No entry found: check for subnode
		  (if (logbitp hash-bits subnode-mask)
		      ;; Subnode found
		      (let ((subnode (svref node subnode-idx))
			    ((old-subnode-size (ch-map-tree-size subnode))
			     (old-subnode-key-hash (ch-map-tree-key-hash subnode))
			     (old-subnode-val-hash (and (ch-map-node-value-hash node)
							(ch-map-tree-value-hash subnode val-hash-fn)))
			     (new-subnode changed? (rec subnode (ash hash-shifted (- champ-hash-bits-per-level))
							(1+ depth)))))
			(if (not changed?)
			    (values node nil)
			  ;; New subnode
			  (let ((n (ch-map-node-update transient-id node subnode-idx new-subnode)))
			    ;; If only a value was updated, the subnode won't have changed size.
			    (setf (ch-map-node-size n)
				  (the fixnum (+ (ch-map-node-size n) (- (ch-map-tree-size new-subnode)
									 old-subnode-size))))
			    (hash-mixf (ch-map-node-key-hash n) (hash-unmix (ch-map-tree-key-hash new-subnode)
									    old-subnode-key-hash))
			    (when (ch-map-node-value-hash n)
			      (hash-mixf (ch-map-node-value-hash n)
					 (hash-unmix (ch-map-tree-value-hash new-subnode val-hash-fn)
						     old-subnode-val-hash)))
			    (values n t))))
		    ;; Neither entry nor subnode found: make new entry
		    (let ((n (ch-map-node-insert-2 transient-id node entry-idx key value)))
		      (logiorf (ch-map-node-entry-mask n) (ash 1 hash-bits))
		      (incf (ch-map-node-size n))
		      (hash-mixf (ch-map-node-key-hash n) key-hash)
		      (when (ch-map-node-value-hash n)
			(hash-mixf (ch-map-node-value-hash n) (hash-to-fixnum value val-hash-fn)))
		      (values n t))))))))))))

(declaim (inline reuse-ch-map-node?))
(defun reuse-ch-map-node? (transient-id node node-len &optional (insertions 1))
  (declare (optimize (speed 3) (safety 0))
	   (simple-vector node)
	   (fixnum node-len insertions)
	   (type (or null fixnum) transient-id))
  (and transient-id
       (let ((n-entries (logcount (ch-map-node-entry-mask node)))
	     (n-subnodes (logcount (ch-map-node-subnode-mask node))))
	 (and (>= node-len (+ ch-map-node-header-size (* 2 n-entries) n-subnodes insertions))
	      (eql transient-id (the fixnum (svref node (+ ch-map-node-header-size (* 2 n-entries)))))))))

(defun ch-map-node-insert-2 (transient-id node idx val-0 val-1)
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector node)
	   (type (and fixnum unsigned-byte) idx))
  (let ((len (length node))
	(n-entries (logcount (ch-map-node-entry-mask node)))
	(n-subnodes (logcount (ch-map-node-subnode-mask node)))
	((hdr+entries (+ ch-map-node-header-size (* 2 n-entries)))))
    (if (reuse-ch-map-node? transient-id node len 2)
	(let ((move-end (min (1+ hdr+entries) (- len n-subnodes 2))))
	  (dotimes (i (- move-end idx))
	    (setf (svref node (- (1+ move-end) i)) (svref node (- move-end i 1))))
	  (setf (svref node idx) val-0)
	  (setf (svref node (1+ idx)) val-1)
	  node)
      (let ((min-len (+ hdr+entries n-subnodes 2))
	    ((new-len (if transient-id (min (+ min-len (ch-map-node-transient-space (1+ n-entries) n-subnodes))
					    (+ ch-map-node-header-size (* 2 champ-node-radix) 1))
			min-len))
	     ((n (make-array new-len)))))
	(assert (<= idx hdr+entries))
	(when transient-id
	  (setf (svref n (+ hdr+entries 2)) transient-id))
	(dotimes (i idx)
	  (setf (svref n i) (svref node i)))
	(setf (svref n idx) val-0)
	(setf (svref n (1+ idx)) val-1)
	(dotimes (i (- hdr+entries idx))
	  (setf (svref n (+ idx i 2)) (svref node (+ idx i))))
	(dotimes (i n-subnodes)
	  (setf (svref n (- new-len i 1)) (svref node (- len i 1))))
	n))))

(defun ch-map-node-update (transient-id node idx val)
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector node)
	   (type fixnum idx))
  (let ((len (length node)))
    (if (reuse-ch-map-node? transient-id node len)
	(progn
	  (setf (svref node idx) val)
	  node)
      (let ((n-entries (logcount (ch-map-node-entry-mask node)))
	    (n-subnodes (logcount (ch-map-node-subnode-mask node)))
	    ((hdr+entries (+ ch-map-node-header-size (* 2 n-entries)))
	     ((min-len (+ hdr+entries n-subnodes))
	      ((new-len (if transient-id (min (+ min-len (ch-map-node-transient-space n-entries n-subnodes))
					      (+ ch-map-node-header-size (* 2 champ-node-radix) 1))
			  min-len))
	       ((n (make-array new-len)))))))
	(assert (>= idx hdr+entries))
	(when transient-id
	  (setf (svref n hdr+entries) transient-id))
	(dotimes (i hdr+entries)
	  (setf (svref n i) (svref node i)))
	(dotimes (i n-subnodes)
	  (setf (svref n (- new-len i 1)) (svref node (- len i 1))))
	(setf (svref n (+ idx (- new-len len))) val)
	n))))

(defun ch-map-node-update-2 (transient-id node idx val-0 val-1)
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector node)
	   (type fixnum idx))
  (let ((len (length node)))
    (if (reuse-ch-map-node? transient-id node len)
	(progn
	  (setf (svref node idx) val-0)
	  (setf (svref node (1+ idx)) val-1)
	  node)
      (let ((n-entries (logcount (ch-map-node-entry-mask node)))
	    (n-subnodes (logcount (ch-map-node-subnode-mask node)))
	    ((hdr+entries (+ ch-map-node-header-size (* 2 n-entries)))
	     ((min-len (+ hdr+entries n-subnodes))
	      ((new-len (if transient-id (min (+ min-len (ch-map-node-transient-space n-entries n-subnodes))
					      (+ ch-map-node-header-size (* 2 champ-node-radix) 1))
			  min-len))
	       ((n (make-array new-len)))))))
	(assert (< idx hdr+entries))
	(when transient-id
	  (setf (svref n hdr+entries) transient-id))
	(dotimes (i hdr+entries)
	  (setf (svref n i) (svref node i)))
	(dotimes (i n-subnodes)
	  (setf (svref n (- new-len i 1)) (svref node (- len i 1))))
	(setf (svref n idx) val-0)
	(setf (svref n (1+ idx)) val-1)
	n))))

(defun ch-map-node-rem-2-ins-1 (transient-id node rem-idx ins-idx ins-val)
  "`ins-idx' is where `ins-val' will end up, i.e., the index it will have in
the result, not that of the existing element it will be inserted after."
  (declare (optimize (speed 3) (safety 0))
	   (simple-vector node)
	   (type (and fixnum unsigned-byte) rem-idx ins-idx))
  (assert (<= rem-idx ins-idx))
  (let ((len (length node))
	(n-entries (logcount (ch-map-node-entry-mask node)))
	(n-subnodes (logcount (ch-map-node-subnode-mask node)))
	((hdr+entries (+ ch-map-node-header-size (* 2 n-entries)))))   ; value before removal
    (if (reuse-ch-map-node? transient-id node len)
	(progn
	  (dotimes (i (- hdr+entries rem-idx 1))
	    (setf (svref node (+ rem-idx i)) (svref node (+ rem-idx i 2))))
	  (setf (svref node (1- hdr+entries)) 0)  ; for GC
	  (let ((b (- len n-subnodes 1)))
	    (dotimes (i (- n-subnodes (- len ins-idx 1)))
	      (setf (svref node (+ b i)) (svref node (+ b i 1)))))
	  (setf (svref node ins-idx) ins-val)
	  node)
      (let ((min-len (+ hdr+entries n-subnodes -1))
	    ((new-len (if transient-id
			  (min (+ min-len (ch-map-node-transient-space (1- n-entries) (1+ n-subnodes)))
			       (+ ch-map-node-header-size (* 2 champ-node-radix) 1))
			min-len))
	     ((n (make-array new-len))
	      (new-ins-idx (+ ins-idx (- new-len len))))))
	(when transient-id
	  (setf (svref n (- hdr+entries 2)) transient-id))
	(assert (and (< rem-idx hdr+entries) (>= ins-idx (- hdr+entries 2))))
	(dotimes (i rem-idx)						; copy [0..rem-idx)
	  (setf (svref n i) (svref node i)))
	(dotimes (i (- hdr+entries rem-idx 2))				; move (rem-idx + 1..hdr+entries) down 2
	  (setf (svref n (+ rem-idx i)) (svref node (+ rem-idx i 2))))
	(dotimes (i (- len ins-idx 1))					; copy (ins-idx..len)
	  (setf (svref n (- new-len i 1)) (svref node (- len i 1))))
	(setf (svref n new-ins-idx) ins-val)				; store ins-idx
	(dotimes (i (- n-subnodes (- len ins-idx 1)))			; copy remaining subnodes
	  (setf (svref n (- new-ins-idx i 1)) (svref node (- ins-idx i))))
	n))))

(defun ch-map-tree-hash-value (tree val-hash-fn)
  (hash-mix (ch-map-tree-key-hash tree) (ch-map-tree-value-hash tree val-hash-fn)))

(declaim (ftype (function (ch-map-tree) fixnum) ch-map-tree-key-hash))
(defun ch-map-tree-key-hash (tree)
  (declare (optimize (speed 3) (safety 0)))
  (cond ((null tree) 0)
	((consp tree) (caar tree))
	(t (ch-map-node-key-hash tree))))

(declaim (ftype (function (ch-map-tree function) fixnum) ch-map-tree-value-hash))
(defun ch-map-tree-value-hash (tree val-hash-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function val-hash-fn))
  (cond ((null tree) 0)
	((consp tree)
	 (or (cdar tree)
	     (setf (cdar tree)
		   (let ((vhash 0))
		     (do-wb-map-tree-pairs (k v (cdr tree))
		       (declare (ignore k))
		       (hash-mixf vhash (hash-to-fixnum v val-hash-fn)))
		     vhash))))
	(t
	 (or (ch-map-node-value-hash tree)
	     ;; Could happen in multiple threads, but they'll compute the same result.
	     (setf (ch-map-node-value-hash tree)
		   (let ((vhash 0))
		     (dotimes (i (logcount (ch-map-node-entry-mask tree)))
		       (let ((k v (ch-map-node-entry tree i)))
			 (declare (ignore k))
			 (hash-mixf vhash (hash-to-fixnum v val-hash-fn))))
		     (dotimes (i (logcount (ch-map-node-subnode-mask tree)))
		       (hash-mixf vhash (ch-map-tree-value-hash (ch-map-node-subnode tree i) val-hash-fn)))
		     vhash))))))

(defun ch-map-tree-arb-pair (tree)
  (declare (optimize (speed 3) (safety 0)))
  (cond ((null tree)
	 (error "'ch-map-tree-arb' called on empty tree"))
	((consp tree)
	 (wb-map-tree-arb-pair (cdr tree)))
	((= 0 (ch-map-node-entry-mask tree))
	 ;; If there are no entries, there must be at least one subnode
	 (ch-map-tree-arb-pair (svref tree (1- (length tree)))))
	(t
	 (values (svref tree ch-map-node-header-size) (svref tree (1+ ch-map-node-header-size))))))

(defun ch-map-tree-less (tree key key-hash-fn key-cmp-fn val-hash-fn &optional transient-id (depth 0))
  "If the key was found, the second value is the associated value, else `nil'.
Third value is true iff the tree changed; the result can be eq to `tree', even
if it changed, if `transient-id' is supplied."
  (declare (optimize (speed 1) (safety 0))
	   (type function key-hash-fn key-cmp-fn val-hash-fn)
	   (type (integer 0 64) depth))
  (let ((key-hash (hash-to-fixnum key key-hash-fn)))
    (declare (fixnum key-hash))
    (rlabels (rec tree (ash key-hash (- (* champ-hash-bits-per-level depth))) depth)
      (rec (node hash-shifted depth)
	;; Third value is true when the first value might be eq to `node', but it has been modified.
	(declare (fixnum hash-shifted)
		 (type (integer 0 64) depth))
	(and node
	     (if (consp node)
		 (if (/= (the fixnum (caar node)) key-hash)
		     (values node nil nil)
		   (let ((new-wb-tree ex-value (wb-map-tree-less (cdr node) key key-cmp-fn)))
		     (if (eq new-wb-tree (cdr node))
			 (values node nil nil)
		       (let ((value-hash (and (cdar node)
					      (hash-unmix (cdar node) (hash-to-fixnum ex-value val-hash-fn)))))
			 (if (= 1 (wb-map-tree-size new-wb-tree))
			     (let ((k v (wb-map-tree-arb-pair new-wb-tree))
				   (new-entry-mask (ash 1 (logcount (logand hash-shifted champ-hash-level-mask)))))
			       (values (make-ch-map-node transient-id new-entry-mask 0 1 key-hash value-hash k v)
				       ex-value t))
			   (values (cons (cons (caar node) value-hash) new-wb-tree)
				   ex-value t))))))
	       (let ((hash-bits (logand hash-shifted champ-hash-level-mask))
		     (entry-mask (ch-map-node-entry-mask node))
		     ((entry-raw-idx (1-bits-below hash-bits entry-mask))
		      ((entry-idx (+ ch-map-node-header-size (* 2 entry-raw-idx)))))
		     (subnode-mask (ch-map-node-subnode-mask node)))
		 (if (logbitp hash-bits entry-mask)
		     (let ((ex-key (svref node entry-idx))
			   (ex-val (svref node (1+ entry-idx))))
		       (cond ((not (equal?-cmp ex-key key key-cmp-fn))
			      (values node nil nil))
			     ((and (= (logcount entry-mask) 1) (= 0 subnode-mask))
			      (assert (= depth 0))
			      (values nil (svref node (1+ entry-idx)) t))
			     (t
			      (let ((n (ch-map-node-remove-2 transient-id node entry-idx)))
				(logandc2f (ch-map-node-entry-mask n) (ash 1 hash-bits))
				(decf (ch-map-node-size n))
				(hash-unmixf (ch-map-node-key-hash n) key-hash)
				(when (ch-map-node-value-hash n)
				  (hash-unmixf (ch-map-node-value-hash n)
					       (hash-to-fixnum ex-val val-hash-fn)))
				(values n (svref node (1+ entry-idx)) t)))))
		   (let ((subnode-raw-idx (1-bits-below hash-bits subnode-mask))
			 ((subnode-idx (- (the fixnum (length node)) 1 subnode-raw-idx))))
		     (declare (fixnum subnode-raw-idx subnode-idx))
		     (if (not (logbitp hash-bits subnode-mask))
			 (values node nil nil)
		       (let ((subnode (svref node subnode-idx))
			     ((old-subnode-key-hash (ch-map-tree-key-hash subnode))
			      (old-subnode-val-hash (and (ch-map-node-value-hash node)
							 (ch-map-tree-value-hash subnode val-hash-fn)))
			      (new-subnode lookup-val changed?
				(rec subnode (ash hash-shifted (- champ-hash-bits-per-level)) (1+ depth)))))
			 (if (not changed?)
			     (values node nil nil)
			   (let ((n (cond ((consp new-subnode)
					   (ch-map-node-update transient-id node subnode-idx new-subnode))
					  ((and (= 1 (logcount (ch-map-node-entry-mask new-subnode)))
						(= 0 (ch-map-node-subnode-mask new-subnode)))
					   ;; New subnode contains only a single entry: pull it up into this node
					   (let ((new-entry-idx
						   (+ ch-map-node-header-size
						      (* 2 (1-bits-below hash-bits entry-mask))))
						 (k v (ch-map-node-entry new-subnode 0))
						 ((n (ch-map-node-ins-2-rem-1 transient-id node new-entry-idx k v
									      subnode-idx))))
					     (logiorf (ch-map-node-entry-mask n) (ash 1 hash-bits))
					     (logandc2f (ch-map-node-subnode-mask n) (ash 1 hash-bits))
					     n))
					  ((let ((only-subnode))
					     (and (= 0 (ch-map-node-entry-mask new-subnode))
						  (= 1 (logcount (ch-map-node-subnode-mask new-subnode)))
						  (consp (setq only-subnode (ch-map-node-subnode new-subnode 0)))))
					   ;; New subnode contains only a collision node: pull it up into this node
					   (ch-map-node-update transient-id node subnode-idx only-subnode))
					  (t (ch-map-node-update transient-id node subnode-idx new-subnode)))))
			     (decf (ch-map-node-size n))
			     (hash-mixf (ch-map-node-key-hash n) (hash-unmix (ch-map-tree-key-hash new-subnode)
									     old-subnode-key-hash))
			     (when (ch-map-node-value-hash n)
			       (hash-mixf (ch-map-node-value-hash n)
					  (hash-unmix (ch-map-tree-value-hash new-subnode val-hash-fn)
						      old-subnode-val-hash)))
			     (values n lookup-val t))))))))))))))

(defun ch-map-node-remove-2 (transient-id node idx)
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector node)
	   (type (unsigned-byte 24) idx))
  (let ((len (length node))
	(n-entries (logcount (ch-map-node-entry-mask node)))
	(n-subnodes (logcount (ch-map-node-subnode-mask node)))
	((hdr+entries (+ ch-map-node-header-size (* 2 n-entries)))))	; value before removal
    (if (reuse-ch-map-node? transient-id node len)
	(let ((move-end (+ hdr+entries 1)))
	  (dotimes (i (- move-end idx 2))
	    (setf (svref node (+ idx i)) (svref node (+ idx i 2))))
	  node)
      (let ((min-len (+ hdr+entries n-subnodes -2))
	    ((new-len (if transient-id (min (+ min-len (ch-map-node-transient-space n-entries n-subnodes))
					    (+ ch-map-node-header-size (* 2 champ-node-radix) 1))
			min-len))
	     ((n (make-array new-len)))))
	(when transient-id
	  (setf (svref n (- hdr+entries 2)) transient-id))
	(dotimes (i idx)
	  (setf (svref n i) (svref node i)))
	(dotimes (i (- hdr+entries idx 2))
	  (setf (svref n (+ idx i)) (svref node (+ idx i 2))))
	(dotimes (i n-subnodes)
	  (setf (svref n (- new-len i 1)) (svref node (- len i 1))))
	n))))

(defun ch-map-node-ins-2-rem-1 (transient-id node ins-idx ins-0 ins-1 rem-idx)
  (declare (optimize (speed 3) (safety 0))
	   (simple-vector node)
	   (type (and fixnum unsigned-byte) rem-idx ins-idx))
  (assert (<= ins-idx rem-idx))
  (let ((len (length node))
	(n-entries (logcount (ch-map-node-entry-mask node)))
	(n-subnodes (logcount (ch-map-node-subnode-mask node)))
	((hdr+entries (+ ch-map-node-header-size (* 2 n-entries)))))   ; value before insertion
    (if (reuse-ch-map-node? transient-id node len)
	(let ((move-end (min (1+ hdr+entries) (- len n-subnodes 1))))
	  (dotimes (i (- rem-idx (- len n-subnodes)))
	    (setf (svref node (- rem-idx i)) (svref node (- rem-idx i 1))))
	  (dotimes (i (- move-end ins-idx))
	    (setf (svref node (- (1+ move-end) i)) (svref node (- move-end i 1))))
	  (when (> (- len n-subnodes) (1+ hdr+entries))
	    (setf (svref node (- len n-subnodes)) 0))   ; for GC
	  (setf (svref node ins-idx) ins-0)
	  (setf (svref node (1+ ins-idx)) ins-1)
	  node)
      (let ((min-len (+ hdr+entries n-subnodes 1))
	    ((new-len (if transient-id
			  (min (+ min-len (ch-map-node-transient-space (1+ n-entries) (1- n-subnodes)))
			       (+ ch-map-node-header-size (* 2 champ-node-radix) 1))
			min-len))
	     ((n (make-array new-len))
	      (new-rem-idx (+ rem-idx (- new-len len))))))
	(when transient-id
	  (setf (svref n (+ hdr+entries 2)) transient-id))
	(assert (and (<= ins-idx hdr+entries) (>= rem-idx (- len n-subnodes))))
	(dotimes (i ins-idx)							; copy [0..ins-idx)
	  (setf (svref n i) (svref node i)))
	(setf (svref n ins-idx) ins-0)						; store ins-idx
	(setf (svref n (1+ ins-idx)) ins-1)
	(dotimes (i (- hdr+entries ins-idx))					; move [ins-idx..hdr+entries) up 2
	  (setf (svref n (- (1+ hdr+entries) i)) (svref node (- hdr+entries i 1))))
	(dotimes (i (- len rem-idx 1))						; copy (rem-idx..len)
	  (setf (svref n (- new-len i 1)) (svref node (- len i 1))))
	(dotimes (i (- rem-idx (- len n-subnodes)))				; copy remaining subnodes
	  (setf (svref n (- new-rem-idx i)) (svref node (- rem-idx i 1))))
	n))))

(defun ch-map-tree-lookup (tree key key-hash-fn key-cmp-fn &optional (depth 0))
  (declare (optimize (speed 3) (safety 0))
	   (type function key-hash-fn key-cmp-fn)
	   (type (integer 0 64) depth))
  (let ((key-hash (hash-to-fixnum key key-hash-fn)))
    (declare (fixnum key-hash))
    (rlabels (rec tree key (ash key-hash (- (* champ-hash-bits-per-level depth))))
      (rec (node key hash-shifted)
	(declare (fixnum hash-shifted))
	(and node
	     (if (consp node)
		 (wb-map-tree-lookup (cdr node) key key-cmp-fn)
	       (let ((hash-bits (logand hash-shifted champ-hash-level-mask))
		     (entry-mask (ch-map-node-entry-mask node)))
		 (if (logbitp hash-bits entry-mask)
		     (let ((entry-idx (+ ch-map-node-header-size
					 (* 2 (1-bits-below hash-bits entry-mask))))
			   ((ex-key (svref node entry-idx))))
		       (and (equal?-cmp ex-key key key-cmp-fn)
			    (values t (svref node (1+ entry-idx)) (svref node entry-idx))))
		   (let ((subnode-mask (ch-map-node-subnode-mask node)))
		     (and (logbitp hash-bits subnode-mask)
			  (let ((subnode-idx (- (the fixnum (length node))
						1 (1-bits-below hash-bits subnode-mask)))
				((subnode (svref node subnode-idx))))
			    (rec subnode key (ash hash-shifted (- champ-hash-bits-per-level))))))))))))))

(defun ch-map-tree-index (tree key key-hash-fn key-cmp-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function key-hash-fn key-cmp-fn))
  (let ((key-hash (hash-to-fixnum key key-hash-fn)))
    (declare (fixnum key-hash))
    (rlabels (rec tree key 0 key-hash)
      (rec (node key base hash-shifted)
	(declare (fixnum base hash-shifted))
	(and node
	     (if (consp node)
		 (let ((found? idx (wb-map-tree-rank (cdr node) key key-cmp-fn)))
		   (and found? (the fixnum (+ (the fixnum idx) base))))
	       (let ((hash-bits (logand hash-shifted champ-hash-level-mask))
		     (entry-mask (ch-map-node-entry-mask node)))
		 (if (logbitp hash-bits entry-mask)
		     (let ((ientry (1-bits-below hash-bits entry-mask))
			   ((entry-idx (+ ch-map-node-header-size (* 2 ientry)))
			    ((ex-key (svref node entry-idx)))))
		       (and (equal?-cmp ex-key key key-cmp-fn)
			    (the fixnum (+ base ientry))))
		   (let ((subnode-mask (ch-map-node-subnode-mask node)))
		     (incf base (logcount entry-mask))
		     (and (logbitp hash-bits subnode-mask)
			  (let ((isubnode (1-bits-below hash-bits subnode-mask))
				(len (length (the simple-vector node)))
				((subnode-idx (- len 1 isubnode))
				 ((subnode (svref node subnode-idx)))))
			    (dotimes (i isubnode)
			      (incf base (ch-map-tree-size (svref node (- len 1 i)))))
			    (rec subnode key base (ash hash-shifted (- champ-hash-bits-per-level))))))))))))))

(defun ch-map-tree-index-pair (tree index)
  (declare (optimize (speed 3) (safety 0)))
  (rlabels (rec tree index)
    (rec (tree index)
      (declare (fixnum index))
      (if (consp tree)
	  (wb-map-tree-rank-pair (cdr tree) index)
	(let ((len (length (the simple-vector tree)))
	      (entry-mask (ch-map-node-entry-mask tree))
	      ((n-entries (logcount entry-mask))))
	  (if (< index n-entries)
	      (let ((idx (+ ch-map-node-header-size (* 2 index))))
		(values (svref tree idx) (svref tree (1+ idx))))
	    (let ((subnode-mask (ch-map-node-subnode-mask tree)))
	      (decf index n-entries)
	      (dotimes (i (logcount subnode-mask))
		(let ((subnode (svref tree (- len i 1)))
		      ((subnode-size (ch-map-tree-size subnode))))
		  (when (< index subnode-size)
		    (return (rec subnode index)))
		  (decf index subnode-size))))))))))

(defun ch-map-tree-domain (tree key-hash-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function key-hash-fn))
  (if (null tree) nil
    (rlabels (rec tree)
      (rec (node)
	(if (consp node)
	    (let ((wb-dom (wb-map-tree-domain (cdr node))))
	      (cons (hash-to-fixnum (wb-set-tree-arb wb-dom) key-hash-fn) wb-dom))
	  (let ((len (length (the simple-vector node)))
		(entry-mask (ch-map-node-entry-mask node))
		(subnode-mask (ch-map-node-subnode-mask node))
		((nentries (logcount entry-mask))
		 (nsubnodes (logcount subnode-mask))
		 ((res-len (+ ch-set-node-header-size nentries nsubnodes))
		  ((n (make-array res-len)))))
		(hash 0))
	    (setf (ch-set-node-entry-mask n) entry-mask)
	    (setf (ch-set-node-subnode-mask n) subnode-mask)
	    (setf (ch-set-node-size n) (ch-map-node-size node))
	    (dotimes (i nentries)
	      (let ((x (svref node (+ ch-map-node-header-size (* 2 i)))))
		(setf (svref n (+ ch-set-node-header-size i)) x)
		(hash-mixf hash (hash-to-fixnum x key-hash-fn))))
	    (dotimes (i nsubnodes)
	      (let ((new-subnode (rec (svref node (- len i 1)))))
		(setf (svref n (- res-len i 1)) new-subnode)
		(hash-mixf hash (ch-set-tree-hash-value new-subnode))))
	    (setf (ch-set-node-hash-value n) hash)
	    n))))))

(defun ch-map-tree-compare (tree1 tree2 key-cmp-fn val-hash-fn val-cmp-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function key-cmp-fn val-hash-fn val-cmp-fn))
  (if (eq tree1 tree2) ':equal
    (let ((size1 (ch-map-tree-size tree1))
	  (size2 (ch-map-tree-size tree2)))
      (cond
	((< size1 size2) ':less)
	((> size1 size2) ':greater)
	(t
	 (let ((khash1 (ch-map-tree-key-hash tree1))
	       (khash2 (ch-map-tree-key-hash tree2)))
	   (cond
	     ((< khash1 khash2) ':less)
	     ((> khash1 khash2) ':greater)
	     (t
	      (let ((vhash1 (ch-map-tree-value-hash tree1 val-hash-fn))
		    (vhash2 (ch-map-tree-value-hash tree2 val-hash-fn)))
		(cond
		  ((< vhash1 vhash2) ':less)
		  ((> vhash1 vhash2) ':greater)
		  ((consp tree1)
		   (if (consp tree2) (wb-map-tree-compare (cdr tree1) (cdr tree2) key-cmp-fn val-cmp-fn)
		     ':less))
		  ((consp tree2) ':greater)
		  (t
		   (let ((entries1 (ch-map-node-entry-mask tree1))
			 (entries2 (ch-map-node-entry-mask tree2))
			 (subnodes1 (ch-map-node-subnode-mask tree1))
			 (subnodes2 (ch-map-node-subnode-mask tree2)))
		     (cond ((< entries1 entries2) ':less)
			   ((> entries1 entries2) ':greater)
			   ((< subnodes1 subnodes2) ':less)
			   ((> subnodes1 subnodes2) ':greater)
			   (t
			    ;; It's astronomically unlikely that we'll get here unless the trees are actually
			    ;; equal... but we still have to check.
			    (let ((default ':equal))
			      (dotimes (i (logcount entries1))
				(let ((k1 (svref tree1 (+ ch-map-node-header-size (* 2 i))))
				      (v1 (svref tree1 (+ ch-map-node-header-size (1+ (* 2 i)))))
				      (k2 (svref tree2 (+ ch-map-node-header-size (* 2 i))))
				      (v2 (svref tree2 (+ ch-map-node-header-size (1+ (* 2 i)))))
				      ((key-cmp (funcall key-cmp-fn k1 k2))))
				  (when (member key-cmp '(:less :greater))
				    (return-from ch-map-tree-compare key-cmp))
				  (when (eq key-cmp ':unequal)
				    (setq default ':unequal))
				  (let ((val-cmp (funcall val-cmp-fn v1 v2)))
				    (when (member val-cmp '(:less :greater))
				      (return-from ch-map-tree-compare val-cmp))
				    (when (eq val-cmp ':unequal)
				      (setq default ':unequal)))))
			      (let ((len1 (length (the simple-vector tree1)))
				    (len2 (length (the simple-vector tree2))))
				(dotimes (i (logcount subnodes1))
				  (let ((cmp (ch-map-tree-compare (svref tree1 (- len1 i 1)) (svref tree2 (- len2 i 1))
								  key-cmp-fn val-hash-fn val-cmp-fn)))
				    (ecase cmp
				      (:equal)
				      (:unequal
					(setq default ':unequal))
				      ((:less :greater)
					(return-from ch-map-tree-compare cmp))))))
			      default)))))))))))))))


;;; --------------------------------
;;; Iteration primitives

(defmacro do-ch-map-tree-pairs ((key-var value-var tree-form &optional value-form)
				&body body)
  (let ((body-fn (gensymx #:body-))
	(recur-fn (gensymx #:recur-)))
    `(block nil
       (labels ((,body-fn (,key-var ,value-var)
		  . ,body)
		(,recur-fn (tree)
		  (when tree
		    (if (consp tree)
			(do-wb-map-tree-pairs (,key-var ,value-var (cdr tree))
			  (,body-fn ,key-var ,value-var))
		      (let ((len (the fixnum (length (the simple-vector tree)))))
			(dotimes (i (logcount (ch-map-node-entry-mask tree)))
			  (let ((idx (+ (* 2 i) ch-map-node-header-size)))
			    (,body-fn (svref tree idx) (svref tree (1+ idx)))))
			(dotimes (i (logcount (ch-map-node-subnode-mask tree)))
			  (,recur-fn (svref tree (- len 1 i)))))))))
	 (declare (inline ,body-fn))
	 (,recur-fn ,tree-form))
       ,value-form)))

;;; ----------------
;;; Stateful iterator

(defun make-ch-map-tree-iterator (tree)
  (let ((iter (make-ch-map-tree-iterator-internal tree)))
    (lambda (op)
      (ecase op
	(:get (ch-map-tree-iterator-get iter))
	(:done? (ch-map-tree-iterator-done? iter))
	(:more? (not (ch-map-tree-iterator-done? iter)))))))

(defun make-ch-map-tree-iterator-internal (tree)
  (declare (optimize (speed 3) (safety 0)))
  (let ((iter (make-array (+ 1 (* 2 (ceiling (integer-length most-positive-fixnum) champ-hash-bits-per-level))))))
    (if (null tree)
	(setf (svref iter 0) -1)
      (progn
	(setf (svref iter 0) 1) ; the stack pointer
	(setf (svref iter 1) tree)
	(setf (svref iter 2) 0)
	(ch-map-tree-iterator-canonicalize iter)))
    iter))

(defun ch-map-tree-iterator-canonicalize (iter)
  (declare (optimize (speed 3) (safety 0)))
  (let ((sp (svref iter 0))
	((node (svref iter sp))
	 (idx (svref iter (1+ sp)))))
    (declare (type (or null fixnum) idx))
    (when (if (null idx)
	      (wb-map-tree-iterator-done? (svref iter sp))
	    (= idx (logcount (logior (ch-map-node-entry-mask node) (ch-map-node-subnode-mask node)))))
      (decf sp 2)
      (unless (< sp 0)
	(setq node (svref iter sp))
	(setq idx (svref iter (1+ sp)))))
    (unless (< sp 0)
      (loop
	(when (null idx)
	  (return))
	(let ((n-entries (logcount (ch-map-node-entry-mask node)))
	      (n-subnodes (logcount (ch-map-node-subnode-mask node))))
	  (when (< idx n-entries)
	    (return))
	  (let ((len (length (the simple-vector node))))
	    (setq node (svref node (- len (- idx n-entries) 1)))
	    (incf idx)
	    (unless (= idx (+ n-entries n-subnodes)) ; TCO
	      (setf (svref iter (1+ sp)) idx)
	      (incf sp 2))
	    (if (consp node)
		(setq node (make-wb-map-tree-iterator-internal (cdr node))
		      idx nil)
	      (setq idx 0))
	    (setf (svref iter sp) node)
	    (setf (svref iter (1+ sp)) idx)))))
    (setf (svref iter 0) sp)))

(defun ch-map-tree-iterator-done? (iter)
  (declare (optimize (speed 3) (safety 0)))
  (< (the fixnum (svref iter 0)) 0))

(defun ch-map-tree-iterator-get (iter)
  (declare (optimize (speed 3) (safety 0)))
  (let ((sp (svref iter 0)))
    (declare (fixnum sp))
    (and (> sp 0)
	 (let ((node (svref iter sp))
	       (idx (svref iter (1+ sp))))
	   (declare (type (or null fixnum) idx))
	   (if (null idx)
	       (let ((key val (wb-map-tree-iterator-get node)))
		 (ch-map-tree-iterator-canonicalize iter)
		 (values key val t))
	     (let ((entry-idx (+ ch-map-node-header-size (the fixnum (* 2 idx)))))
	       (setf (svref iter (1+ sp)) (1+ idx))
	       (ch-map-tree-iterator-canonicalize iter)
	       (values (svref node entry-idx) (svref node (1+ entry-idx))
		       t)))))))

;;; ----------------
;;; Functional iterator

(defun ch-map-tree-fun-iter (tree)
  (declare (optimize (speed 3) (safety 0)))
  (rlabels (walk tree (lambda (op)
			(ecase op
			  (:first (values nil nil))
			  (:empty? t)
			  (:more? nil))))
    (walk (node cont)
      (if (consp node)
	  (wb-map-tree-fun-iter (cdr node) cont)
	(let ((n-entries (logcount (ch-map-node-entry-mask node)))
	      (n-subnodes (logcount (ch-map-node-subnode-mask node))))
	  (rlabels (entry 0)
	    (entry (i)
	      (declare (fixnum i))
	      (if (< i n-entries)
		  (lambda (op)
		    (ecase op
		      (:first (let ((entry-idx (+ ch-map-node-header-size (the fixnum (* 2 i)))))
				(values (svref node entry-idx) (svref node (1+ entry-idx)) t)))
		      (:rest (entry (1+ i)))
		      (:empty? nil)
		      (:more? t)))
		(subnode 0)))
	    (subnode (i)
	      (declare (fixnum i))
	      (if (< i n-subnodes)
		  (walk (svref node (- (+ ch-map-node-header-size (* 2 n-entries) n-subnodes)
				       i 1))
			(lambda (op) (funcall (the function (subnode (1+ i))) op)))
		cont))))))))

(defun ch-map-tree-rev-fun-iter (tree)
  (declare (optimize (speed 3) (safety 0)))
  (rlabels (walk tree (lambda (op)
			(ecase op
			  (:first (values nil nil))
			  (:empty? t)
			  (:more? nil))))
    (walk (node cont)
      (if (consp node)
	  (wb-map-tree-rev-fun-iter (cdr node) cont)
	(let ((n-entries (logcount (ch-map-node-entry-mask node)))
	      (n-subnodes (logcount (ch-map-node-subnode-mask node))))
	  (rlabels (subnode (1- n-subnodes))
	    (entry (i)
	      (declare (fixnum i))
	      (if (>= i 0)
		  (lambda (op)
		    (ecase op
		      (:first (let ((entry-idx (+ ch-map-node-header-size (the fixnum (* 2 i)))))
				(values (svref node entry-idx) (svref node (1+ entry-idx)) t)))
		      (:rest (entry (1- i)))
		      (:empty? nil)
		      (:more? t)))
		cont))
	    (subnode (i)
	      (declare (fixnum i))
	      (if (>= i 0)
		  (walk (svref node (- (+ ch-map-node-header-size (* 2 n-entries) n-subnodes)
				       i 1))
			(lambda (op) (funcall (the function (subnode (1- i))) op)))
		(entry (1- n-entries))))))))))


;;; --------------------------------
;;; Union, intersection, set-difference, subset?, disjoint?

(declaim (inline ch-map-node-add-entry!))
(defun ch-map-node-add-entry! (n idx key val key-hash-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type champ-bit-index idx)
	   (type function key-hash-fn))
  (let ((entry-idx (+ ch-map-node-header-size (* 2 (logcount (ch-map-node-entry-mask n))))))
    (setf (svref n entry-idx) key)
    (setf (svref n (1+ entry-idx)) val))
  (logiorf (ch-map-node-entry-mask n) (ash 1 idx))
  (incf (ch-map-node-size n))
  (hash-mixf (ch-map-node-key-hash n) (hash-to-fixnum key key-hash-fn)))

(declaim (inline ch-map-node-add-subnode!))
(defun ch-map-node-add-subnode! (n idx subnode key-hash-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type champ-bit-index idx)
	   (type function key-hash-fn))
  (when subnode
    (if (and (not (consp subnode))
	     (= 1 (logcount (ch-map-node-entry-mask subnode)))
	     (= 0 (ch-map-node-subnode-mask subnode)))
	;; `subnode' contains only an entry -- pull it up.
	(ch-map-node-add-entry! n idx (svref subnode ch-map-node-header-size)
			       (svref subnode (1+ ch-map-node-header-size)) key-hash-fn)
      (progn
	(when (and (not (consp subnode))
		   (= 0 (ch-map-node-entry-mask subnode))
		   (= 1 (logcount (ch-map-node-subnode-mask subnode)))
		   (consp (svref subnode (1- (length subnode)))))
	  ;; `subnode' contains only a collision subnode -- pull it up.
	  (setq subnode (svref subnode (1- (length subnode)))))
	(setf (svref n (- (length (the simple-vector n))
			  (logcount (ch-map-node-subnode-mask n)) 1))
	      subnode)
	(logiorf (ch-map-node-subnode-mask n) (ash 1 idx))
	(incf (ch-map-node-size n) (ch-map-tree-size subnode))
	(hash-mixf (ch-map-node-key-hash n) (ch-map-tree-key-hash subnode))))))

(defun ch-map-tree-union (tree1 tree2 val-fn key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn)
  (declare (optimize (speed 1) (safety 0))
	   (type function val-fn key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn))
  (rlabels (rec tree1 tree2 0)
    (rec (tree1 tree2 depth)
      (declare (type (integer 0 64) depth)
	       (type function val-fn))
      (cond ((null tree1) tree2)
	    ((null tree2) tree1)
	    ((eq tree1 tree2) tree1)
	    ((and (consp tree1) (consp tree2))
	     (if (= (the fixnum (caar tree1)) (the fixnum (caar tree2)))
		 (let ((result (wb-map-tree-union (cdr tree1) (cdr tree2) val-fn key-cmp-fn val-cmp-fn)))
		   (ch-map-node-from-wb result (caar tree1) depth))
	       (let ((bits1 (champ-hash-bits (the fixnum (caar tree1)) depth))
		     (bits2 (champ-hash-bits (the fixnum (caar tree2)) depth))
		     (size (+ (wb-map-tree-size (cdr tree1)) (wb-map-tree-size (cdr tree2))))
		     (key-hash (hash-mix (caar tree1) (caar tree2))))
		 (declare (fixnum size))
		 (if (= bits1 bits2)
		     (vector 0 (ash 1 bits1) size key-hash nil (rec tree1 tree2 (1+ depth)))
		   (let ((subnode0 subnode1 (swap-if (> bits1 bits2) tree1 tree2)))
		     (vector 0 (logior (ash 1 bits1) (ash 1 bits2)) size key-hash nil subnode1 subnode0))))))
	    ((or (consp tree1) (consp tree2))
	     ;; I foolishly undertook to implement left preference and make this case more efficient at
	     ;; the same time.  Turned out to take a crapload of code (and my time), for a not-very-common
	     ;; case.  Sometimes maximum performance is not worth the complication.
	     (let ((tree1-collision? (consp tree1))
		   ((norm-node coll-node (swap-if tree1-collision? tree1 tree2))
		    ((hash-bits (champ-hash-bits (the fixnum (caar coll-node)) depth))
		     (entry-mask (ch-map-node-entry-mask norm-node))
		     (subnode-mask (ch-map-node-subnode-mask norm-node)))))
	       (declare (type simple-vector norm-node))
	       (cond ((logbitp hash-bits entry-mask)
		      (let ((ientry (1-bits-below hash-bits entry-mask))
			    ((norm-key norm-val (ch-map-node-entry norm-node ientry))
			     ((coll-val? coll-val coll-key (wb-map-tree-lookup (cdr coll-node) norm-key key-cmp-fn))
			      ((new-subnode
				 (if coll-val?
				     (let ((new-val second-val
					     (if tree1-collision? (compute-new-val coll-val norm-val)
					       (compute-new-val norm-val coll-val))))
				       (if (eq second-val ':no-value)
					   (ch-map-tree-less coll-node norm-key key-hash-fn key-cmp-fn val-hash-fn
							     nil (1+ depth))
					 (ch-map-tree-with coll-node (if tree1-collision? coll-key norm-key)
							   new-val key-hash-fn key-cmp-fn val-hash-fn
							   val-cmp-fn nil (1+ depth) (not tree1-collision?))))
				   (ch-map-tree-with coll-node norm-key norm-val key-hash-fn key-cmp-fn val-hash-fn
						     val-cmp-fn nil (1+ depth) (not tree1-collision?))))))))
			(ch-map-node-change-entry-to-subnode norm-node hash-bits new-subnode key-hash-fn val-hash-fn)))
		     ((logbitp hash-bits subnode-mask)
		      (let ((isubnode (1-bits-below hash-bits subnode-mask))
			    ((old-subnode (ch-map-node-subnode norm-node isubnode))))
			(ch-map-node-replace-subnode norm-node hash-bits
						     (if tree1-collision? (rec coll-node old-subnode (1+ depth))
						       (rec old-subnode coll-node (1+ depth)))
						     key-hash-fn val-hash-fn)))
		     (t
		      (ch-map-node-insert-subnode norm-node hash-bits coll-node val-hash-fn)))))
	    (t
	     (let ((entries1 (ch-map-node-entry-mask tree1))
		   (entries2 (ch-map-node-entry-mask tree2))
		   (subnodes1 (ch-map-node-subnode-mask tree1))
		   (subnodes2 (ch-map-node-subnode-mask tree2))
		   ((all-entries (logior entries1 entries2))
		    (all-subnodes (logior subnodes1 subnodes2))
		    ((everything (logior all-entries all-subnodes))
		     ;; The `:no-value' feature creates the possibility that a subnode, on one or both sides,
		     ;; will change to an entry; in the worst case, this could happen to all of them.
		     ((res-len (+ ch-map-node-header-size (* 2 (logcount everything))))
		      ((res-n (make-array res-len :initial-element 0))))))
		   (ientry1 0)
		   (isubnode1 0)
		   (ientry2 0)
		   (isubnode2 0))
	       (declare (fixnum ientry1 isubnode1 ientry2 isubnode2))
	       (setf (ch-map-node-value-hash res-n) nil)
	       (flet ((add-entry (idx key val)
			(ch-map-node-add-entry! res-n idx key val key-hash-fn))
		      (add-subnode (idx subnode)
			(ch-map-node-add-subnode! res-n idx subnode key-hash-fn)
			nil)  ; hush, SBCL
		      (subtree-lookup (tree key)
			(ch-map-tree-lookup tree key key-hash-fn key-cmp-fn (1+ depth)))
		      (subtree-with (subtree key value &optional replace?)
			(ch-map-tree-with subtree key value key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn
					  nil (1+ depth) replace?))
		      (subtree-less (subtree key)
			(ch-map-tree-less subtree key key-hash-fn key-cmp-fn val-hash-fn nil (1+ depth))))
		 (do-bit-indices (idx everything)
		   (cond ((and (logbitp idx entries1) (logbitp idx entries2))
			  (let ((key1 val1 (ch-map-node-entry tree1 (postincf ientry1)))
				(key2 val2 (ch-map-node-entry tree2 (postincf ientry2))))
			    (if (equal?-cmp key1 key2 key-cmp-fn)
				(let ((new-val second-val (compute-new-val val1 val2)))
				  (unless (eq second-val ':no-value)
				    (add-entry idx key1 new-val)))
			      (add-subnode idx (subtree-with (subtree-with nil key1 val1) key2 val2)))))
			 ((logbitp idx entries1)
			  (let ((key1 val1 (ch-map-node-entry tree1 (postincf ientry1))))
			    (if (logbitp idx subnodes2)
				(let ((subnode2 (ch-map-node-subnode tree2 (postincf isubnode2)))
				      ((val2? val2 (subtree-lookup subnode2 key1))))
				  (if val2?
				      (let ((new-val second-val (compute-new-val val1 val2)))
					(if (eq second-val ':no-value)
					    (add-subnode idx (subtree-less subnode2 key1))
					  (add-subnode idx (subtree-with subnode2 key1 new-val t))))
				    (add-subnode idx (subtree-with subnode2 key1 val1 t))))
			      (add-entry idx key1 val1))))
			 ((logbitp idx entries2)
			  (let ((key2 val2 (ch-map-node-entry tree2 (postincf ientry2))))
			    (if (logbitp idx subnodes1)
				(let ((subnode1 (ch-map-node-subnode tree1 (postincf isubnode1)))
				      ((val1? val1 key1 (subtree-lookup subnode1 key2))))
				  (if val1?
				      (let ((new-val second-val (compute-new-val val1 val2)))
					(if (eq second-val ':no-value)
					    (add-subnode idx (subtree-less subnode1 key2))
					  (add-subnode idx (subtree-with subnode1 key1 new-val t))))
				    (add-subnode idx (subtree-with subnode1 key2 val2))))
			      (add-entry idx key2 val2))))
			 ((and (logbitp idx subnodes1) (logbitp idx subnodes2))
			  (add-subnode idx (rec (ch-map-node-subnode tree1 (postincf isubnode1))
						(ch-map-node-subnode tree2 (postincf isubnode2))
						(1+ depth))))
			 ((logbitp idx subnodes1)
			  (add-subnode idx (ch-map-node-subnode tree1 (postincf isubnode1))))
			 ((logbitp idx subnodes2)
			  (add-subnode idx (ch-map-node-subnode tree2 (postincf isubnode2))))
			 (t (error "Bug in 'ch-map-tree-union'")))))
	       ;; When two entries meet and become a subnode, we no longer need the value slot.
	       (ch-map-compact-node res-n)))))
    (compute-new-val (val1 val2)
      (if (equal?-cmp val1 val2 val-cmp-fn)
	  val1
	(funcall val-fn val1 val2)))))

(defun ch-map-tree-intersection (tree1 tree2 val-fn key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function val-fn key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn))
  (rlabels (rec tree1 tree2 0)
    (rec (tree1 tree2 depth)
      (declare (type (integer 0 64) depth)
	       (type function val-fn))
      (cond ((or (null tree1) (null tree2)) nil)
	    ((eq tree1 tree2) tree1)
	    ((consp tree1)
	     (if (consp tree2)
		 (and (= (the fixnum (caar tree1)) (the fixnum (caar tree2)))
		      (let ((result (wb-map-tree-intersect (cdr tree1) (cdr tree2) val-fn key-cmp-fn val-cmp-fn)))
			(ch-map-node-from-wb result (caar tree1) depth)))
	       (let ((result nil))
		 (do-wb-map-tree-pairs (k1 v1 (cdr tree1))
		   (let ((v2? v2 (ch-map-tree-lookup tree2 k1 key-hash-fn key-cmp-fn depth)))
		     (when v2?
		       (let ((new-v second-val (compute-new-val v1 v2)))
			 (unless (eq second-val ':no-value)
			   (setq result (ch-map-tree-with result k1 new-v key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn
							  nil depth)))))))
		 result)))
	    ((consp tree2)
	     (let ((hash-bits (champ-hash-bits (the fixnum (caar tree2)) depth))
		   (entry-mask (ch-map-node-entry-mask tree1))
		   (subnode-mask (ch-map-node-subnode-mask tree1)))
	       (cond ((logbitp hash-bits entry-mask)
		      (let ((ientry (1-bits-below hash-bits entry-mask))
			    ((k1 v1 (ch-map-node-entry tree1 ientry))
			     ((v2? v2 (wb-map-tree-lookup (cdr tree2) k1 key-cmp-fn)))))
			(and v2?
			     (let ((new-v second-val (compute-new-val v1 v2)))
			       (and (not (eq second-val ':no-value))
				    (ch-map-tree-with nil k1 new-v key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn
						      nil depth))))))
		     ((logbitp hash-bits subnode-mask)
		      (let ((isubnode (1-bits-below hash-bits subnode-mask))
			    ((old-subnode (ch-map-node-subnode tree1 isubnode)))
			    (result nil))
			(do-wb-map-tree-pairs (k2 v2 (cdr tree2))
			  (let ((v1? v1 k1 (ch-map-tree-lookup old-subnode k2 key-hash-fn key-cmp-fn (1+ depth))))
			    (when v1?
			      (let ((new-v second-val (compute-new-val v1 v2)))
				(unless (eq second-val ':no-value)
				  (setq result (ch-map-tree-with result k1 new-v key-hash-fn key-cmp-fn
								 val-hash-fn val-cmp-fn nil depth)))))))
			result))
		     (t nil))))
	    (t
	     (let ((entries1 (ch-map-node-entry-mask tree1))
		   (entries2 (ch-map-node-entry-mask tree2))
		   (subnodes1 (ch-map-node-subnode-mask tree1))
		   (subnodes2 (ch-map-node-subnode-mask tree2))
		   ((combined-mask (logand (logior entries1 subnodes1) (logior entries2 subnodes2)))
		    ;; The result can be longer than either input, because the intersection of two subnodes
		    ;; could be an entry.
		    ((res-len (+ ch-map-node-header-size (* 2 (logcount combined-mask))))
		     ((res-n (make-array res-len :initial-element 0))))))
	       (setf (ch-map-node-value-hash res-n) nil)
	       (flet ((add-entry (idx key val)
			(ch-map-node-add-entry! res-n idx key val key-hash-fn))
		      (add-subnode (idx subnode)
			(ch-map-node-add-subnode! res-n idx subnode key-hash-fn))
		      (subtree-lookup (tree key)
			(ch-map-tree-lookup tree key key-hash-fn key-cmp-fn (1+ depth))))
		 (do-bit-indices (idx combined-mask)
		   (cond ((and (logbitp idx entries1) (logbitp idx entries2))
			  (let ((key1 val1 (ch-map-node-entry tree1 (1-bits-below idx entries1)))
				(key2 val2 (ch-map-node-entry tree2 (1-bits-below idx entries2))))
			    (when (equal?-cmp key1 key2 key-cmp-fn)
			      (let ((new-val second-val (compute-new-val val1 val2)))
				(unless (eq second-val ':no-value)
				  (add-entry idx key1 new-val))))))
			 ((and (logbitp idx entries1) (logbitp idx subnodes2))
			  (let ((key1 val1 (ch-map-node-entry tree1 (1-bits-below idx entries1)))
				(subnode2 (ch-map-node-subnode tree2 (1-bits-below idx subnodes2)))
				((val2? val2 (subtree-lookup subnode2 key1))))
			    (when val2?
			      (let ((new-val second-val (compute-new-val val1 val2)))
				(unless (eq second-val ':no-value)
				  (add-entry idx key1 new-val))))))
			 ((and (logbitp idx subnodes1) (logbitp idx entries2))
			  (let ((key2 val2 (ch-map-node-entry tree2 (1-bits-below idx entries2)))
				(subnode1 (ch-map-node-subnode tree1 (1-bits-below idx subnodes1)))
				((val1? val1 key1 (subtree-lookup subnode1 key2))))
			    (when val1?
			      (let ((new-val second-val (compute-new-val val1 val2)))
				(unless (eq second-val ':no-value)
				  (add-entry idx key1 new-val))))))
			 ((and (logbitp idx subnodes1) (logbitp idx subnodes2))
			  (add-subnode idx (rec (ch-map-node-subnode tree1 (1-bits-below idx subnodes1))
						(ch-map-node-subnode tree2 (1-bits-below idx subnodes2))
						(1+ depth))))))
		 (ch-map-compact-node res-n))))))
    (compute-new-val (val1 val2)
      (if (equal?-cmp val1 val2 val-cmp-fn)
	  (values val1 nil)
	(n-values 2 (funcall val-fn val1 val2))))))

(defun ch-map-tree-diff-2 (tree1 tree2 key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn))
  (rlabels (rec tree1 tree2 0)
    (rec (tree1 tree2 depth)
      (declare (type (integer 0 64) depth))
      (cond ((null tree1) (values nil tree2))
	    ((null tree2) (values tree1 nil))
	    ((eq tree1 tree2) (values nil nil))
	    ((consp tree1)
	     (if (consp tree2)
		 (if (= (the fixnum (caar tree1)) (the fixnum (caar tree2)))
		     (let ((result1 result2 (wb-map-tree-diff-2 (cdr tree1) (cdr tree2) key-cmp-fn val-cmp-fn)))
		       (values (ch-map-node-from-wb result1 (caar tree1) depth)
			       (ch-map-node-from-wb result2 (caar tree2) depth)))
		   (values tree1 tree2))
	       (let ((result1 nil)
		     (result2 nil))
		 (do-wb-map-tree-pairs (k v1 (cdr tree1))
		   (let ((v2? v2 (ch-map-tree-lookup tree2 k key-hash-fn key-cmp-fn depth)))
		     (unless (and v2? (equal?-cmp v1 v2 val-cmp-fn))
		       (setq result1 (wb-map-tree-with result1 k v1 key-cmp-fn val-cmp-fn)))))
		 (do-ch-map-tree-pairs (k v2 tree2)
		   (let ((v1? v1 (wb-map-tree-lookup (cdr tree1) k key-cmp-fn)))
		     (unless (and v1? (equal?-cmp v1 v2 val-cmp-fn))
		       (setq result2 (ch-map-tree-with result2 k v2 key-hash-fn key-cmp-fn val-hash-fn val-cmp-fn
						       nil depth)))))
		 (values (ch-map-node-from-wb result1 (caar tree1) depth)
			 result2))))
	    ((consp tree2)
	     (let ((res2 res1 (rec tree2 tree1 depth)))
	       (values res1 res2)))
	    (t
	     (let ((entries1 (ch-map-node-entry-mask tree1))
		   (entries2 (ch-map-node-entry-mask tree2))
		   (subnodes1 (ch-map-node-subnode-mask tree1))
		   (subnodes2 (ch-map-node-subnode-mask tree2))
		   ((res-len1 (+ ch-map-node-header-size (* 2 (logcount (logior entries1 subnodes1)))))
		    ((res-n1 (make-array res-len1 :initial-element 0))))
		   ((res-len2 (+ ch-map-node-header-size (* 2 (logcount (logior entries2 subnodes2)))))
		    ((res-n2 (make-array res-len2 :initial-element 0))))
		   (ientry1 0)
		   (isubnode1 0)
		   (ientry2 0)
		   (isubnode2 0))
	       (declare (fixnum ientry1 isubnode1 ientry2 isubnode2))
	       (setf (ch-map-node-value-hash res-n1) nil)
	       (setf (ch-map-node-value-hash res-n2) nil)
	       (flet ((add-entry (n idx key val)
			(ch-map-node-add-entry! n idx key val key-hash-fn))
		      (add-subnode (n idx subnode)
			(ch-map-node-add-subnode! n idx subnode key-hash-fn))
		      (subtree-less (subtree key)
			(ch-map-tree-less subtree key key-hash-fn key-cmp-fn val-hash-fn nil (1+ depth)))
		      (subtree-lookup (subtree key)
			(ch-map-tree-lookup subtree key key-hash-fn key-cmp-fn (1+ depth))))
		 (do-bit-indices (idx (logior entries1 subnodes1 entries2 subnodes2))
		   (cond ((logbitp idx entries1)
			  (let ((key1 val1 (ch-map-node-entry tree1 (postincf ientry1))))
			    (cond ((logbitp idx entries2)
				   (let ((key2 val2 (ch-map-node-entry tree2 (postincf ientry2))))
				     (unless (and (equal?-cmp key1 key2 key-cmp-fn) (equal?-cmp val1 val2 val-cmp-fn))
				       (add-entry res-n1 idx key1 val1)
				       (add-entry res-n2 idx key2 val2))))
				  ((logbitp idx subnodes2)
				   (let ((subnode2 (ch-map-node-subnode tree2 (postincf isubnode2)))
					 ((val2? val2 (subtree-lookup subnode2 key1))))
				     (if (and val2? (equal?-cmp val1 val2 val-cmp-fn))
					 (add-subnode res-n2 idx (subtree-less subnode2 key1))
				       (progn
					 (add-entry res-n1 idx key1 val1)
					 (add-subnode res-n2 idx subnode2)))))
				  (t (add-entry res-n1 idx key1 val1)))))
			 ((logbitp idx subnodes1)
			  (let ((subnode1 (ch-map-node-subnode tree1 (postincf isubnode1))))
			    (cond ((logbitp idx subnodes2)
				   (let ((subnode2 (ch-map-node-subnode tree2 (postincf isubnode2)))
					 ((new-sn1 new-sn2 (rec subnode1 subnode2 (1+ depth)))))
				     (add-subnode res-n1 idx new-sn1)
				     (add-subnode res-n2 idx new-sn2)))
				  ((logbitp idx entries2)
				   (let ((key2 val2 (ch-map-node-entry tree2 (postincf ientry2)))
					 ((val1? val1 (subtree-lookup subnode1 key2))))
				     (if (and val1? (equal?-cmp val1 val2 val-cmp-fn))
					 (add-subnode res-n1 idx (subtree-less subnode1 key2))
				       (progn
					 (add-subnode res-n1 idx subnode1)
					 (add-entry res-n2 idx key2 val2)))))
				  (t (add-subnode res-n1 idx subnode1)))))
			 ((logbitp idx entries2)
			  (let ((key val (ch-map-node-entry tree2 (postincf ientry2))))
			    (add-entry res-n2 idx key val)))
			 ((logbitp idx subnodes2)
			  (add-subnode res-n2 idx (ch-map-node-subnode tree2 (postincf isubnode2))))
			 (t (error "Bug in ch-map-tree-diff")))))
	       (values (ch-map-compact-node res-n1) (ch-map-compact-node res-n2))))))))

(defun ch-map-tree-restrict (map-tree set-tree key-hash-fn key-cmp-fn val-hash-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function key-hash-fn key-cmp-fn val-hash-fn))
  (rlabels (rec map-tree set-tree 0)
    (rec (map-tree set-tree depth)
      (declare (type (integer 0 64) depth))
      (cond ((or (null map-tree) (null set-tree)) nil)
	    ((and (consp map-tree) (consp set-tree))
	     (and (= (the fixnum (caar map-tree)) (the fixnum (car set-tree)))
		  (let ((result (wb-map-tree-restrict (cdr map-tree) (cdr set-tree) key-cmp-fn)))
		    (ch-map-node-from-wb result (car set-tree) depth))))
	    ;; I figure the collision nodes are probably the smaller of the two.
	    ((consp map-tree)
	     (let ((result nil))
	       (do-wb-map-tree-pairs (k v (cdr map-tree))
		 (when (ch-set-tree-contains? set-tree k key-hash-fn key-cmp-fn depth)
		   (setq result (ch-map-tree-with result k v key-hash-fn key-cmp-fn val-hash-fn (fn (_ _))
						  nil depth))))
	       result))
	    ((consp set-tree)
	     (let ((result nil))
	       (do-wb-set-tree-members (k (cdr set-tree))
		 (let ((v? v (ch-map-tree-lookup map-tree k key-hash-fn key-cmp-fn depth)))
		   (when v?
		     (setq result (ch-map-tree-with result k v key-hash-fn key-cmp-fn val-hash-fn (fn (_ _))
						    nil depth)))))
	       result))
	    (t
	     (let ((entries1 (ch-map-node-entry-mask map-tree))
		   (entries2 (ch-set-node-entry-mask set-tree))
		   (subnodes1 (ch-map-node-subnode-mask map-tree))
		   (subnodes2 (ch-set-node-subnode-mask set-tree))
		   ((combined-mask (logand (logior entries1 subnodes1) (logior entries2 subnodes2)))
		    ;; The result can be longer than either input, because the restriction of two subnodes
		    ;; could be an entry.
		    ((res-len (+ ch-map-node-header-size (* 2 (logcount combined-mask))))
		     ((res-n (make-array res-len :initial-element 0))))))
	       (setf (ch-map-node-value-hash res-n) nil)
	       (flet ((add-entry (idx key val)
			(ch-map-node-add-entry! res-n idx key val key-hash-fn))
		      (add-subnode (idx subnode)
			(ch-map-node-add-subnode! res-n idx subnode key-hash-fn))
		      (map-lookup (map-subtree key)
			(ch-map-tree-lookup map-subtree key key-hash-fn key-cmp-fn (1+ depth)))
		      (set-contains? (set-subtree key)
			(ch-set-tree-contains? set-subtree key key-hash-fn key-cmp-fn (1+ depth))))
		 (do-bit-indices (idx combined-mask)
		   (cond ((and (logbitp idx entries1) (logbitp idx entries2))
			  (let ((key1 val1 (ch-map-node-entry map-tree (1-bits-below idx entries1)))
				(key2 (ch-set-node-entry set-tree (1-bits-below idx entries2))))
			    (when (equal?-cmp key1 key2 key-cmp-fn)
			      (add-entry idx key1 val1))))
			 ((and (logbitp idx entries1) (logbitp idx subnodes2))
			  (let ((key1 val1 (ch-map-node-entry map-tree (1-bits-below idx entries1)))
				(subnode2 (ch-set-node-subnode set-tree (1-bits-below idx subnodes2))))
			    (when (set-contains? subnode2 key1)
			      (add-entry idx key1 val1))))
			 ((and (logbitp idx subnodes1) (logbitp idx entries2))
			  (let ((subnode1 (ch-map-node-subnode map-tree (1-bits-below idx subnodes1)))
				(key2 (ch-set-node-entry set-tree (1-bits-below idx entries2)))
				((val1? val1 (map-lookup subnode1 key2))))
			    (when val1?
			      (add-entry idx key2 val1))))
			 ((and (logbitp idx subnodes1) (logbitp idx subnodes2))
			  (add-subnode idx (rec (ch-map-node-subnode map-tree (1-bits-below idx subnodes1))
						(ch-map-node-subnode set-tree (1-bits-below idx subnodes2))
						(1+ depth))))))
		 (ch-map-compact-node res-n))))))))

(defun ch-map-tree-restrict-not (map-tree set-tree key-hash-fn key-cmp-fn val-hash-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function key-hash-fn key-cmp-fn val-hash-fn))
  (rlabels (rec map-tree set-tree 0)
    (rec (map-tree set-tree depth)
      (declare (type (integer 0 64) depth))
      (cond ((or (null map-tree) (null set-tree)) nil)
	    ((and (consp map-tree) (consp set-tree))
	     (if (= (the fixnum (caar map-tree)) (the fixnum (car set-tree)))
		 (let ((result (wb-map-tree-restrict-not (cdr map-tree) (cdr set-tree) key-cmp-fn)))
		   (ch-map-node-from-wb result (car set-tree) depth))
	       map-tree))
	    ((consp map-tree)
	     (let ((result nil))
	       (do-wb-map-tree-pairs (k v (cdr map-tree))
		 (unless (ch-set-tree-contains? set-tree k key-hash-fn key-cmp-fn depth)
		   (setq result (wb-map-tree-with result k v key-cmp-fn (fn (_ _))))))
	       (ch-map-node-from-wb result (caar map-tree) depth)))
	    ((consp set-tree)
	     (do-wb-set-tree-members (k (cdr set-tree))
	       (setq map-tree (ch-map-tree-less map-tree k key-hash-fn key-cmp-fn val-hash-fn nil depth)))
	     map-tree)
	    (t
	     (let ((entries1 (ch-map-node-entry-mask map-tree))
		   (entries2 (ch-set-node-entry-mask set-tree))
		   (subnodes1 (ch-map-node-subnode-mask map-tree))
		   (subnodes2 (ch-set-node-subnode-mask set-tree))
		   ;; The result can be longer than `map-tree', because the restriction of two subnodes
		   ;; could be an entry.
		   ((res-len (+ ch-map-node-header-size
				(* 2 (+ (logcount entries1) (logcount subnodes1)))))
		    ((res-n (make-array res-len :initial-element 0)))))
	       (setf (ch-map-node-value-hash res-n) nil)
	       (flet ((add-entry (idx key val)
			(ch-map-node-add-entry! res-n idx key val key-hash-fn))
		      (add-subnode (idx subnode)
			(ch-map-node-add-subnode! res-n idx subnode key-hash-fn))
		      (map-subtree-less (subtree key)
			(ch-map-tree-less subtree key key-hash-fn key-cmp-fn val-hash-fn nil (1+ depth)))
		      (set-contains? (set-subtree key)
			(ch-set-tree-contains? set-subtree key key-hash-fn key-cmp-fn (1+ depth))))
		 (do-bit-indices (idx (logior entries1 subnodes1))
		   (cond ((logbitp idx entries1)
			  (let ((key1 val1 (ch-map-node-entry map-tree (1-bits-below idx entries1))))
			    (cond ((logbitp idx entries2)
				   (let ((key2 (ch-set-node-entry set-tree (1-bits-below idx entries2))))
				     (unless (equal?-cmp key1 key2 key-cmp-fn)
				       (add-entry idx key1 val1))))
				  ((logbitp idx subnodes2)
				   (let ((subnode2 (ch-set-node-subnode set-tree (1-bits-below idx subnodes2))))
				     (unless (set-contains? subnode2 key1)
				       (add-entry idx key1 val1))))
				  (t (add-entry idx key1 val1)))))
			 ((logbitp idx subnodes1)
			  (let ((subnode1 (ch-map-node-subnode map-tree (1-bits-below idx subnodes1))))
			    (cond ((logbitp idx entries2)
				   (let ((key2 (ch-set-node-entry set-tree (1-bits-below idx entries2))))
				     (add-subnode idx (map-subtree-less subnode1 key2))))
				  ((logbitp idx subnodes2)
				   (let ((subnode2 (ch-set-node-subnode set-tree (1-bits-below idx subnodes2))))
				     (add-subnode idx (rec subnode1 subnode2 (1+ depth)))))
				  (t (add-subnode idx subnode1)))))))
		 (ch-map-compact-node res-n))))))))

(defun ch-map-node-from-wb (wb-map-tree key-hash depth)
  (declare (optimize (speed 3) (safety 0)))
  (case (wb-map-tree-size wb-map-tree)
    (0 nil)
    (1 (let ((k v (wb-map-tree-arb-pair wb-map-tree)))
	 (vector (ash 1 (champ-hash-bits key-hash depth))
		 0 1 key-hash nil k v)))
    (t (cons (cons key-hash nil) wb-map-tree))))

(defun ch-map-node-replace-subnode (node hash-bits new-subnode key-hash-fn val-hash-fn)
  "Returns a new node with `new-subnode' replacing the subnode at `isubnode'."
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector node)
	   (type champ-bit-index hash-bits)
	   (type function key-hash-fn val-hash-fn))
  (let ((isubnode (1-bits-below hash-bits (ch-map-node-subnode-mask node)))
	((old-subnode (ch-map-node-subnode node isubnode))))
    ;; Even when unioning, the `:no-value' feature can generate empty subnodes...
    (cond ((null new-subnode)
	   (let ((n (vector-remove-n-at node (- (length node) isubnode 1) 1)))
	     (logandc2f (ch-map-node-subnode-mask n) (ash 1 hash-bits))
	     (decf (ch-map-node-size n) (ch-map-tree-size old-subnode))
	     (hash-unmixf (ch-map-node-key-hash n) (ch-map-tree-key-hash old-subnode))
	     (when (ch-map-node-value-hash n)
	       (hash-unmixf (ch-map-node-value-hash n) (ch-map-tree-value-hash old-subnode val-hash-fn)))
	     n))
	  ;; ... or single-entry ones.
	  ((and (not (consp new-subnode))
		(= 1 (logcount (ch-map-node-entry-mask new-subnode)))
		(= 0 (ch-map-node-subnode-mask new-subnode)))
	   (let ((ientry (1-bits-below hash-bits (ch-map-node-entry-mask node)))
		 (key val (ch-map-node-entry new-subnode 0))
		 ((n (ch-map-node-ins-2-rem-1 nil node (+ ch-map-node-header-size (* 2 ientry)) key val
					      (- (length node) isubnode 1)))))
	     (logiorf (ch-map-node-entry-mask n) (ash 1 hash-bits))
	     (logandc2f (ch-map-node-subnode-mask n) (ash 1 hash-bits))
	     (incf (ch-map-node-size n) (- 1 (ch-map-tree-size old-subnode)))
	     (hash-mixf (ch-map-node-key-hash n)
			(hash-unmix (hash-to-fixnum key key-hash-fn)
				    (ch-map-tree-key-hash old-subnode)))
	     (when (ch-map-node-value-hash n)
	       (hash-mixf (ch-map-node-value-hash n)
			  (hash-unmix (hash-to-fixnum val val-hash-fn)
				      (ch-map-tree-value-hash old-subnode val-hash-fn))))
	     n))
	  (t
	   (let ((n (vector-update node (- (length node) isubnode 1) new-subnode)))
	     (declare (type simple-vector n))
	     (setf (svref n (- (length n) isubnode 1)) new-subnode)
	     (incf (ch-map-node-size n) (- (ch-map-tree-size new-subnode) (ch-map-tree-size old-subnode)))
	     (hash-mixf (ch-map-node-key-hash n)
			(hash-unmix (ch-map-tree-key-hash new-subnode)
				    (ch-map-tree-key-hash old-subnode)))
	     (when (ch-map-node-value-hash n)
	       (hash-mixf (ch-map-node-value-hash n)
			  (hash-unmix (ch-map-tree-value-hash new-subnode val-hash-fn)
				      (ch-map-tree-value-hash old-subnode val-hash-fn))))
	     n)))))

(defun ch-map-node-insert-subnode (node hash-bits new-subnode val-hash-fn)
  "Returns a new node with `new-subnode' inserted just before `isubnode'."
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector node)
	   (type champ-bit-index hash-bits))
  (let ((isubnode (1-bits-below hash-bits (ch-map-node-subnode-mask node)))
	((n (vector-insert node (- (length node) isubnode) new-subnode))))
    (logiorf (ch-map-node-subnode-mask n) (ash 1 hash-bits))
    (incf (ch-map-node-size n) (ch-map-tree-size new-subnode))
    (hash-mixf (ch-map-node-key-hash n) (ch-map-tree-key-hash new-subnode))
    (when (ch-map-node-value-hash n)
      (hash-mixf (ch-map-node-value-hash n)
		 (ch-map-tree-value-hash new-subnode val-hash-fn)))
    n))

(defun ch-map-node-change-entry-to-subnode (node hash-bits new-subnode key-hash-fn val-hash-fn)
  "Returns a new node with entry `ientry' removed, and `new-subnode' inserted just
before `isubnode'."
  (declare (optimize (speed 3) (safety 0))
	   (type simple-vector node)
	   (type champ-bit-index hash-bits)
	   (type function key-hash-fn val-hash-fn))
  (let ((ientry (1-bits-below hash-bits (ch-map-node-entry-mask node)))
	(isubnode (1-bits-below hash-bits (ch-map-node-subnode-mask node)))
	((old-key old-val (ch-map-node-entry node ientry))))
    ;; Even when unioning, the `:no-value' feature can generate single-entry subnodes.
    (if (and (not (consp new-subnode))
	     (= 1 (logcount (ch-map-node-entry-mask new-subnode)))
	     (= 0 (ch-map-node-subnode-mask new-subnode)))
	(let ((key val (ch-map-node-entry new-subnode 0))
	      ((n (ch-map-node-update-2 nil node (+ ch-map-node-header-size (* 2 ientry)) key val))))
	  (hash-mixf (ch-map-node-key-hash n)
		     (hash-unmix (hash-to-fixnum key key-hash-fn)
				 (hash-to-fixnum old-key key-hash-fn)))
	  (when (ch-map-node-value-hash n)
	    (hash-mixf (ch-map-node-value-hash n)
		       (hash-unmix (hash-to-fixnum val val-hash-fn)
				   (hash-to-fixnum old-val val-hash-fn))))
	  n)
      (let ((n (ch-map-node-rem-2-ins-1 nil node (+ ch-map-node-header-size (* 2 ientry))
					(- (length node) isubnode 1) new-subnode)))
	(logandc2f (ch-map-node-entry-mask n) (ash 1 hash-bits))
	(logiorf (ch-map-node-subnode-mask n) (ash 1 hash-bits))
	(incf (ch-map-node-size n) (1- (ch-map-tree-size new-subnode)))
	(hash-mixf (ch-map-node-key-hash n)
		   (hash-unmix (ch-map-tree-key-hash new-subnode)
			       (hash-to-fixnum old-key key-hash-fn)))
	(when (ch-map-node-value-hash n)
	  (hash-mixf (ch-map-node-value-hash n)
		     (hash-unmix (ch-map-tree-value-hash new-subnode val-hash-fn)
				 (hash-to-fixnum old-val val-hash-fn))))
	n))))

(defun ch-map-compact-node (n)
  (declare (optimize (speed 3) (safety 0)))
  (let ((entries (ch-map-node-entry-mask n))
	(subnodes (ch-map-node-subnode-mask n)))
    (and (or (/= entries 0) (/= subnodes 0))
	 (let ((len (length (the simple-vector n)))
	       (n-entries (logcount entries))
	       ((extra (- len ch-map-node-header-size (* 2 n-entries) (logcount subnodes)))))
	   (when (< extra 0)
	     (error "Bug!  Not enough space allocated for ch-map-node"))
	   (if (= extra 0) n
	     (vector-remove-n-at n (+ ch-map-node-header-size (* 2 n-entries)) extra))))))

(defun ch-map-compact-tree (tree &key compact-value-fn)
  (declare (optimize (speed 3) (safety 0))
	   (type (or null function) compact-value-fn))
  (cond ((null tree) nil)
	((consp tree) tree)
	(t
	 (let ((n-entries (logcount (ch-map-node-entry-mask tree)))
	       (n-subnodes (logcount (ch-map-node-subnode-mask tree)))
	       (len (length (the simple-vector tree)))
	       ((min-len (+ ch-map-node-header-size (* 2 n-entries) n-subnodes)))
	       (copied? nil))
	   (flet ((copy ()
		    (unless copied?
		      (let ((new (make-array min-len)))
			(dotimes (i (+ ch-map-node-header-size (* 2 n-entries)))
			  (setf (svref new i) (svref tree i)))
			(dotimes (i n-subnodes)
			  (setf (svref new (- min-len i 1)) (svref tree (- len i 1))))
			(setq tree new)
			(setq len min-len)
			(setq copied? t)))))
	     (when (< len min-len)
	       (error "Bug!  Not enough space allocated for ch-map-node"))
	     (when (> len min-len)
	       (copy))
	     (dotimes (i n-subnodes)
	       (let ((subnode (svref tree (- len i 1)))
		     ((new-subnode (ch-map-compact-tree subnode))))
		 (unless (eq new-subnode subnode)
		   (copy)
		   (setf (svref tree (- len i 1)) new-subnode))))
	     (when compact-value-fn
	       (dotimes (i n-entries)
		 (let ((idx (+ ch-map-node-header-size (* 2 i) 1))
		       ((value (svref tree idx))
			((new-value (funcall compact-value-fn value)))))
		   (unless (eq new-value value)
		     (copy)
		     (setf (svref tree idx) new-value)))))
	     tree)))))

(defun ch-map-tree-compose (tree fn)
  (declare (optimize (speed 3) (safety 0))
	   (type function fn))
  (cond ((null tree) nil)
	((consp tree)
	 (wb-map-tree-compose tree fn))
	(t
	 (let ((n (make-array (length (the simple-vector tree)) :initial-element 0)))
	   (dotimes (i (logcount (ch-map-node-entry-mask tree)))
	     (let ((entry-idx (+ ch-map-node-header-size (* 2 i))))
	       (setf (svref n entry-idx) (svref tree entry-idx))
	       (setf (svref n (1+ entry-idx)) (funcall fn (svref tree (1+ entry-idx))))))
	   (dotimes (i (logcount (ch-map-node-subnode-mask tree)))
	     (let ((subnode-idx (- (length (the simple-vector tree)) i 1)))
	       (setf (svref n subnode-idx)
		     (ch-map-tree-compose (svref tree subnode-idx) fn))))
	   (setf (ch-map-node-entry-mask n) (ch-map-node-entry-mask tree))
	   (setf (ch-map-node-subnode-mask n) (ch-map-node-subnode-mask tree))
	   (setf (ch-map-node-size n) (ch-map-node-size tree))
	   (setf (ch-map-node-key-hash n) (ch-map-node-key-hash tree))
	   (setf (ch-map-node-value-hash n) nil)
	   n))))

(defun ch-map-tree-verify (tree key-hash-fn val-hash-fn)
  (declare (optimize (debug 3)))
  (or (null tree)
      (rlabels (rec tree 0 0)
	(rec (node depth partial-hash)
	  (macrolet ((test (form)
		       `(or ,form
			    (progn
			      (cerror "Ignore and proceed."
				      "Verification check failed at ~:A: ~S" (path depth partial-hash) ',form)
			      t))))
	    (let ((entry-mask (ch-map-node-entry-mask node))
		  (subnode-mask (ch-map-node-subnode-mask node)))
	      (and (test (= 0 (logand entry-mask subnode-mask)))
		   (test (= 0 (ash entry-mask (- champ-node-radix))))
		   (test (= 0 (ash subnode-mask (- champ-node-radix))))
		   (test (>= (length node)
			     (+ ch-map-node-header-size (* 2 (logcount entry-mask)) (logcount subnode-mask))))
		   ;; Check that unless root, this node does not contain only an entry ...
		   (test (not (and (> depth 0) (= 1 (logcount entry-mask)) (= 0 subnode-mask))))
		   ;; ... or only a collision subnode
		   (test (not (and (> depth 0) (= 0 entry-mask) (= 1 (logcount subnode-mask))
				   (consp (svref node (1- (length node)))))))
		   (let ((size (logcount entry-mask))
			 (node-key-hash 0)
			 (node-value-hash 0))
		     (and
		       ;; Check entry key hashes
		       (gmap :and (fn (key-idx hash-bits)
				    (let ((key (svref node (+ ch-map-node-header-size (* 2 key-idx))))
					  ((key-hash (hash-to-fixnum key key-hash-fn)))
					  (value (svref node (+ ch-map-node-header-size (1+ (* 2 key-idx))))))
				      (hash-mixf node-key-hash key-hash)
				      (when (ch-map-node-value-hash node)
					(hash-mixf node-value-hash (hash-to-fixnum value val-hash-fn)))
				      (test (= (ldb (byte (* champ-hash-bits-per-level (1+ depth)) 0)
						    key-hash)
					       (new-partial-hash hash-bits depth partial-hash)))))
			     (:arg index 0)
			     (:arg list (bit-indices entry-mask)))
		       ;; Verify subnodes
		       (gmap :and (fn (subnode-idx hash-bits)
				    (let ((subnode (svref node (- (length node) 1 subnode-idx))))
				      (if (consp subnode)
					  (let ((key-hash (hash-to-fixnum (wb-map-tree-arb-pair (cdr subnode))
									  key-hash-fn))
						(vhash 0))
					    (test (consp (car subnode)))
					    (test (> (wb-map-tree-size (cdr subnode)) 1))
					    (do-wb-map-tree-pairs (k v (cdr subnode))
					      (let ((kh (hash-to-fixnum k key-hash-fn)))
						(test (= kh key-hash))
						(when (cdar subnode)
						  (hash-mixf vhash (hash-to-fixnum v val-hash-fn)))))
					    (hash-mixf node-key-hash key-hash)
					    (incf size (wb-map-tree-size (cdr subnode)))
					    (when (cdar subnode)
					      (test (= (cdar subnode) vhash))
					      (hash-mixf node-value-hash vhash))
					    (test (= (caar subnode) key-hash)))
					(and (rec subnode (1+ depth) (new-partial-hash hash-bits depth partial-hash))
					     (progn
					       (incf size (ch-map-node-size subnode))
					       (hash-mixf node-key-hash (ch-map-node-key-hash subnode))
					       (when (ch-map-node-value-hash node)
						 (hash-mixf node-value-hash (ch-map-node-value-hash subnode)))
					       t)))))
			     (:arg index 0)
			     (:arg list (bit-indices subnode-mask)))
		       ;; Finally, check size and hashes
		       (test (= (ch-map-node-size node) size))
		       (test (= (ch-map-node-key-hash node) node-key-hash))
		       (or (null (ch-map-node-value-hash node))
			   (test (= (ch-map-node-value-hash node) node-value-hash)))))))))
	(new-partial-hash (hash-bits depth partial-hash)
	  (dpb hash-bits (byte champ-hash-bits-per-level (* champ-hash-bits-per-level depth))
	       partial-hash))
	(path (depth partial-hash)
	  (let ((path nil))
	    (dotimes (i depth)
	      (push (ldb (byte champ-hash-bits-per-level (* i champ-hash-bits-per-level))
			 partial-hash)
		    path))
	    (nreverse path))))))

    
