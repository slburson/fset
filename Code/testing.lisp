;;; -*- Mode: Lisp; Package: FSet; Syntax: ANSI-Common-Lisp -*-

;;; File: testing.lisp
;;; Contents: FSet test suite.
;;;
;;; This file is part of FSet.  Copyright (c) 2007-2025 Scott L. Burson.
;;; FSet is licensed under the 2-clause BSD license; see LICENSE.
;;; This license provides NO WARRANTY.

(in-package :fset)


(defstruct (My-Integer
	    (:constructor Make-My-Integer (Value)))
  Value)

(def-tuple-key +K0+)
(def-tuple-key +K1+ (fn (tup) (@ tup +K0+)))
(def-tuple-key +K2+)
(def-tuple-key +K3+)
(def-tuple-key +K4+)


(defclass My-Unhandled-Obj ()
  ((value :initarg :value :initform nil
	  :accessor My-Unhandled-Obj-Value))
  (:documentation "Object on which we have defined no FSet methods."))

(defclass My-Identity-Ordered-Obj (identity-ordering-mixin)
  ((value :initarg :value :initform nil
	  :accessor My-Identity-Ordered-Obj-Value))
  (:documentation "Object that has identity ordering"))

#+sbcl
(progn
  (defclass my-sequence (standard-object sequence)
    ((actual :type list :initarg :actual :initform nil
	     :accessor my-sequence-actual))
    (:documentation "An example of an SBCL user-defined sequence class"))
  (defmethod sb-sequence:length ((obj my-sequence))
    (cl:length (my-sequence-actual obj)))
  (defmethod sb-sequence:elt ((obj my-sequence) index)
    (elt (my-sequence-actual obj) index))
  (defmethod (setf sb-sequence:elt) (val (obj my-sequence) index)
    (setf (elt (my-sequence-actual obj) index) val))
  (defmethod sb-sequence:adjust-sequence ((obj my-sequence) len &rest args)
    (setf (my-sequence-actual obj)
	  (apply #'sb-sequence:adjust-sequence (my-sequence-actual obj) len args))
    obj)
  (defmethod sb-sequence:make-sequence-like ((obj my-sequence) len &rest args)
    (let ((new-contents
	   (apply #'sb-sequence:make-sequence-like (my-sequence-actual obj) len args)))
      (make-instance 'my-sequence :actual new-contents))))

(defun erapmoc (a b)
  (compare b a))

(defun hash-value-negated (x)
  (- (hash-value x)))

(define-hash-function erapmoc hash-value-negated)

(defun int-compare (a b)
  (declare (fixnum a b))
  (cond ((< a b) ':less)
	((> a b) ':greater)
	(t ':equal)))

(define-hash-function int-compare hash-value)

;;; utility functions used in tests

(defun add-to-front (list &rest vals)
  (nconc (copy-list vals) list))

(defun run-test-suite (n-iterations &optional random-seed)
  ;; `Test-Misc' was huge and wouldn't compile in ABCL (JVM function size limitations),
  ;; so I broke it up.
  (format t "Testing FSet...")
  (Test-GMap)
  (Test-Misc-0)
  (Test-Misc-1)
  (Test-Misc-2)
  (Test-Misc-3)
  (Test-Misc-4)
  (Test-Reader)
  (Test-Rereader)
  (Test-Compare-Lexicographically)
  (Test-Modify-Macros)
  (Test-Functional-Deep-Update)
  (Test-Bounded-Sets)
  (Test-Complement-Sets)
  (Test-2-Relations)
  (Test-List-Relations)
  (Test-FSet2)
  (let ((*random-state* (make-random-state random-seed))) ; for repeatability.
    (dotimes (i n-iterations)
      (when (zerop (mod i 10))
	(format t "."))
      (Test-Map-Operations i (Test-Set-Operations i))
      (Test-Bag-Operations i)
      (Test-Seq-Operations i)
      (Test-Tuple-Operations i))
    (test-champ-sets n-iterations)
    (test-champ-maps n-iterations))
  (format t "passed~%"))


(defun Test-GMap ()
  (macrolet ((test (form)
	       `(unless ,form
		  (error "Test failed: ~S" ',form))))
    (test (equal? (gmap (:result list) nil (:arg fun-sequence (list 3 'foo 42)))
		  '(3 foo 42)))
    (test (equal? (gmap (:result list) nil (:arg fun-sequence (list 3 'foo 42) :from-end? t))
		  '(42 foo 3)))
    (test (equal? (gmap (:result list) nil (:arg fun-sequence (vector 3 'foo 42)))
		  '(3 foo 42)))
    (test (equal? (gmap (:result list) nil (:arg fun-sequence (vector 3 'foo 42) :from-end? t))
		  '(42 foo 3)))
    (test (equal? (gmap (:result list) nil (:arg fun-sequence "3Q7"))
		  '(#\3 #\Q #\7)))
    (test (equal? (gmap (:result list) nil (:arg fun-sequence "3Q7" :from-end? t))
		  '(#\7 #\Q #\3)))

    (test (equal? (gmap (:result list) nil (:arg set (wb-set 13 7 41 2)))
		  '(2 7 13 41)))
    (test (equal? (sort (gmap (:result list) nil (:arg set (ch-set 13 7 41 2))) #'<)
		  '(2 7 13 41)))
    (test (equal? (gmap (:result list) nil (:arg wb-set (wb-set 13 7 41 2)))
		  '(2 7 13 41)))
    (test (equal? (sort (gmap (:result list) nil (:arg ch-set (ch-set 13 7 41 2))) #'<)
		  '(2 7 13 41)))
    (test (equal? (gmap (:result set) nil (:arg list '(8 3 14 6)))
		  (wb-set 8 3 14 6)))
    (test (equal? (gmap (:result wb-set :compare-fn-name 'erapmoc) nil (:arg list '(8 3 14 6)))
		  (wb-custom-set 'erapmoc 8 3 14 6)))
    (test (equal? (gmap (:result ch-set :compare-fn-name 'erapmoc) nil (:arg list '(8 3 14 6)))
		  (ch-custom-set 'erapmoc 8 3 14 6)))
    (test (equal? (gmap (:result union) nil (:arg list (list (set 3 7) (set 9 1))))
		  (wb-set 1 3 7 9)))
    (test (equal? (gmap (:result intersection) nil (:arg list (list (set 3 7 9) (set 9 3))))
		  (wb-set 3 9)))

    (test (equal? (gmap (:result list) nil (:arg bag (bag 3 7 (% 9 2))))
		  '(3 7 9 9)))
    (test (equal? (gmap (:result list) nil (:arg wb-bag (bag 3 7 (% 9 2))))
		  '(3 7 9 9)))
    (test (equal? (gmap (:result list) #'cons (:arg bag-pairs (bag 3 7 (% 9 2))))
		  '((3 . 1) (7 . 1) (9 . 2))))
    (test (equal? (gmap (:result list) #'cons (:arg wb-bag-pairs (bag 3 7 (% 9 2))))
		  '((3 . 1) (7 . 1) (9 . 2))))
    (test (equal? (gmap (:result list) #'cons (:arg fun-bag-pairs (bag 3 7 (% 9 2))))
		  '((3 . 1) (7 . 1) (9 . 2))))
    (test (equal? (gmap (:result bag) nil (:arg list '(3 7 9 2 7 3)))
		  (wb-bag 2 (% 3 2) (% 7 2) 9)))
    (test (equal? (gmap (:result bag-pairs) (fn (x) (values (car x) (cdr x)))
			(:arg list '((a . 2) (b . 6) (q . 4))))
		  (wb-bag (% 'a 2) (% 'b 6) (% 'q 4))))
    (test (equal? (gmap (:result wb-bag :compare-fn-name 'erapmoc) nil (:arg list '(3 7 9 2 7 3)))
		  (wb-custom-bag 'erapmoc 2 (% 3 2) (% 7 2) 9)))
    (test (equal? (gmap (:result wb-bag-pairs :compare-fn-name 'erapmoc) (fn (x) (values (car x) (cdr x)))
			(:arg list '((a . 2) (b . 6) (q . 4))))
		  (wb-custom-bag 'erapmoc (% 'a 2) (% 'b 6) (% 'q 4))))
    (test (equal? (gmap (:result bag-sum) nil (:arg list (list (bag 2 2 3 3 3 4) (bag 1 2 4))))
		  (bag 1 (% 2 3) (% 3 3) (% 4 2))))
    (test (equal? (gmap (:result bag-product) nil (:arg list (list (bag 2 2 3 3 3 4) (bag 1 2 2 4))))
		  (bag (% 2 4) 4)))

    (test (equal? (gmap (:result list) #'cons (:arg map (map ('a 3) ('b 7) ('c 6))))
		  '((a . 3) (b . 7) (c . 6))))
    (test (equal? (gmap (:result list) #'cons (:arg fun-map (map ('a 3) ('b 7) ('c 6))))
		  '((a . 3) (b . 7) (c . 6))))
    (test (equal? (gmap (:result list) #'cons (:arg wb-map (map ('a 3) ('b 7) ('c 6))))
		  '((a . 3) (b . 7) (c . 6))))
    (test (equal? (sort (gmap (:result list) #'cons (:arg ch-map (ch-map ('a 3) ('b 7) ('c 6))))
			#'string< :key #'car)
		  '((a . 3) (b . 7) (c . 6))))
    (test (equal? (gmap (:result map) #'values (:arg list '(foo bar baz)) (:arg list '(12 17 91)))
		  (wb-map ('foo 12) ('bar 17) ('baz 91))))
    (test (equal? (gmap (:result wb-map) #'values (:arg list '(foo bar baz)) (:arg list '(12 17 91)))
		  (wb-map ('foo 12) ('bar 17) ('baz 91))))
    (test (equal? (gmap (:result ch-map) #'values (:arg list '(foo bar baz)) (:arg list '(12 17 91)))
		  (ch-map ('foo 12) ('bar 17) ('baz 91))))
    (test (equal? (gmap (:result map-union) nil (:arg list (list (map ('a 7) ('b 4)) (map ('c 8) ('a 11)))))
		  (wb-map ('a 11) ('b 4) ('c 8))))
    (test (equal? (gmap (:result map-intersection) nil (:arg list (list (map ('a 7) ('b 4)) (map ('c 8) ('a 11)))))
		  (wb-map ('a 11))))
    (test (equal? (gmap (:result map-to-sets) #'values
			(:arg list '(a b a c a b))
			(:arg list '(0 1 2 3 4 5)))
		  (wb-map ('a (wb-set 0 2 4)) ('b (wb-set 1 5)) ('c (wb-set 3)) :default (wb-set))))

    (test (equal? (gmap (:result list) nil (:arg seq (seq 3 'foo 99)))
		  '(3 foo 99)))
    (test (equal? (gmap (:result list) nil (:arg seq (seq 3 'foo 99 42 "hello" 'fizzbuzz)
						 :start 1 :end 5))
		  '(foo 99 42 "hello")))
    (test (equal? (gmap (:result list) nil (:arg seq (seq 3 'foo 99) :from-end? t))
		  '(99 foo 3)))
    (test (equal? (gmap (:result list) nil (:arg seq (seq 3 'foo 99 42 "hello" 'fizzbuzz)
						 :start 1 :end 5 :from-end? t))
		  '("hello" 42 99 foo)))
    (test (equal? (gmap (:result list) nil (:arg wb-seq (seq 3 'foo 99)))
		  '(3 foo 99)))
    (test (equal? (gmap (:result list) nil (:arg wb-seq (seq 3 'foo 99 42 "hello" 'fizzbuzz)
						 :start 1 :end 5))
		  '(foo 99 42 "hello")))
    ;; Heh -- had to find something that wasn't `t' yet would still be guaranteed true.
    (test (equal? (gmap (:result list) nil (:arg wb-seq (seq 3 'foo 99) :from-end? (> (get-universal-time) 1000000)))
		  '(99 foo 3)))
    (test (equal? (gmap (:result list) nil (:arg wb-seq (seq 3 'foo 99 42 "hello" 'fizzbuzz)
						 :start 1 :end 5 :from-end? (> (get-universal-time) 1000000)))
		  '("hello" 42 99 foo)))
    (test (equal? (gmap (:result seq :filterp #'integerp) nil (:arg list '(3 'bar 99)))
		  (seq 3 99)))
    (test (equal? (gmap (:result concat) nil (:arg list (list (seq 'now 'is) (seq 'the 'time))))
		  (seq 'now 'is 'the 'time)))

    (test (equal? (gmap (:result list) #'cons (:arg tuple (tuple (+k0+ 47) (+k2+ 32) (+k3+ 17))))
		  `((,+k0+ . 47) (,+k2+ . 32) (,+k3+ . 17))))
    (test (equal? (gmap (:result tuple) #'values (:arg map (map (+k0+ 31) (+k1+ 91) (+k4+ 23))))
		  (tuple  (+k0+ 31) (+k1+ 91) (+k4+ 23))))

    (test (equal? (gmap (:result list) #'cons (:arg 2-relation (wb-2-relation (1 7) (4 13) (2 9) (1 4) (2 3))))
		  '((1 . 4) (1 . 7) (2 . 3) (2 . 9) (4 . 13))))
    (test (equal? (sort (gmap (:result list) #'cons (:arg 2-relation (ch-2-relation (1 7) (4 13) (2 9) (1 4) (2 3))))
			(fn (a b) (or (< (car a) (car b)) (and (= (car a) (car b)) (< (cdr a) (cdr b))))))
		  '((1 . 4) (1 . 7) (2 . 3) (2 . 9) (4 . 13))))
    (test (equal? (gmap (:result wb-2-relation) #'values (:arg list '(a b a c a b)) (:arg index 0))
		  (wb-2-relation ('a 0) ('a 2) ('a 4) ('b 1) ('b 5) ('c 3))))
    (test (equal? (gmap (:result ch-2-relation) #'values (:arg list '(a b a c a b)) (:arg index 0))
		  (ch-2-relation ('a 0) ('a 2) ('a 4) ('b 1) ('b 5) ('c 3))))
    (test (equal? (gmap (:result list) nil (:arg list-relation
						 ;; No constructor macro yet.
						 (let ((rel (empty-wb-list-relation)))
						   (includef rel '(suzy age 9))
						   (includef rel '(will age 7))
						   rel)))
		  '((suzy age 9) (will age 7))))
    (test (equal? (gmap (:result list) nil (:arg wb-list-relation
						 ;; No constructor macro yet.
						 (let ((rel (empty-wb-list-relation)))
						   (includef rel '(suzy age 9))
						   (includef rel '(will age 7))
						   rel)))
		  '((suzy age 9) (will age 7))))
    (test (equal? (sort (gmap (:result list) nil (:arg ch-list-relation
						       ;; No constructor macro yet.
						       (let ((rel (empty-ch-list-relation)))
							 (includef rel '(suzy age 9))
							 (includef rel '(will age 7))
							 rel)))
			#'string< :key #'car)
		  '((suzy age 9) (will age 7))))

    (test (equal? (gmap (:result list) nil (:arg replay-set (wb-replay-set 3 17 6 12 4)))
		  '(3 17 6 12 4)))
    (test (equal? (gmap (:result list) nil (:arg replay-set (ch-replay-set 3 17 6 12 4)))
		  '(3 17 6 12 4)))
    (test (equal? (gmap (:result replay-set) nil (:arg list (list 3 17 6 12 4)))
		  (ch-replay-set 3 17 6 12 4)))
    (test (equal? (gmap (:result wb-replay-set) nil (:arg list (list 3 17 6 12 4)))
		  (wb-replay-set 3 17 6 12 4)))
    (test (equal? (gmap (:result ch-replay-set) nil (:arg list (list 3 17 6 12 4)))
		  (ch-replay-set 3 17 6 12 4)))
    (test (equal? (gmap (:result append-unique) nil (:arg list (list (list 3 7 2) (list 7 4 1) (list 2 1 8))))
		  '(3 7 2 4 1 8)))

    (test (equal? (gmap (:result list) #'list (:arg replay-map (replay-map ('c 31) ('b 29) ('d 37) ('a 13))))
		  '((c 31) (b 29) (d 37) (a 13))))
    (test (equal? (gmap (:result replay-map) #'values (:arg list '(a c a b a c)) (:arg list '(19 23 47 11 37 43)))
		  (ch-replay-map ('a 37) ('c 43) ('b 11))))
    (test (equal? (gmap (:result wb-replay-map) #'values (:arg list '(a c a b a c)) (:arg list '(19 23 47 11 37 43)))
		  (wb-replay-map ('a 37) ('c 43) ('b 11))))
    (test (equal? (gmap (:result ch-replay-map) #'values (:arg list '(a c a b a c)) (:arg list '(19 23 47 11 37 43)))
		  (ch-replay-map ('a 37) ('c 43) ('b 11))))))

(defun Test-Misc-0 ()
  "Tests some things that don't need extensive random test cases generated."
  (macrolet ((test (form)
	       `(unless ,form
		  (error "Test failed: ~S" ',form))))
    (flet ((equal? (a b)
	     (and (equal? a b)
		  (equal? b a)))
	   (less-than? (a b)
	     (and (less-than?-cmp a b #'compare)
		  (greater-than?-cmp b a #'compare)))
	   (greater-than? (a b)
	     (and (greater-than?-cmp a b #'compare)
		  (less-than?-cmp b a #'compare)))
	   (unequal? (a b)
	     (let ((ab (eq (compare a b) ':unequal))
		   (ba (eq (compare b a) ':unequal)))
	       (assert (eq ab ba))
	       ab)))
      (test (less-than? nil 1))
      (test (less-than? 1 2))
      (test (equal? 11/31 11/31))
      (test (unequal? 3 3.0))
      (test (less-than? 1 #\x))
      (test (less-than? #\x #\y))
      (test (less-than? #\z 'a))
      (test (less-than? 'a 'b))
      (test (less-than? 'x 'ab))
      (test (equal? 'a 'a))
      (test (less-than? 'reduce 'cl:find))
      (test (less-than? '#:a '#:b))
      (test (unequal? '#:foo '#:foo))
      (test (less-than? 'a "A"))
      (test (less-than? "A" "B"))
      (test (less-than? "x" "12"))
      (test (equal? "This is a text." "This is a text."))
      (test (unequal? '(a . 3) '(a . 3.0))) ; #56
      (test (less-than? (make-array '(1)
				    :element-type 'base-char
				    :initial-element #\A
				    :adjustable t)
			"B"))
      (test (less-than? "A"
			(make-array '(1)
				    :element-type 'base-char
				    :initial-element #\B
				    :adjustable t)))
      (test (equal? (make-array '(5)
				:initial-contents '(#\a #\b #\c #\d #\e)
				:element-type 'base-char
				:adjustable t)
		    "abcde"))
      (test (less-than? "x" #(#\x)))
      (test (less-than? #(1) #(#\y)))
      (test (let ((v #(1 2))) (equal? v v)))
      (let ((x #(1 2)))
	(test (equal? x x))
	(test (not (unequal? x x))))
      (test (equal? #(1 2) #(1 2)))
      (test (less-than? #(1) #(1 2)))
      (test (less-than? #2A((0 1) (1 2)) #2A((0 1) (1 3))))
      (test (equal? #(1 2) (make-array '(2) :initial-contents '(1 2)
				       :adjustable t)))
      (test (equal? (make-array '(2) :initial-contents '(1 2)
				:adjustable t)
		    (make-array '(2) :initial-contents '(1 2)
				:adjustable t)))
      (test (less-than? (make-array '(1) :initial-contents '(1)
				    :adjustable t)
			(make-array '(2) :initial-contents '(1 2)
				    :adjustable t)))
      (test (less-than? (make-array '(1) :initial-contents '(1)
				    :adjustable t)
			(make-array '(1) :initial-contents '(2)
				    :adjustable t)))
      (test (less-than? (make-my-integer 0) ""))
      (test (less-than? (make-my-integer 0) 0))
      (test (less-than? (make-my-integer 0) #()))
      (test (equal? (make-my-integer 0) (make-my-integer 0)))
      (test (unequal? (make-my-integer 0) (make-my-integer 1)))
      (test (let ((obj (make-instance 'my-unhandled-obj)))
	      (equal? obj obj)))
      (test (unequal? (make-instance 'my-unhandled-obj)
		      (make-instance 'my-unhandled-obj)))
      (test (unequal? (make-array '(1) :initial-element '#:foo)
		      (make-array '(1) :initial-element '#:foo)))
      (test (unequal? (make-array '(1) :initial-element '#:foo)
		      (make-array '(1) :initial-element '#:foo
				  :adjustable t)))
      (test (less-than? (make-instance 'my-identity-ordered-obj)
			(make-instance 'my-identity-ordered-obj)))
      (test (let ((obj (make-instance 'my-identity-ordered-obj)))
	      (equal? obj obj)))
      ;; Anyone hacking the guts of FSet should be sure they understand the next
      ;; two examples.
      (test (unequal? #(1 2) #(1.0 2)))
      (test (less-than? #(1 2) #(1.0 3)))
      (test (less-than? #(1) '(0)))
      (test (less-than? '(0) '(a)))
      (test (less-than? '(0 1) '(a)))
      (test (unequal? '(1 2) '(1.0 2)))
      (test (less-than? '(1 2) '(1.0 3)))
      (test (let ((v (vector 1))) (equal? v v)))
      (test (less-than? '(x) (find-package :fset)))
      (test (less-than? (find-package :fset) #p"/"))
      (test (equal? #p"/foo/bar" #p"/foo/bar"))
      (test (less-than? #p"/foo/bar" #p"/foo/baz"))
      (test (less-than? #p"/bar" #p"/foo/bar"))
      (test (less-than? #p"/" (set)))
      (test (less-than? #*110101001101 #*111001001101))
      (test (greater-than? #*111001001101 #*110101001101))

      (test (equal? (with-first '(a b) 'x) '(x a b)))
      (test (equal? (less-first '(a b)) '(b)))
      (test (equal? (with-last '(a b) 'x) '(a b x)))
      (test (equal? (less-last '(a b)) '(a)))

      ;; Test subtle code in compare on renamed packages
      (let ((name1 "FSET-TESTING-PACKAGE-1")
	    (name2 "FSET-TESTING-PACKAGE-2"))
	(flet ((%clean ()
		 (when (find-package name1) (delete-package name1))
		 (when (find-package name2) (delete-package name2))))
	  (%clean)
	  (unwind-protect
	       (let ((p1 (make-package name1 :use nil)))
		 (test (not (equal? p1 (find-package :fset))))
		 (rename-package p1 name2)
		 (let ((p2 (make-package name1 :use nil)))
		   (test (unequal? p1 p2))))
	    (%clean))))

      ;; We use `eval' to force the macro to be expanded during the test.
      (test (equal (convert 'list
			    (eval '(set 1 ($ (set 1 2)) ($ (set 3 4)))))
		   '(1 2 3 4)))
      (test (equalp (convert 'list
			     (set "foo" (find-package :fset) '(a b) 17 #p"/"
				  nil #\x 'car #p"/foo" "bar" 'bike #(1 2) 3
				  #(2 1) '(a . b) #\y))
		    `(nil 3 17 #\x #\y bike car "bar" "foo" #(1 2) #(2 1)
		      (a . b) (a b) ,(find-package :fset) #p"/" #p"/foo")))
      (test (less-than? (set 1 2) (set 1 2 0)))
      (test (unequal? (set 'a 3 'c) (set 'a 3.0 'c)))
      (test (less-than? (set 'a 3 'c) (set 'a 3.0 'd)))
      (test (less-than? (wb-set 8 12) (wb-custom-set 'erapmoc 0 2))) ; because "compare" < "erapmoc"
      (test (less-than? (ch-set 8 12) (ch-custom-set 'erapmoc 0 2)))
      (test (less-than? (ch-set 8 12) (wb-custom-set 'erapmoc 0 2))) ; because "ch-..." < "wb-..."
      (test (less-than? (ch-custom-set 'erapmoc 0 2) (wb-set 8 12)))
      (test (less-than? (set 1) (bag 1)))
      (test (equal (convert 'list
			    (eval '(bag 1 ($ (bag 3 3)) (% "x" 3) 4
				        ($ (bag (% 7 2) 8 1)))))
		   '(1 1 3 3 4 7 7 8 "x" "x" "x")))
      (test (equal (convert 'list (bag 1 2 1)) '(1 1 2)))
      (test (less-than? (bag 0 0 1 1 2) (wb-custom-bag 'erapmoc 0 1 1 1 2)))

      (test (less-than? (bag 1) (map ('x 1))))
      (test (equal (convert 'list
			    (eval '(map ($ (map ('x 0) ('y 3) ('z 4))) ('x 1)
				        ($ (map ('z 7) ('w 9))))))
		   '((w . 9) (x . 1) (y . 3) (z . 7))))
      (test (equal (convert 'list (map ('x 1) ('y 2))) '((x . 1) (y . 2))))
      (test (less-than? (map ('x 1)) (map ('y 1))))
      (test (less-than? (map ('x 1)) (map ('x 2))))
      (test (unequal? (map ('x 1) ('y 2)) (map ('x 1.0) ('y 2))))
      (test (less-than? (map ('x 1)) (seq "x")))
      (test (less-than? (map ('c 43) ('d 17)) (map ('c 44) ('d 17))))
      (test (less-than? (map ('c 43) ('d 17)) (map ('c 43) ('e 17))))
      (test (less-than? (map ('c 43) ('d 17)) (wb-custom-map 'erapmoc nil ('c 43) ('d 17))))
      (test (less-than? (ch-map ('c 43) ('d 17)) (ch-map ('c 44) ('d 17))))
      (test (less-than? (ch-map ('c 43) ('d 17)) (ch-custom-map 'erapmoc nil ('c 43) ('d 17))))
      (test (equal (convert 'list (eval '(seq 1 ($ (seq 8 'x 7)) 2 4 ($ (seq 'z 3)))))
		   '(1 8 x 7 2 4 z 3)))
      (test (equal (convert 'list (seq 1 'x "u")) '(1 x "u")))
      (test (less-than? (seq "x") (seq "y")))
      (test (unequal? (seq 'a 3 'c) (seq 'a 3.0 'c)))
      (test (less-than? (seq 'a 3 'c) (seq 'a 3.0 'd)))
      (test (less-than? (seq) (tuple)))
      (test (equal (sort (convert 'list (eval '(tuple (+K0+ 1)
						      ($ (tuple (+K1+ 2) (+K2+ 3)))
						      (+K0+ 2)
						      ($ (tuple (+K4+ 7) (+K2+ 8))))))
			 #'< :key (fn (x) (tuple-key-number (car x))))
		   `((,+K0+ . 2) (,+K1+ . 2) (,+K2+ . 8) (,+K4+ . 7))))
      (test (less-than? (tuple (+K0+ 1)) (tuple (+K0+ 2))))
      (test (unequal? (tuple (+K0+ 1.0) (+K1+ 'c)) (tuple (+K0+ 1) (+K1+ 'c))))
      (test (less-than? (tuple (+K0+ 1.0) (+K1+ 'c)) (tuple (+K0+ 1) (+K1+ 'd))))
      (test (not (equal? (map (3 7) :default 0) (map (3 7) :default 1))))
      (test (not (equal? (with-default (seq 42 17) 6) (with-default (seq 42 17) 9))))

      (test (equal? (image +K0+ (set)) (set)))
      (test (equal? (image +K0+ (set (tuple))) (set nil)))
      (test (equal? (image +K0+ (set (tuple (+K0+ 1) (+K1+ 2)) (tuple (+K0+ 3) (+K2+ 17))))
		    (set 1 3)))
      (test (equal? (image +K0+ (seq)) (seq)))
      (test (equal? (image +K0+ (seq (tuple) (tuple (+K0+ 1) (+K1+ 2)) (tuple (+K0+ 3) (+K2+ 17))))
		    (seq nil 1 3)))
      (test (equal? (restrict (tuple) (set)) (tuple)))
      (test (equal? (restrict (tuple (+K0+ 1)) (set)) (tuple)))
      (test (equal? (restrict (tuple (+K0+ 1) (+K1+ 2) (+K3+ 5)) (set +K1+)) (tuple (+K1+ 2))))
      (test (equal? (restrict-not (tuple) (set)) (tuple)))
      (test (equal? (restrict-not (tuple (+K0+ 1)) (set)) (tuple (+K0+ 1))))
      (test (equal? (restrict-not (tuple (+K0+ 1) (+K1+ 2) (+K3+ 5)) (set +K1+))
		    (tuple (+K0+ 1) (+K3+ 5))))

      (test (empty? (set)))
      (test (empty? (less (set 3) 3)))
      (test (empty? (map)))
      (test (empty? (less (map (3 42)) 3)))
      (test (empty? (bag)))
      (test (empty? (less (bag 7) 7)))
      (test (empty? (seq)))
      (test (empty? (less (seq 'a) 0)))	 ; #67
      (test (empty? (less (seq #\x) 0))) ; #67
      (test (nonempty? (set 1)))
      (test (locally (declare (notinline nonempty?)) (nonempty? (set 1))))
      (test (member? 1 (set 1)))
      (test (lookup (set 1 2 3 4 5 6 7 8 9 10) 1))
      (test (lookup (set 1 2 3 4 5 6 7 8 9 10) 6))
      (test (lookup (set 1 2 3 4 5 6 7 8 9 10) 10))
      (test (equal (multiple-value-list (lookup (convert 'bag '(3 3 5 5 5)) 3)) '(t 3)))
      (test (equal (multiple-value-list (lookup (convert 'bag '(3 3 5 5 5)) 4)) '(nil nil)))

      (dolist (n '(2 5 10 20))
	(let* ((s (gmap (:result set) (fn (i) (make-instance 'my-unhandled-obj :value i)) (:arg index 0 n)))
	       (singles (gmap (:result list) (fn (o) (set o)) (:arg set s))))
	  (dolist (s1 singles)
	    (test (subset? s1 s))
	    (test (not (subset? s s1))))
	  (test (every (lambda (o) (lookup s o)) s))))

      (let* ((objs (gmap (:result list) (fn (i) (make-instance 'my-unhandled-obj :value i)) (:arg index 0 3)))
	     (s (convert 'set objs))
	     (s1 (set (car objs)))
	     (s2 (set (cadr objs)))
	     (s3 (set (caddr objs)))
	     (s12 (set (car objs) (cadr objs)))
	     (s23 (set (cadr objs) (caddr objs))))
	(test (subset? s1 s12))
	(test (subset? s2 s12))
	(test (not (subset? s1 s2)))
	(test (not (subset? s1 s23)))
	(test (equal? (union s1 s23) s))
	(test (equal? (union s12 s23) s))
	(test (subset? s1 s))
	(test (subset? s12 s))
	(test (subset? s23 s))
	(test (subset? s s))

	(test (empty? (intersection s1 s2)))
	(test (empty? (intersection s1 s23)))
	(test (empty? (intersection s12 s3)))
	(test (empty? (intersection (set) s)))
	(test (empty? (intersection s (set)))))

      (test-equivalent-sets)

      (test (subset? (set 1) (set 1 2)))
      (test (subset? (set 2) (set 1 2)))
      (test (not (subset? (set 2) (set 1 3))))
      (test (subset? (set 1) (ch-set 1 2)))
      (test (not (subset? (set 1 3) (ch-set 1 2))))

      (test (not (lookup (set 1 7 10) 8)))
      (test (equal? (split #'evenp (set 1 2)) (set 2)))
      (test (equal? (nth-value 1 (split #'evenp (set 1 2))) (set 1)))
      (test (equal (multiple-value-list (split #'evenp '(1 2))) '((2) (1))))
      (test (equal? (filter-pairs (lambda (v c) (declare (ignore v)) (> c 1))
				  (bag 1 2 2 3 3 4 5 5 5 6))
		    (bag 2 2 3 3 5 5 5)))
      (test (equal? (filter-pairs (constantly t) (set 1 2 3)) (set 1 2 3)))
      (test (equal? (image #'1+ '(1 2 3)) '(2 3 4)))
      (test (equal? (image '1+ '(1 2 3)) '(2 3 4)))
      (test (equal? (image (set 1 3) '(1 2 3 4)) '(t nil t nil)))
      (test (equal? (fset2:image (set 1 3) '(1 2 3 4)) '(t nil t nil)))
      (test (equal? (image (set 1 3) #(1 2 3 4)) #(t nil t nil)))
      (test (equal? (fset2:image (set 1 3) #(1 2 3 4)) #(t nil t nil)))
      (test (equal? (image '1+ (set 0 4 7)) (set 1 5 8)))
      (test (equal? (image #'1+ (set 9 3 17)) (set 4 10 18)))
      (test (equal? (image (map (1 4) (2 8) (3 10) :default 0) (set 1 2 7))
		    (set 0 4 8)))
      (test (equal? (image '1+ (ch-set 0 4 7)) (ch-set 1 5 8)))
      (test (equal? (image #'1+ (ch-set 9 3 17)) (ch-set 4 10 18)))
      (test (equal? (image (map (1 4) (2 8) (3 10) :default 0) (ch-set 1 2 7))
		    (ch-set 0 4 8)))
      (test (equal? (image (map (1 2) (3 4)) '(1 2 3)) '(2 nil 4)))
      (test (equal? (fset2:image (map (1 2) (3 4)) '(1 2 3)) '(2 nil 4)))
      (test (equal? (image (map (1 2) (3 4)) #(1 2 3)) #(2 nil 4)))
      (test (equal? (fset2:image (map (1 2) (3 4)) #(1 2 3)) #(2 nil 4)))
      (test (equal? (image (set 1) (set 1)) (set t)))
      (test (equal? (image (set 1) (set 2)) (set nil)))
      (test (equal? (image (set 1) (set 1 2)) (set nil t)))
      (test (equal? (image (set 1) (ch-set 1 2)) (ch-set nil t)))
      (test (equal? (image (bag 1) (set 1)) (set t)))
      (test (equal? (image (bag 1) (set 2)) (set nil)))
      (test (equal? (image (bag 1 1 2) (set 1 2 3)) (set nil t)))
      (test (equal? (image (bag 1 1 2) (ch-set 1 2 3)) (ch-set nil t)))

      (test (equal? (reduce #'+ (set 1 2 3) :initial-value 0) 6))
      (test (equal? (reduce #'+ (set 1 2 3) :initial-value 1 :key '1+) 10))
      (test (equal? (reduce #'+ (set 1 2 3) :key #'1+ :initial-value 0) 9))
      (test (equal? (reduce '+ (set 1 2 3 5) :initial-value 0) 11))
      (test (equal? (reduce '+ (set 1 2 3 5) :key '1+ :initial-value 0) 15))
      (test (equal (reduce #'cons (set 1 2 3)) '((1 . 2) . 3)))
      (test (equal (reduce 'cons (set 1 2 3)) '((1 . 2) . 3)))
      (test (equal (reduce #'cons (set 1 2 3) :key #'1+) '((2 . 3) . 4)))
      (test (equal (reduce #'list (set)) nil))
      (test (equal (reduce 'list (set)) nil))
      (test (equal (reduce #'+ (set)) 0))
      (test (equal (reduce '+ (set)) 0))
      (test (equal (reduce #'+ (set) :initial-value 1) 1))
      (test (equal (reduce '+ (set) :initial-value 1) 1))
      (test (equal (reduce #'+ (set) :initial-value nil) nil))
      (test (equal (reduce '+ (set) :initial-value nil) nil))

      (test (equal? (sort (set 4 2 19 14) #'<) (seq 2 4 14 19)))
      (test (equal? (sort (set 4 2 19 14) #'< :key #'-) (seq 19 14 4 2)))
      (test (equal? (default (sort (with-default (seq 1 2 0) 3) #'<)) 3))
      (test (equal? (stable-sort (set 4 2 19 14) #'<) (seq 2 4 14 19)))
      (test (equal? (stable-sort (set 4 2 19 14) #'< :key #'-) (seq 19 14 4 2)))
      (test (equal? (default (stable-sort (with-default (seq 1 2 0) 3) #'<)) 3))

      (test (equal? (convert 'set (set 1 2 4)) (set 1 2 4)))
      (test (equal? (convert 'wb-set (wb-set 5 8 19)) (wb-set 5 8 19)))
      (test (equal? (convert 'bag (wb-set 3 18 24 4)) (bag 3 4 18 24)))
      (test (equal? (convert 'wb-bag (wb-set 3 18 24 4)) (wb-bag 3 4 18 24)))
      (test (equal? (convert 'set (seq 3 10 4 20 7)) (set 3 4 7 10 20)))
      (test (equal? (convert 'wb-set (seq 3 10 4 20 7)) (wb-set 3 4 7 10 20)))
      (test (equal? (convert 'set (vector 3 10 4 20 7)) (set 3 4 7 10 20)))
      (test (equal? (convert 'wb-set (vector 3 10 4 20 7)) (wb-set 3 4 7 10 20)))
      (test (equal? (convert 'set '(1 1)) (set 1)))

      (test (handler-case (progn (convert 'bag '((1 . 0)) :from-type 'alist) nil)
              (simple-type-error (e) e)))
      (test (handler-case (progn (convert 'bag '((1 . :x)) :from-type 'alist) nil)
              (simple-type-error (e) e)))

      (dolist (n '(0 2 5 7 10))
	(let* ((vals (gmap (:result list) nil (:arg index 0 n)))
	       #+sbcl
	       (seq (make-instance 'my-sequence :actual vals))
	       (s (set)))
	  (dolist (i vals) (setf s (with s i)))
	  (test (equal? (convert 'set vals) s))
	  #+sbcl
	  (test (equal? (convert 'set seq) s))))

      (test (equal (find 0 (set)) nil))
      (test (equal (find 1 (set 1)) 1))
      (test (equal (find 1 (set 1) :test 'equal?) 1))
      (test (equal (find 1 (set 1) :test #'equal?) 1))
      (test (equal (find 1 (set 1 0) :key #'1+) 0))
      (test (equal (find 2 (set 1 0) :key #'1+) 1))
      (test (equal (find 3 (set 1 2 8) :test #'<) 8))
      (test (equal (find 3 (set 1 2 8) :key '1+ :test #'<=) 2))
      (test (equal (find 1 (set) :key #'1+) nil))
      (let ((s1 "x") (s2 (copy-seq "x")))
        (test (eql (find s1 (set s2)) s2))
        (test (eql (find s1 (set s2) :test #'eql) nil))
        (test (eql (find s1 (set s2) :key #'identity) s2))
        (test (eql (find s1 (set s2) :test #'eql :key #'identity) nil)))
      (test (equal (find nil (set 1) :test (lambda (x y) (not (eql x y)))) 1))

      (test (equal (find-if #'evenp (set 1 2 3)) 2))
      (test (equal (find-if 'evenp (set 1 2 3)) 2))
      (test (equal (find-if #'evenp (set 0 1) :key #'1+) 1))
      (test (equal (find-if #'oddp (set 0 1) :key #'1+) 0))
      (test (equal (find-if-not #'evenp (set 2 3 4)) 3))
      (test (equal (find-if-not 'evenp (set 2 3 4)) 3))
      (test (equal (find-if-not 'evenp (set 3 4 5) :key #'1+) 4))

      (test (equal (count 5 (set 4 5 6)) 1))
      (test (equal (count 1 (set)) 0))
      (test (equal (count 1 (set) :test 'equal?) 0))
      (test (equal (count 1 (set) :test #'equal?) 0))
      (test (equal (count nil (set 1 2 3 4 5) :key #'evenp) 3))
      (test (equal (count nil (set 1 2 3 4 5) :key 'evenp) 3))
      (test (equal (count 3 (set 1 2 3 4 5 6 7) :test #'<=) 5))
      (test (equal (count 3 (set 1 2 3 4 5 6 7) :test '>) 2))
      (test (equal (count 3 (set 1 2 3 4 5 6 7) :test #'> :key #'1+) 1))
      (test (equal (count 5 (set 1 2 3 4 5 6 7) :test #'> :key #'1+) 3))

      (test (equal (count-if #'evenp (set 0 1 2 3 4)) 3))
      (test (equal (count-if 'evenp (set 1 2 3 4 5)) 2))
      (test (equal (count-if #'evenp (set 1 2 3 4 5) :key #'1+) 3))
      (test (equal (count-if #'evenp (set 1 2 3 4 5) :key '1+) 3))

      (test (equal (count-if-not #'evenp (set 0 1 2 3 4)) 2))
      (test (equal (count-if-not #'evenp (set 0 1 2 3 4) :key #'1+) 3))

      (locally (declare (notinline empty-bag empty-wb-bag))
	(test (equal? (size (empty-bag)) 0))
	(test (equal? (empty-bag) (bag)))
	(test (equal? (size (empty-wb-bag)) 0))
	(test (equal? (empty-wb-bag) (wb-bag))))

      (test (equal (multiplicity (set 0 1) 0) 1))
      (test (equal (multiplicity (set 0 1) 2) 0))

      (test (equal? (with (bag 1 2) 1) (bag 1 1 2)))
      (test (equal? (with (bag 1 2) 1 0) (bag 1 2)))
      (test (equal? (with (bag 1 2) 1 2) (bag 1 1 1 2)))
      (test (equal? (with (bag 1 2) 3) (bag 1 2 3)))
      (test (equal? (with (bag 1 2) 3 4) (bag 1 2 3 3 3 3)))

      (test (equal? (less (bag 1 2) 1) (bag 2)))
      (test (equal? (less (bag 1 2) 1 0) (bag 1 2)))
      (test (equal? (less (bag 1 1 2) 1) (bag 1 2)))
      (test (equal? (less (bag 1 1 2) 1 2) (bag 2)))

      (test (equal? (union (set) (bag)) (bag)))
      (test (equal? (union (set 1) (bag 2)) (bag 1 2)))
      (test (equal? (union (set 1) (bag 2 2)) (bag 1 2 2)))
      (test (equal? (union (set 2) (bag 2 2)) (bag 2 2)))

      (test (equal? (union (bag) (set)) (bag)))
      (test (equal? (union (bag 1) (set 2)) (bag 1 2)))
      (test (equal? (union (bag 1 1) (set 2)) (bag 1 1 2)))
      (test (equal? (union (bag 1 1) (set 1 3)) (bag 1 1 3)))

      (test (equal? (bag-sum (set) (bag)) (bag)))
      (test (equal? (bag-sum (set 1) (bag 2)) (bag 1 2)))
      (test (equal? (bag-sum (set 1) (bag 1 2)) (bag 1 1 2)))
      (test (equal? (bag-sum (set 1) (bag 1 1 2)) (bag 1 1 1 2)))
      (test (equal? (bag-sum (set 3) (bag 1 1 2)) (bag 1 1 2 3)))

      (test (equal? (bag-sum (bag) (set)) (bag)))
      (test (equal? (bag-sum (bag 2) (set 1)) (bag 1 2)))
      (test (equal? (bag-sum (bag 1 2) (set 1)) (bag 1 1 2)))
      (test (equal? (bag-sum (bag 1 1 2) (set 1)) (bag 1 1 1 2)))
      (test (equal? (bag-sum (bag 1 1 2) (set 3)) (bag 1 1 2 3)))

      (test (equal? (intersection (set) (bag)) (set)))
      (test (equal? (intersection (set 1) (bag 2)) (set)))
      (test (equal? (intersection (set 1) (bag 1 2)) (set 1)))
      (test (equal? (intersection (set 1) (bag 1 1 2)) (set 1)))
      (test (equal? (intersection (set 3) (bag 1 1 2)) (set)))

      (test (equal? (bag-product (set) (bag)) (bag)))
      (test (equal? (bag-product (set 1) (bag)) (bag)))
      (test (equal? (bag-product (set) (bag 2)) (bag)))
      (test (equal? (bag-product (set 1) (bag 2)) (bag)))
      (test (equal? (bag-product (set 1) (bag 1)) (bag 1)))
      (test (equal? (bag-product (set 1) (bag 1 1 2)) (bag 1 1)))
      (test (equal? (bag-product (set 2) (bag 1 1 2)) (bag 2)))

      (test (equal? (bag-product (bag) (set)) (bag)))
      (test (equal? (bag-product (bag) (set 1)) (bag)))
      (test (equal? (bag-product (bag 2) (set)) (bag)))
      (test (equal? (bag-product (bag 2) (set 1)) (bag)))
      (test (equal? (bag-product (bag 1) (set 1)) (bag 1)))
      (test (equal? (bag-product (bag 1 1 2) (set 1)) (bag 1 1)))
      (test (equal? (bag-product (bag 1 1 2) (set 2)) (bag 2)))

      (test (equal? (bag-difference (set) (bag)) (bag)))
      (test (equal? (bag-difference (set) (bag 1)) (bag)))
      (test (equal? (bag-difference (set 1) (bag)) (bag 1)))
      (test (equal? (bag-difference (set 1) (bag 1)) (bag)))
      (test (equal? (bag-difference (set 1) (bag 1 1)) (bag)))
      (test (equal? (bag-difference (set 1) (bag 2)) (bag 1)))
      (test (equal? (bag-difference (set 1 3) (bag 1 2)) (bag 3)))

      (test (equal? (bag-difference (bag) (set)) (bag)))
      (test (equal? (bag-difference (bag 1) (set)) (bag 1)))
      (test (equal? (bag-difference (bag) (set 1)) (bag)))
      (test (equal? (bag-difference (bag 1) (set 1)) (bag)))
      (test (equal? (bag-difference (bag 1 1) (set 1)) (bag 1)))
      (test (equal? (bag-difference (bag 1 2) (set 1)) (bag 2)))
      (test (equal? (bag-difference (bag 1 1 1 2) (set 1 3)) (bag 1 1 2)))

      (test (subbag? (set) (bag)))
      (test (subbag? (set) (bag 1)))
      (test (subbag? (set 1) (bag 1)))
      (test (subbag? (set 1) (bag 1 1)))
      (test (not (subbag? (set 1) (bag))))
      (test (not (subbag? (set 1 3 5) (bag 1 1 4 7 5))))

      (test (subbag? (bag) (set)))
      (test (subbag? (bag) (set 1)))
      (test (subbag? (bag 1) (set 1)))
      (test (not (subbag? (bag 1) (set 2))))
      (test (not (subbag? (bag 1 1) (set 1))))
      (test (not (subbag? (bag 1 2) (set 1))))
      (test (subbag? (bag 1 4 8 10) (set 0 1 2 3 4 5 6 7 8 9 10 11)))
      (test (not (subbag? (bag 1 4 8 8 10) (set 0 1 2 3 4 5 6 7 8 9 10 11))))
      (test (subbag? (bag 1 3 3) (wb-custom-bag 'erapmoc 1 1 3 3 7 12)))

      (test (disjoint? (set 1 3 5) (set 0 2 4 6)))
      (test (disjoint? (set 1 3 5) (wb-custom-set 'erapmoc 0 2 4 6)))
      (test (disjoint? (ch-set 1 3 5) (ch-set 0 2 4 6)))
      (test (not (disjoint? (set 1 3 5) (set 0 2 3 4 6))))
      (test (not (disjoint? (set 1 3 5) (wb-custom-set 'erapmoc 0 2 3 4 6))))
      (test (not (disjoint? (ch-set 1 3 5) (ch-set 0 2 3 4 6))))
      (test (disjoint? (set 1 3 5) (bag 0 2 4 6)))
      (test (disjoint? (ch-set 1 3 5) (bag 0 2 4 6)))
      (test (not (disjoint? (set 1 3 5) (bag 0 2 3 4 6))))
      (test (not (disjoint? (ch-set 1 3 5) (bag 0 2 3 4 6))))
      (test (disjoint? (bag 0 2 4 6) (set 1 3 5)))
      (test (disjoint? (bag 0 2 4 6) (ch-set 1 3 5)))
      (test (not (disjoint? (bag 0 2 3 4 6) (set 1 3 5))))
      (test (not (disjoint? (bag 0 2 3 4 6) (ch-set 1 3 5))))

      (test (equal? (filter #'evenp (bag)) (bag)))
      (test (equal? (filter #'evenp (bag 1)) (bag)))
      (test (equal? (filter #'evenp (bag 2)) (bag 2)))
      (test (equal? (filter #'evenp (bag 1 1 2 2)) (bag 2 2)))
      (test (equal? (filter 'evenp (bag 1 1 1 2 2 3)) (bag 2 2)))
      (test (equal? (filter (map (1 t) (3 t)) (bag 0 0 1 1 1 2 3 4 4 4 5))
		    (bag 1 1 1 3)))
      (test (equal? (filter (set 1 3) (bag 0 1 1 1 2 3 4 4 4 5))
		    (bag 1 1 1 3)))
      (test (equal? (filter (bag 1 1 3) (bag 0 1 1 1 2 3 4 4 4 5))
		    (bag 1 1 1 3)))
      (test (equal? (filter #'evenp '(1 2 3 4)) '(2 4)))
      (test (equal? (filter #'zerop #*01101110) #*000))
      (test (equal? (filter #'symbolp #(:a 1 :b (:x) 10.0)) #(:a :b)))
      (test (equal? (filter-pairs #'evenp  '(1 2 3 4)) '(2 4)))
      (test (equal? (filter-pairs 'oddp  '(1 2 3 4)) '(1 3)))

      (let ((e (lambda (x c) (declare (ignore c)) (evenp x))))
	(test (equal? (filter-pairs e (bag)) (bag)))
	(test (equal? (filter-pairs e (bag 1 2 2 3 4 5)) (bag 2 2 4))))
      (test (equal? (filter-pairs '= (bag 1 1 1 2 2 3)) (bag 2 2)))

      (test (equal? (image #'1+ (bag)) (bag)))
      (test (equal? (image #'1+ (bag 1)) (bag 2)))
      (test (equal? (image #'1+ (bag 1 1)) (bag 2 2)))
      (test (equal? (image #'1+ (bag 0 1 1 3 4 4 4 5)) (bag 1 2 2 4 5 5 5 6)))
      (test (equal? (image '1+ (bag 0 1 2 2 3)) (bag 1 2 3 3 4)))
      (test (equal? (image (map (1 4) (2 5) (3 6) (4 5) :default 0) (bag 0 1 1 2 2 2 3 4 5 6))
		    (bag 0 0 0 4 4 5 5 5 5 6)))
      (test (equal? (image (set 1) (bag 1)) (bag t)))
      (test (equal? (image (set 0) (bag 1)) (bag nil)))
      (test (equal? (image (set 0 3) (bag 0 1 2 3 5)) (bag nil nil nil t t)))
      (test (equal? (image (bag 1 1) (bag 1)) (bag t)))
      (test (equal? (image (bag 0) (bag 1)) (bag nil)))
      (test (equal? (image (bag 0 3) (bag 0 1 1 2 3 5)) (bag nil nil nil nil t t)))

      (test (equal (reduce #'+ (bag 1 2 3) :initial-value 0) 6))
      (test (equal (reduce '+ (bag 1 2 3) :initial-value 0) 6))
      (test (equal (reduce #'+ (bag 1 2 2 3) :initial-value 0) 8))
      (test (equal (reduce #'+ (bag 1 2 3) :key #'1+ :initial-value 0) 9))
      (test (equal (reduce '+ (bag 1 2 3) :key #'1+ :initial-value 0) 9))
      (test (equal (reduce #'+ (bag 1 2 3) :key '1+ :initial-value 0) 9))
      (test (equal (reduce '+ (bag 1 2 3) :key '1+ :initial-value 0) 9))
      (test (equal (reduce #'+ (bag 1 2 2 3) :key #'1+ :initial-value 0) 12))
      (test (equal (reduce 'cons (bag 1 2 3)) '((1 . 2) . 3)))
      (test (equal (reduce 'cons (bag 1 2 3) :key #'1+) '((2 . 3) . 4)))
      (test (equal (reduce #'cons (bag 1 2 2 3)) '(((1 . 2) . 2) . 3)))
      (test (equal (reduce 'list (bag)) nil))
      (test (equal (reduce #'+ (bag)) 0))
      (test (equal (reduce '+ (bag)) 0))
      (test (equal (reduce #'+ (bag) :initial-value nil) nil))
      (test (equal (reduce '+ (bag) :initial-value nil) nil))

      (test (equal? (convert 'bag (bag 0 1 1 2 3 3 4)) (bag 0 1 1 2 3 3 4)))
      (test (equal? (convert 'wb-bag (bag 0 1 1 2 3 3 4)) (wb-bag 0 1 1 2 3 3 4)))
      (test (equal? (convert 'set (bag 0 1 1 2 3 3 4)) (set 0 1 2 3 4)))
      (test (equal? (convert 'wb-set (bag 0 1 1 2 3 3 4)) (wb-set 0 1 2 3 4)))
      (test (equal? (convert 'list (bag 0 1 1 2 3 3 4)) '(0 1 1 2 3 3 4)))
      (test (equal? (convert 'seq (bag 0 1 1 2 3 3 4)) (seq 0 1 1 2 3 3 4)))
      (test (equal? (convert 'list (bag 0 1 1 2 3 3 4) :pairs? t)
		   '((0 . 1) (1 . 2) (2 . 1) (3 . 2) (4 . 1))))
      (test (equal? (convert 'seq (bag 0 1 1 2 3 3 4) :pairs? t)
		    (seq '(0 . 1) '(1 . 2) '(2 . 1) '(3 . 2) '(4 . 1))))
      (test (equalp (convert 'vector (bag 0 1 1 2 3 3 4)) #(0 1 1 2 3 3 4)))

      (test (equal (convert 'alist (bag 1 1 2 2 2)) '((1 . 2) (2 . 3))))

      (test (equal? (convert 'bag (vector 10 0 8 1 1 2 5 9 9 9))
		    (bag 0 1 1 2 5 8 9 9 9 10)))
      (test (equal? (convert 'wb-bag (vector 10 0 8 1 1 2 5 9 9 9))
		    (bag 0 1 1 2 5 8 9 9 9 10)))

      (test (equal? (convert 'wb-bag '(1 1 2 2 2))
                    (bag 1 1 2 2 2)))
      (test (equal? (convert 'bag '((1 . 2) (2 . 3)) :from-type 'alist)
                    (bag 1 1 2 2 2)))
      (test (equal? (convert 'wb-bag '((1 . 2) (2 . 3)) :from-type 'alist)
                    (bag 1 1 2 2 2)))

      (test (equal? (convert 'seq #(foo 17 bar 42 baz))
		    (seq 'foo 17 'bar 42 'baz)))
      (test (equal? (convert 'seq '(foo 17 bar 42 baz))
		    (seq 'foo 17 'bar 42 'baz)))
      (test (equal? (convert 'seq '(foo 17 bar 42 baz) :reverse? t)
		    (seq 'baz 42 'bar 17 'foo)))

      (test (equal (find 0 (bag)) nil))
      (test (equal (find 1 (bag 1)) 1))
      (test (equal (find 2 (bag 2)) 2))
      (test (equal (find 1 (bag 0 1 2)) 1))
      (test (equal (find 1 (bag 0 1 2) :test #'equal?) 1))
      (test (equal (find 1 (bag 0 1 2) :test 'equal?) 1))
      (test (equal (find 1 (bag 0 1 1 2)) 1))
      (test (equal (find 1 (bag 0 0 1 2)) 1))
      (test (equal (find 1 (bag 0 1 2 2)) 1))
      (test (equal (find 1 (bag 0 0 1 1 2 2)) 1))
      (test (equal (find 1 (bag 0 1 2 3) :key #'1-) 2))
      (test (equal (find 3 (bag 0 1 2 3) :key '1+) 2))
      (test (equal (find 1 (bag 0 1 2 3) :test '<) 2))
      (test (equal (find 2 (bag 0 1 2 3) :test '<) 3))
      (test (equal (find 1 (bag 0 1 2 3) :test '< :key #'1-) 3))

      (test (equal (find-if #'evenp (bag)) nil))
      (test (equal (find-if #'evenp (bag 1)) nil))
      (test (equal (find-if #'evenp (bag 1 1)) nil))
      (test (equal (find-if #'evenp (bag 1 2 3)) 2))
      (test (equal (find-if 'evenp (bag 1 2 3)) 2))
      (test (equal (find-if #'plusp (bag 1 1 2 2 2 3 4) :key (lambda (n) (- n 3))) 4))

      (test (equal (find-if-not #'evenp (bag)) nil))
      (test (equal (find-if-not #'evenp (bag 1)) 1))
      (test (equal (find-if-not #'evenp (bag 2)) nil))
      (test (equal (find-if-not #'evenp (bag 2 2)) nil))
      (test (equal (find-if-not #'evenp (bag 1 1)) 1))
      (test (equal (find-if-not #'evenp (bag 2 3 4)) 3))
      (test (equal (find-if-not 'evenp (bag 2 3 4)) 3))
      (test (equal (find-if-not #'minusp (bag 1 1 2 2 2 3 4) :key (lambda (n) (- n 3))) 3))

      (test (equal (count 1 (bag)) 0))
      (test (equal (count 2 (bag)) 0))
      (test (equal (count 1 (bag 1)) 1))
      (test (equal (count 2 (bag 1)) 0))
      (test (equal (count 2 (bag 2)) 1))
      (test (equal (count 1 (bag 1 1)) 2))
      (test (equal (count 1 (bag 2)) 0))
      (test (equal (count 1 (bag 2 2)) 0))
      (test (equal (count 1 (bag 0 1 1 2 2 2) :test 'equal?) 2))
      (test (equal (count 1 (bag 0 1 1 2 2 2) :test #'equal?) 2))
      (test (equal (count 1 (bag 0 1 1 2) :key #'1+) 1))
      (test (equal (count 2 (bag 0 1 1 2) :key #'1+) 2))
      (test (equal (count 1 (bag 0 1 1 2) :key '1+) 1))
      (test (equal (count 1 (bag 0 0 1 2 2 2 3) :test #'<) 4))
      (test (equal (count 2 (bag 0 0 1 2 2 2 3) :test #'<) 1))
      (test (equal (count 1 (bag 0 0 1 2 2 2 3) :test '<) 4))
      (test (equal (count 1 (bag 0 0 1 2 2 2 3) :test '< :key #'1+) 5))

      (test (equal (count-if #'evenp (bag)) 0))
      (test (equal (count-if #'evenp (bag 1)) 0))
      (test (equal (count-if #'evenp (bag 2)) 1))
      (test (equal (count-if #'evenp (bag 1 2 3) :key #'1+) 2))
      (test (equal (count-if #'evenp (bag 1 2 3) :key '1+) 2))

      (test (equal (count-if-not #'evenp (bag 1 2 2 3 4)) 2))
      (test (equal (count-if-not #'evenp (bag 1 2 2 3 4) :key #'1+) 3))

      (test (less-than? (wb-2-relation (1 1) (1 2)) (wb-custom-2-relation 'erapmoc 'erapmoc (1 1) (1 2))))
      (test (less-than? (ch-2-relation (1 1) (1 2)) (ch-custom-2-relation 'erapmoc 'erapmoc (1 1) (1 2)))))))

(defun Test-Misc-1 ()
  "Tests some things that don't need extensive random test cases generated."
  (macrolet ((test (form)
	       `(unless ,form
		  (error "Test failed: ~S" ',form))))
    (flet ((equal? (a b)
	     (and (equal? a b)
		  (equal? b a))))
      (locally (declare (notinline empty-map empty-wb-map))
	(test (equal (size (empty-map)) 0))
	(test (equal (size (empty-map t)) 0))
	(test (equal (size (empty-wb-map)) 0))
	(test (equal (size (empty-wb-map t)) 0)))
      (test (equal (default (empty-map)) nil))
      (test (equal (default (empty-map 1)) 1))
      (test (empty? (empty-map)))
      (test (empty? (empty-map t)))
      (test (not (empty? (map (1 2)))))

      (let ((m (map (1 3) (2 4))))
	(setf (lookup m 10) 17)
	(test (equal? m (map (1 3) (2 4) (10 17)))))

      (test (equal? (filter #'eql (map (1 2) (2 3) (3 3) (4 5)))
		    (map (3 3))))
      (test (equal? (filter #'eql (ch-map (1 2) (2 3) (3 3) (4 5)))
		    (ch-map (3 3))))
      (test (equal? (filter 'eql (map (1 2) (2 3) (3 3) (4 5)))
		    (map (3 3))))
      (test (equal? (filter 'eql (ch-map (1 2) (2 3) (3 3) (4 5)))
		    (ch-map (3 3))))
      (test (equal? (filter #'eql (map (1 2) (2 3) (3 3) (4 5) :default t))
		    (map (3 3) :default t)))
      (test (equal? (filter #'eql (ch-map (1 2) (2 3) (3 3) (4 5) :default t))
		    (ch-map (3 3) :default t)))

      (test (equal? (image (lambda (k v) (values (1+ k) (+ v 2)))
                           (map (1 2) (2 3) (3 3)))
                    (map (2 4) (3 5) (4 5))))
      (test (equal? (image (lambda (k v) (values (1+ k) (+ v 2)))
                           (ch-map (1 2) (2 3) (3 3)))
                    (ch-map (2 4) (3 5) (4 5))))
      (test (equal? (image #'values (map (1 2) (4 6)))
		    (map (1 2) (4 6))))
      (test (equal? (image #'values (ch-map (1 2) (4 6)))
		    (ch-map (1 2) (4 6))))
      (test (equal? (image 'values (map (1 2) (4 6)))
		    (map (1 2) (4 6))))
      (test (equal? (image 'values (ch-map (1 2) (4 6)))
		    (ch-map (1 2) (4 6))))
      (test (equal? (image #'values (map (1 2) (4 6) :default t))
		    (map (1 2) (4 6) :default t)))
      (test (equal? (image #'values (ch-map (1 2) (4 6) :default t))
		    (ch-map (1 2) (4 6) :default t)))
      (test (equal? (image '+ (map (1 2) (4 6)))
                    (map (3 nil) (10 nil))))
      (test (equal? (image '+ (ch-map (1 2) (4 6)))
                    (ch-map (3 nil) (10 nil))))

      (test (equal (reduce #'+ (map (1 2) (10 18)) :initial-value 0) 31))
      (test (equal (reduce #'+ (map (1 2) (10 18)) :initial-value 17) 48))
      (test (equal (reduce '+ (map (1 2) (10 18)) :initial-value 1) 32))
      (test (equal (reduce '+ (map (1 2) (10 18)) :initial-value 5) 36))
      (test (equal (reduce #'+ (map (1 2) (10 18))
			   :key (lambda (x y) (declare (ignore y)) (values x 0))
			   :initial-value 0)
		   11))
      (test (equal (reduce '+ (map (1 2) (10 18))
			   :key (lambda (x y) (declare (ignore x)) (values 0 y))
			   :initial-value 1)
		   21))
      (test (equal (reduce 'add-to-front (map (1 2) (3 4)) :initial-value nil)
                   '(3 4 1 2)))
      (test (equal (reduce 'add-to-front (map (1 2) (3 4)) :key #'+ :initial-value nil)
                   '(7 nil 3 nil)))
      (test (equal (reduce #'add-to-front (map (1 2) (3 4)) :key '+ :initial-value nil)
                   '(7 nil 3 nil)))
      (test (equal (reduce 'add-to-front (map (1 2) (3 4)) :key '+ :initial-value nil)
                   '(7 nil 3 nil)))
      (test (handler-case (progn (reduce #'cons (map (1 2) (2 4))) nil)
              (simple-program-error (e) e)))
      (test (handler-case (progn (reduce 'cons (map (1 2) (2 4))) nil)
              (simple-program-error (e) e)))

      (test (equal? (range (map (1 3) (2 12))) (set 3 12)))
      (test (equal? (range (ch-map (1 3) (2 12))) (ch-set 3 12)))
      (test (eql (range-contains? (map (4 8) (3 12) (6 7)) 7) t))
      (test (not (range-contains? (map (4 8) (3 12) (6 7)) 4)))

      (test (contains? (map (1 2)) 1 2))
      (test (not (contains? (map (1 2)) 1 3)))
      (test (contains? (map (1 nil)) 1 nil))
      (test (not (contains? (map (2 3)) 1 nil)))
      (test (not (contains? (map (1 2)) 2 2)))
      (test (handler-case (progn (contains? (map (1 2)) 1) nil)
              (simple-program-error () t)))
      (test (contains? (ch-map (1 2)) 1 2))
      (test (not (contains? (ch-map (1 2)) 1 3)))
      (test (contains? (ch-map (1 nil)) 1 nil))
      (test (not (contains? (ch-map (2 3)) 1 nil)))
      (test (not (contains? (ch-map (1 2)) 2 2)))
      (test (handler-case (progn (contains? (ch-map (1 2)) 1) nil)
              (simple-program-error () t)))

      (test (equal? (compose (map (1 2)) (map (2 3)))
		    (map (1 3))))
      (test (equal? (compose (map (1 2) :default 4) (map (4 5) :default 3))
		    (map (1 3) :default 5)))
      (test (equal? (compose (map (1 2) :default 3) #'1+)
		    (map (1 3) :default 4)))
      (test (equal? (compose (map (1 2) :default 3) '1+)
		    (map (1 3) :default 4)))
      (test (equal? (compose (map (0 1) (2 4) :default 3)
			     (seq :a :b :c :d :e :f :g))
		    (map (0 :b) (2 :e) :default :d)))
      (test (equal (default (compose (map (1 2) :default 3)
                                     (map (2 4) :default 5)))
                   5))
      (test (equal (default (compose (map (1 2) :default 3)
                                     (map (2 4) :default nil)))
                   nil))

      (test (equal (default (compose (map (1 2) :default 2)
                                     (map (2 4) :default 5)))
                   4))

      (test (equal (default (compose (map (1 2) :default 2)
                                     (map (2 nil) :default 5)))
                   nil))

      (test (equal? (image (compose #'1+ (map (2 5) (3 7) (4 11) (5 13)))
			   (seq 1 3 4))
		    (seq 5 11 13)))
      (test (equal? (image (compose #'1+ (seq 2 3 5 7 11 13))
			   (seq 1 3 4))
		    (seq 5 11 13)))

      (test (equal? (convert 'map (map (1 2) (4 8) :default 0))
		    (map (1 2) (4 8) :default 0)))
      (test (equal? (convert 'wb-map (map (1 2) (4 8) :default 0))
		    (map (1 2) (4 8) :default 0)))
      (test (equal? (convert 'seq (map (1 3) (2 10) :default 17))
		    (with-default (seq '(1 . 3) '(2 . 10)) 17)))
      (test (equalp (convert 'vector (map (1 3) (2 10) :default 17))
		    #((1 . 3) (2 . 10))))
      (test (equalp (convert 'set (map (1 3) (2 10) :default 17))
		    (set '(1 . 3) '(2 . 10))))
      (test (equal? (convert 'map '((1 . 2) (3 . 4)))
		    (map (1 2) (3 4))))
      (test (equal? (convert 'wb-map '((1 . 2) (3 . 4)))
		    (map (1 2) (3 4))))
      (test (equal? (convert 'map #((1 . 2) (3 . 4)))
		    (map (1 2) (3 4))))
      (test (equal? (convert 'wb-map #((1 . 2) (3 . 4)))
		    (map (1 2) (3 4))))
      (test (equal? (convert 'map (bag 0 2 2 2 3 8 8))
		    (map (0 1) (2 3) (3 1) (8 2))))
      (test (equal? (convert 'wb-map (bag 0 2 2 2 3 8 8))
		    (map (0 1) (2 3) (3 1) (8 2))))
      (test (let ((ht (make-hash-table)))
	      (setf (gethash 1 ht) 2)
	      (setf (gethash 3 ht) 4)
	      (equal? (convert 'map ht) (map (1 2) (3 4)))))
      (test (let ((ht (convert 'hash-table (map (1 2) (3 4)))))
	      (and (eql (gethash 1 ht) 2)
		   (eql (gethash 3 ht) 4)
		   (eql (hash-table-count ht) 2))))
      (test (let ((ht (convert 'hash-table (map ('(1) 2) ('(3) 4)) :test 'equal)))
              (eql (gethash (list 3) ht) 4)))

      (test (equal? (map-union (map (0 50) (1 88))
			       (map (0 51) (1 97))
			       (fn (x y) (if (equal? (1+ x) y) (values nil ':no-value) y)))
		    (map (1 97))))
      (test (equal? (map-union (map (0 50) (1 88))
			       (map (0 51) (2 104))
			       (fn (x y) (if (equal? (1+ x) y) (values nil ':no-value) y)))
		    (map (1 88) (2 104))))
      (test (equal? (gmap (:result map-union :val-fn (fn (x y) (if (equal? (1+ x) y) (values nil ':no-value) y)))
			  nil
			  (:arg seq (seq (map ((make-my-integer 0) 32) ((make-my-integer 1) 77))
					 (map ((make-my-integer 0) 33) ((make-my-integer 1) 92)))))
		    (map ((make-my-integer 1) 92))))
      (test (equal? (map-union (map ((make-my-integer 0) 32) ((make-my-integer 1) 55))
			       (map ((make-my-integer 0) 33) ((make-my-integer 2) 84))
			       (fn (x y) (if (equal? (1+ x) y) (values nil ':no-value) y)))
		    (map ((make-my-integer 1) 55) ((make-my-integer 2) 84))))
      (test (equal? (map-union (map ((make-my-integer 0) 32) ((make-my-integer 1) 56))
			       (map ((make-my-integer 0) 34) ((make-my-integer 2) 88))
			       (fn (x y) (if (equal? (1+ x) y) (values nil ':no-value) y)))
		    (map ((make-my-integer 0) 34) ((make-my-integer 1) 56) ((make-my-integer 2) 88))))
      (test (equal? (map-union (map ((make-my-integer 0) 32) ((make-my-integer 2) 47))
			       (map ((make-my-integer 0) 33) ((make-my-integer 1) 23))
			       (fn (x y) (if (equal? (1+ x) y) (values nil ':no-value) y)))
		    (map ((make-my-integer 1) 23) ((make-my-integer 2) 47))))
      (test (equal? (map-union (map ((make-my-integer 0) 33) ((make-my-integer 2) 28))
			       (map ((make-my-integer 0) 32) ((make-my-integer 1) 19))
			       (fn (x y) (if (equal? (1+ x) y) (values nil ':no-value) y)))
		    (map ((make-my-integer 0) 32) ((make-my-integer 1) 19) ((make-my-integer 2) 28))))
      (test (equal? (map-union (map ((make-my-integer 0) 16) ((make-my-integer 2) 44))
			       (map ((make-my-integer 0) 17) ((make-my-integer 2) 67))
			       (fn (x y) (if (equal? (1+ x) y) (values nil ':no-value) y)))
		    (map ((make-my-integer 2) 67))))
      (let ((m1 (gmap (:result map) (fn (x) (values (make-my-integer (* x 2)) x)) (:arg index -8 8)))
	    (m2 (gmap (:result map) (fn (x) (values (make-my-integer (* x 2)) (1+ x))) (:arg index -8 8))))
	(test (equal? (map-union m1 m2
				 (fn (x y) (if (equal? (1+ x) y) (values nil ':no-value) y)))
		      (map)))
	(test (equal? (map-union m1 (with m2 (make-my-integer 0) 99)
				 (fn (x y) (if (equal? (1+ x) y) (values nil ':no-value) y)))
		      (map ((make-my-integer 0) 99)))))

      (test (equal? (map-intersection (map ((make-my-integer 0) 16) ((make-my-integer 1) 44))
				      (map ((make-my-integer 0) 16) ((make-my-integer 1) 72))
				      (fn (x y) (if (equal? x y) x (values nil ':no-value))))
		    (map ((make-my-integer 0) 16))))
      (test (equal? (gmap (:result map-intersection :val-fn (fn (x y) (if (equal? x y) x (values nil ':no-value))))
			  #'identity
			  (:arg seq (seq (map ((make-my-integer 0) 17) ((make-my-integer 1) 44))
					 (map ((make-my-integer 0) 17) ((make-my-integer 2) 72)))))
		    (map ((make-my-integer 0) 17))))
      (test (equal? (map-intersection (map ((make-my-integer 0) 15) ((make-my-integer 1) 44))
				      (map ((make-my-integer 0) 17) ((make-my-integer 2) 72))
				      (fn (x y) (if (equal? x y) x (values nil ':no-value))))
		    (map)))
      (test (equal? (map-intersection (map ((make-my-integer 0) 17) ((make-my-integer 2) 71))
				      (map ((make-my-integer 0) 17) ((make-my-integer 1) 44))
				      (fn (x y) (if (equal? x y) x (values nil ':no-value))))
		    (map ((make-my-integer 0) 17))))
      (test (equal? (map-intersection (map ((make-my-integer 0) 17) ((make-my-integer 2) 72))
				      (map ((make-my-integer 0) 15) ((make-my-integer 1) 44))
				      (fn (x y) (if (equal? x y) x (values nil ':no-value))))
		    (map)))
      (let ((m (gmap (:result map) (fn (x) (values (make-my-integer (* x 2)) x)) (:arg index -8 8))))
	(test (equal? (map-intersection m (with m (make-my-integer 0) 99)
					(fn (x y) (if (equal? x y) x (values nil ':no-value))))
		      (less m (make-my-integer 0))))
	(test (equal? (map-intersection (with m (make-my-integer 0) 99) (with m (make-my-integer 0) 99)
					(fn (x y) (if (equal? x y) x (values nil ':no-value))))
		      (with m (make-my-integer 0) 99))))

      (test (equal (multiple-value-list (find 1 (map))) '(nil nil)))
      (test (equal (multiple-value-list (find 1 (map (1 3)))) '(1 3)))
      (test (equal (multiple-value-list (find 2 (map (2 3)))) '(2 3)))
      (test (equal (multiple-value-list (find 1 (map (1 3) (2 5)) :test #'<)) '(2 5)))
      (test (equal (multiple-value-list (find 10 (map (1 3) (2 5)) :test #'<)) '(nil)))
      (test (equal (multiple-value-list (find 1 (map (1 3) (2 5)) :key #'1-)) '(2 5)))
      (test (equal (multiple-value-list (find 10 (map (1 3) (2 5)) :key #'1-)) '(nil)))
      (test (equal (multiple-value-list (find 1 (map (1 3) (2 5) (3 6)) :test #'> :key #'1-)) '(1 3)))
      (test (equal (multiple-value-list (find 10 (map (1 3) (2 5) (3 6)) :test #'= :key #'1-)) '(nil)))
      (test (equal (multiple-value-list (find 1 (map (1 3) (2 5) (3 6)) :test #'< :key #'1-)) '(3 6)))

      (test (equal (multiple-value-list (find 5 (map (5 nil)))) '(5 nil)))
      (test (equal (multiple-value-list (find 4 (map (5 nil)) :key #'1-)) '(5 nil)))

      (test (equal (multiple-value-list (find-if #'evenp (map))) '(nil)))
      (test (equal (multiple-value-list (find-if #'evenp (map (1 2)))) '(nil)))
      (test (equal (multiple-value-list (find-if #'evenp (map (1 2) (2 3)))) '(2 3)))
      (test (equal (multiple-value-list (find-if #'evenp (map (1 2) (2 3)) :key 'identity)) '(2 3)))
      (test (equal (multiple-value-list (find-if #'evenp (map (1 2) (2 3)) :key '1-)) '(1 2)))

      (test (equal (multiple-value-list (find-if-not #'evenp (map))) '(nil)))
      (test (equal (multiple-value-list (find-if-not #'evenp (map (0 3) (1 7)))) '(1 7)))
      (test (equal (multiple-value-list (find-if-not 'evenp (map (1 4) (2 19) (3 21)) :key '1+)) '(2 19)))

      (test (equal (count 1 (map)) 0))
      (test (equal (count 2 (map (0 2) (1 3) (2 5) (3 2))) 1))
      (test (equal (count 2 (map (0 2) (1 3) (2 5) (3 2) :default 2)) 1))
      (test (equal (count 2 (map (0 2) (1 3) (2 5) (3 2)) :key (constantly 2)) 4))
      (test (equal (count 2 (map (0 2) (1 3) (2 5) (3 2)) :key (constantly 3)) 0))
      (test (equal (count 2 (map (0 2) (1 3) (2 5) (3 2)) :test #'equal?) 1))
      (test (equal (count 2 (map (0 2) (1 3) (2 5) (3 2)) :test 'equal?) 1))
      (test (equal (count 2 (map (45 2) (12 3) (2 5) (19 2)) :test 'equal?) 1))
      (test (equal (count 2 (map (0 2) (1 3) (2 5) (3 2)) :test #'>=) 3))
      (test (equal (count 2 (map (0 2) (1 3) (2 5) (3 2)) :key #'1+ :test #'>=) 2))
      (test (equal (count 17 (map (17 23)) :key #'identity) 1))

      (test (equal (count-if #'evenp (map (1 5) (2 7) (3 9))) 1))
      (test (equal (count-if #'evenp (map (1 5) (2 7) (4 12) (3 9))) 2))
      (test (equal (count-if #'evenp (map (1 5) (2 7) (3 9)) :key #'1+) 2))
      (test (equal (count-if #'evenp (map (1 5) (2 7) (3 9) (5 17)) :key #'1+) 3))
      (test (equal (count-if-not #'evenp (map (1 5) (2 7) (3 9))) 2))
      (test (equal (count-if-not #'evenp (map (1 5) (2 7) (3 9)) :key #'1+) 1))

      (let ((ls '(0 1 2 3 4 5 6 7 8 9)))
	(test (equal (@ ls 'first) 0))
	(test (equal (with ls 'first 10) '(10 1 2 3 4 5 6 7 8 9)))
	(test (equal (@ ls 'cl:first) 0))
	(test (equal (with ls 'cl:first 10) '(10 1 2 3 4 5 6 7 8 9)))
	(test (equal (@ ls 'second) 1))
	(test (equal (with ls 'second 11) '(0 11 2 3 4 5 6 7 8 9)))
	(test (equal (@ ls 'third) 2))
	(test (equal (with ls 'third 12) '(0 1 12 3 4 5 6 7 8 9)))
	(test (equal (@ ls 'fourth) 3))
	(test (equal (with ls 'fourth 13) '(0 1 2 13 4 5 6 7 8 9)))
	(test (equal (@ ls 'fifth) 4))
	(test (equal (with ls 'fifth 14) '(0 1 2 3 14 5 6 7 8 9)))
	(test (equal (@ ls 'sixth) 5))
	(test (equal (with ls 'sixth 15) '(0 1 2 3 4 15 6 7 8 9)))
	(test (equal (@ ls 'seventh) 6))
	(test (equal (with ls 'seventh 16) '(0 1 2 3 4 5 16 7 8 9)))
	(test (equal (@ ls 'eighth) 7))
	(test (equal (with ls 'eighth 17) '(0 1 2 3 4 5 6 17 8 9)))
	(test (equal (@ ls 'ninth) 8))
	(test (equal (with ls 'ninth 18) '(0 1 2 3 4 5 6 7 18 9)))
	(test (equal (@ ls 'tenth) 9))
	(test (equal (with ls 'tenth 19) '(0 1 2 3 4 5 6 7 8 19)))))))

(defun Test-Misc-2 ()
  "Tests some things that don't need extensive random test cases generated."
  (declare (optimize (debug 3)))
  (macrolet ((test (form)
	       `(unless ,form
		  (error "Test failed: ~S" ',form))))
    (flet ((equal? (a b)
	     (and (equal? a b)
		  (equal? b a))))
      (locally (declare (notinline empty-seq empty-wb-seq))
	(test (equal (size (empty-seq)) 0))
	(test (empty? (empty-seq)))
	(test (equal (size (empty-seq t)) 0))
	(test (empty? (empty-wb-seq)))
	(test (equal (size (empty-wb-seq)) 0)))

      (test (equal (default (empty-seq 1)) 1))
      (test (equal (default (with-default (seq 1 2) 17)) 17))

      (test (equal (multiple-value-list (lookup (seq 1 2) 0)) '(1 t)))
      (test (equal (multiple-value-list (lookup (seq 1 2) 1)) '(2 t)))
      (test (equal (multiple-value-list (lookup (seq 1 2) 2)) '(nil nil)))
      (test (equal (multiple-value-list (lookup (with-default (seq 1 2) 17) 2)) '(17 nil)))
      (test (equal (multiple-value-list (lookup (seq 1 2 3) (1+ most-positive-fixnum)))
		   '(nil nil)))
      (test (equal (multiple-value-list (first (seq))) '(nil nil)))
      (test (equal (multiple-value-list (first (empty-seq 17))) '(17 nil)))
      (test (equal (multiple-value-list (first (seq 1))) '(1 t)))
      (test (equal (multiple-value-list (first (seq 1 2))) '(1 t)))
      (test (equal (multiple-value-list (last (seq))) '(nil nil)))
      (test (equal (multiple-value-list (last (empty-seq 17))) '(17 nil)))
      (test (equal (multiple-value-list (last (seq 1))) '(1 t)))
      (test (equal (multiple-value-list (last (seq 1 2))) '(2 t)))

      (test (equal (find 0 (seq 2 5 0 6 7)) 0))
      (test (equal (find 'x (seq)) nil))
      (test (equal (find 'x (with-default (seq) 'x)) nil))
      (test (equal (find 'x (seq 'x)) 'x))
      (test (equal (find 5 (seq 2 5 0 6 7)) 5))
      (test (equal (find 3 (seq 0 2 5 4 8) :test (lambda (a b) (<= (abs (- a b)) 1))) 2))
      (test (equal (find 3 (seq 0 2 5 4 8) :start 1 :end 4
                         :test (lambda (a b) (<= (abs (- a b)) 1)))
                   2))
      (test (equal (find 3 (seq 0 2 5 4 8) :from-end t
                         :test (lambda (a b) (<= (abs (- a b)) 1)))
                   4))
      (test (equal (find 3 (seq 0 2 5 4 8) :from-end t
                         :start 1 :end 4
                         :test (lambda (a b) (<= (abs (- a b)) 1)))
                   4))
      (test (equal (find 10 (seq 1 2 3) :from-end t) nil))
      (test (equal (find 10 (seq 1 2 3) :from-end t :key #'1+) nil))
      (test (equal (find 5 (seq 5 1 2 3 4 3) :from-end t :key #'1+ :test #'<=) 4))
      (test (equal (find 10 (seq 1 2 3) :test #'eql) nil))
      (test (equal (find 10 (seq 1 2 3) :start 0) nil))
      (test (equal (find 10 (seq 1 2 3) :end 3) nil))
      (test (equal (find 10 (seq 1 2 3) :key #'1+) nil))
      (test (equal (find 10 (seq 1 2 3) :key #'1+ :start 0) nil))
      (test (equal (find 10 (seq 1 2 3) :key #'1+ :end 3) nil))
      (let* ((s1 "x") (s2 (copy-seq s1)))
        (test (eql (find s1 (seq s1 s2)) s1))
        (test (eql (find s1 (seq s1 s2) :start 1) s2))
        (test (eql (find s1 (seq s1 s2) :from-end t) s2))
        (test (eql (find s1 (seq s1 s2) :from-end t :end 1) s1)))

      (test (equal (find-if #'evenp (seq 0)) 0))
      (test (equal (find-if #'evenp (seq 1 3 4 7 8)) 4))
      (test (equal (find-if #'evenp (seq 1 3 4 7 8) :from-end t) 8))
      (test (equal (find-if #'evenp (seq 1 3 4 7 8) :start 3) 8))
      (test (equal (find-if #'evenp (seq 1 3 4 7 8) :end 2) nil))
      (test (equal (find-if #'evenp (seq 2 4 5 8 9) :key #'1+) 5))
      (test (equal (find-if #'evenp (seq 2 4 5 8 9 10) :key '1+ :from-end t) 9))
      (test (equal (find-if #'evenp (seq 2 4 5 6 7 8) :start 2 :key '1+) 5))
      (test (equal (find-if #'evenp (seq 2 4 5 6 7 8) :start 3 :key '1+) 7))

      (test (equal (find-if-not #'evenp (seq 2 4 5 8 9)) 5))
      (test (equal (find-if-not #'evenp (seq 2 3 4 5 8 9) :start 2) 5))
      (test (equal (find-if-not #'evenp (seq 2 4 6 8 9 10) :end 4) nil))
      (test (equal (find-if-not #'evenp (seq 2 4 6 8 9 10) :start 1 :end 4) nil))
      (test (equal (find-if-not #'evenp (seq 1 2 3 4 5 6) :from-end t) 5))
      (test (equal (find-if-not #'evenp (seq 1 2 3 4 5 6) :end 4 :from-end t) 3))

      (test (equal (find-if-not #'evenp (seq 1 2 3 4) :key '1+) 2))
      (test (equal (find-if-not #'evenp (seq 1 2 3 4) :key '1+ :from-end t) 4))

      (test (equal (count 0 (seq 0 1 2 0 3 0 4 5 4)) 3))
      (test (equal (count 0 (seq 0 1 2 0 3 0 4 5 4) :test #'equal?) 3))
      (test (equal (count 0 (seq 0 1 2 0 3 0 4 5 4) :test 'equal?) 3))
      (test (equal (count 0 (seq 0 1 2 0 3 0 4 5 4)) 3))
      (test (equal (count 0 (seq 0 1 2 0 3 0 4 5 4) :start 1) 2))
      (test (equal (count 0 (seq 0 1 2 0 3 0 4 5 4) :end 4) 2))
      (test (equal (count 0 (seq 0 1 2 0 3 0 4 5 4) :start 1 :end 4) 1))
      (test (equal (count 1 (seq 0 1 2 0 3 0 4 5 4) :key #'1+) 3))
      (test (equal (count 2 (seq 0 1 2 0 3 0 4 5 4) :key #'1+ :test #'<) 5))
      (test (equal (let ((i 0))
                     (count 5 (seq 0 1 2 1 2 4 5 6 7 8)
                            :key (lambda (x) (+ x (incf i)))))
                   2))
      (test (equal (let ((i 1))
                     (count 5 (seq 0 1 2 1 2 4 5 6 7 8)
                            :start 1
                            :key (lambda (x) (+ x (incf i)))))
                   2))
      (test (equal (let ((i 0))
                     (count 5 (seq 0 1 2 1 2 4 5 6 7 8)
                            :end 6
                            :key (lambda (x) (+ x (incf i)))))
                   2))
      (test (equal (let ((i 0))
                     (count 9 (seq 0 1 2 1 2 4 5 6 7 8)
                            :from-end t
                            :key (lambda (x) (+ x (incf i)))))
                   5))
      (test (equal (let ((i 0))
                     (count 9 (seq 0 1 2 1 2 4 5 6 7 8)
                            :start 6 :from-end t
                            :key (lambda (x) (+ x (incf i)))))
                   4))
      (test (equal (let ((i 0))
                     (count 8 (seq 0 1 2 1 2 4 5 6 7 8)
                            :end 9 :from-end t
                            :key (lambda (x) (+ x (incf i)))))
                   4))

      (test (equal (let ((i 0))
                     (count 1 (seq 0 1)
                            :test (lambda (x y)
                                    (= x (+ (incf i) y)))))
                   1))
      (test (equal (let ((i 0))
                     (count 1 (seq 0 1)
                            :from-end t
                            :test (lambda (x y)
                                    (= x (+ (incf i) y)))))
                   0))

      (test (equal (count-if #'evenp (seq 3 2 1 1 5 4 8 9)) 3))
      (test (equal (count-if #'evenp (seq 3 2 1 1 5 4 8 9) :from-end t) 3))
      (test (equal (count-if #'evenp (seq 3 2 1 1 5 4 8 9) :start 2) 2))
      (test (equal (count-if #'evenp (seq 3 2 1 1 5 4 8 9) :end 4) 1))
      (test (equal (count-if #'evenp (seq 3 2 1 1 5 4 8 9) :start 2 :end 4) 0))
      (test (equal (count-if #'evenp (seq 3 2 1 1 5 4 8 9) :key #'1+) 5))
      (test (equal (count-if #'evenp (seq 1 2 3) :key #'1+ :from-end t) 2))
      (test (equal (let ((i 0))
                     (count-if (lambda (x) (> x 4))
                               (seq 0 1 2 3 4 5)
                               :key (lambda (x) (+ x (incf i)))))
                   4))
      (test (equal (let ((i 0))
                     (count-if (lambda (x) (> x 4))
                               (seq 0 1 2 3 4 5)
                               :start 2
                               :key (lambda (x) (+ x (incf i)))))
                   3))
      (test (equal (let ((i 0))
                     (count-if (lambda (x) (> x 4))
                               (seq 0 1 2 3 4 5)
                               :end 4
                               :key (lambda (x) (+ x (incf i)))))
                   2))
      (test (equal (let ((i 0))
                     (count-if (lambda (x) (> x 4))
                               (seq 0 1 2 3 4 5)
                               :from-end t
                               :key (lambda (x) (+ x (incf i)))))
                   6))
      (test (equal (let ((i 0))
                     (count-if (lambda (x) (> (+ x (incf i)) 4))
                               (seq 0 1 2 3 4 5)))
                   4))
      (test (equal (let ((i 0))
                     (count-if (lambda (x) (> (+ x (incf i)) 4))
                               (seq 0 1 2 3 4 5)
                               :from-end t))
                   6))

      (test (equal (count-if-not #'evenp (seq 3 2 1 1 5 4 8 9)) 5))
      (test (equal (count-if-not #'evenp (seq 3 2 1 1 5 4 8 9) :key #'1+) 3))
      (test (equal (count-if-not #'evenp (seq 1 2 3 1 7 9 4 1) :start 1) 5))
      (test (equal (count-if-not #'evenp (seq 1 2 3 1 7 9 4 1 1) :end 7) 5))
      (test (equal (let ((i 0))
                     (count-if-not (lambda (x) (> (+ x (incf i)) 5))
                                   (seq 0 1 2 3 4 5 6)))
                   3))
      (test (equal (let ((i 0))
                     (count-if-not (lambda (x) (> (+ x (incf i)) 5))
                                   (seq 0 1 2 3 4 5 6)
                                   :from-end t))
                   0))

      (test (equal (position 0 (seq)) nil))
      (test (equal (position 1 (seq 1)) 0))
      (test (equal (position 1 (seq 1 1)) 0))
      (test (equal (position 1 (seq 1 1) :from-end t) 1))
      (test (equal (position 1 (seq 0 1 2) :key #'1-) 2))
      (test (equal (position 3 (seq 0 2 5 6) :test #'<) 2))
      (test (equal (position 3 (seq 0 2 5 6) :test #'<= :key #'1+) 1))
      (test (equal (position :x (seq :a :b :x :c) :test 'equal?) 2))
      (test (equal (position :x (seq :a :b :x :c) :test #'equal?) 2))

      (test (eql (first '(1 2)) 1))
      (test (eql (first #(1 2)) 1))
      (test (eql (last '(1 2)) 2))
      (test (eql (last #(1 2)) 2))
      (test (eql (first "abc") #\a))
      (test (eql (last "abc") #\c))
      (test (equal? (subseq '(0 1 2 3) 1 3) '(1 2)))
      (test (equal? (subseq #(0 1 2 3) 1 3) #(1 2)))
      (test (equal? (subseq "abcd" 1 3) "bc"))
      (test (equal? (reverse '(0 1 2 3)) '(3 2 1 0)))
      (test (equal? (reverse #(0 1 2 3)) #(3 2 1 0)))
      (test (equal? (reverse "abcd") "dcba"))
      (let ((x (list 3 1 2)))
	(test (equal? (sort x #'<) '(1 2 3)))
	;; fset::sort is nondestructive
	(test (equal? x '(3 1 2))))
      (let ((x (list 3 1 2)))
	(test (equal? (stable-sort x #'<) '(1 2 3)))
	;; fset::stable-sort is nondestructive
	(test (equal? x '(3 1 2))))
      (dolist (v (list '(3 5)
		       #(3 5)
		       (make-array '(2) :initial-contents '(3 5)
				   :adjustable t)
		       #+sbcl
		       (make-instance 'my-sequence :actual '(3 5))))
	(let ((it (iterator v)))
	  (test (equal (mapcar (lambda (v)
				 (multiple-value-bind (x y)
				     (funcall it v)
				   (if (eql v :get) (list x y) (not (not x)))))
			       '(:done? :more? :get :done? :more? :get :done? :more? :get))
		       '(nil t (3 t) nil t (5 t) t nil (nil nil))))))
      (dolist (s (list "ab"
		       (make-array '(2) :element-type 'base-char
				      :adjustable t :initial-contents '(#\a #\b))))
	(let ((it (iterator s)))
	  (test (equal (mapcar (lambda (v)
				 (multiple-value-bind (x y)
				     (funcall it v)
				   (if (eql v :get) (list x y) (not (not x)))))
			       '(:done? :more? :get :done? :more? :get :done? :more? :get))
		       '(nil t (#\a t) nil t (#\b t) t nil (nil nil))))))

      (test (let ((it (iterator (make-array '(0) :element-type t))))
              (equal (multiple-value-list (funcall it :get)) '(nil nil))))
      (test (let ((it (iterator (make-array '(0) :element-type 'character))))
              (equal (multiple-value-list (funcall it :get)) '(nil nil))))
      (test (let ((it (iterator (make-array '(0) :element-type 'base-char))))
              (equal (multiple-value-list (funcall it :get)) '(nil nil))))

      (test (equal (find-if #'evenp '(1 2 3)) 2))
      (test (equal (find-if #'evenp '(1 2 3 4 5 6 7) :start 2) 4))
      (test (equal (find-if #'evenp '(1 2 3 4 5 6 7) :from-end t) 6))
      (test (equal (find-if #'evenp '(1 2 3 4 5 6 7) :from-end t :end 2) 2))
      (test (equal (find-if #'evenp '(1 2 3 4 5 6 7)
                            :from-end t :end 4)
                   4))
      (test (equal (find-if #'evenp '(1 2 3 4 5 6 7)
                            :start 2 :end 3)
                   nil))
      (test (equal (find-if-not #'evenp '(1 2 3)) 1))
      (test (equal (find-if-not #'evenp '(1 2 3) :start 1) 3))
      (test (equal (find-if-not #'evenp '(1 2 3) :from-end t) 3))
      (test (equal (find-if-not #'evenp '(1 2 3 4 5) :from-end t :end 4) 3))
      (test (equal (find-if-not #'evenp '(1 2 3) :start 1 :end 1) nil))

      (test (equal (count 1 '(1 2 3 1 4 2 1 0)) 3))
      (test (equal (count 1 '(1 2 3 1 4 2 1 0) :start 4) 1))
      (test (equal (count 1 '(1 2 3 1 4 2 1 0) :end 4) 2))
      (test (equal (count 1 '()) 0))
      (test (equal (count 1 '(1 2 3 2 5 6) :key #'1-) 2))
      (test (equal (count 3 '(1 2 3 2 5 6) :test '>=) 4))
      (test (equal (count 3 '(1 2 3 2 5 6) :test #'<) 2))
      (test (equal (count 3 '(1 2 3 2 5 6) :test-not '>=) 2))
      (test (equal (count 3 '(1 2 3 2 5 6) :test-not #'<) 4))
      (test (equal
             (let ((i 0))
               (count 0 '(1 2 4 4 7 6 8) :test #'(lambda (x y) (= (+ x (incf i)) y))))
             4))
      (test (equal
             (let ((i 0))
               (count 0 (reverse '(1 2 4 4 7 6 8)) :test #'(lambda (x y) (= (+ x (incf i)) y))
                      :from-end t))
             4))

      (test (equal (count-if #'oddp '(1 2 3 4 5)) 3))
      (test (equal (count-if #'oddp '(1 2 3 4 5 6 7) :start 2) 3))
      (test (equal (count-if #'oddp '(1 2 3 4 5 6 7) :start 3) 2))
      (test (equal (count-if #'oddp '(1 2 3 4 5 6 7) :end 4) 2))
      (test (equal (count-if #'oddp '(1 2 3 4 5 6 7) :start 1 :end 4) 1))
      (test (equal (count-if #'oddp '(1 2 3 4 5) :key #'1+) 2))
      (test (equal (let ((i 0))
                     (count-if #'(lambda (x) (> x 4))
                               '(0 1 0 1 -1 0 -2 0)
                               :key (lambda (x)
                                      (+ x (incf i)))))
                   4))
      (test (equal (let ((i 0))
                     (count-if #'(lambda (x) (> x 4))
                               '(0 1 0 1 1 -1 0 -2 0)
                               :from-end t
                               :key (lambda (x)
                                      (+ x (incf i)))))
                   5))
      (test (equal (let ((i 0))
                     (count-if #'(lambda (x) (> x 4))
                               '(0 1 0 1 -1 0 -2 0)
                               :start 2
                               :key (lambda (x)
                                      (+ x (incf i)))))
                   1))
      (test (equal (let ((i 0))
                     (count-if #'(lambda (x) (> x 4))
                               '(0 1 0 1 -1 0 -2 0)
                               :start 2 :from-end t
                               :key (lambda (x)
                                      (+ x (incf i)))))
                   2))
      (test (equal (let ((i 0))
                     (count-if #'(lambda (x) (> x 4))
                               '(0 1 0 1 -1 0 -2 0)
                               :end 7
                               :key (lambda (x)
                                      (+ x (incf i)))))
                   3))
      (test (equal (count-if-not #'oddp '(1 2 3 4 5)) 2))
      (test (equal (count-if-not #'oddp '(1 2 3 4 5) :start 2) 1))
      (test (equal (count-if-not #'evenp '(1 2 3 4 5 6 7) :start 2) 3))
      (test (equal (count-if-not #'evenp '(1 2 3 4 5 6 7) :start 3) 2))
      (test (equal (count-if-not #'evenp '(1 2 3 4 5 6 7) :end 4) 2))
      (test (equal (count-if-not #'evenp '(1 2 3 4 5 6 7) :start 1 :end 4) 1))
      (test (equal (count-if-not #'evenp '(1 2 3 4 5) :key #'1+) 2))
      (test (equal (let ((i 0))
                     (count-if-not #'(lambda (x) (<= x 4))
                                   '(0 1 0 1 -1 0 -2 0)
                                   :key (lambda (x)
                                          (+ x (incf i)))))
                   4))
      (test (equal (let ((i 0))
                     (count-if-not #'(lambda (x) (<= x 4))
                                   '(0 1 0 1 1 -1 0 -2 0)
                                   :from-end t
                                   :key (lambda (x)
                                          (+ x (incf i)))))
                   5))
      (test (equal (let ((i 0))
                     (count-if-not #'(lambda (x) (<= x 4))
                                   '(0 1 0 1 -1 0 -2 0)
                                   :start 2
                                   :key (lambda (x)
                                          (+ x (incf i)))))
                   1))
      (test (equal (let ((i 0))
                     (count-if-not #'(lambda (x) (<= x 4))
                                   '(0 1 0 1 -1 0 -2 0)
                                   :start 2 :from-end t
                                   :key (lambda (x)
                                          (+ x (incf i)))))
                   2))
      (test (equal (let ((i 0))
                     (count-if-not #'(lambda (x) (<= x 4))
                                   '(0 1 0 1 -1 0 -2 0)
                                   :end 7
                                   :key (lambda (x)
                                          (+ x (incf i)))))
                   3))

      (test (equal (position :x '(:a :b :x c)) 2))
      (test (equal (position :x '(:a :b :x c :x d) :from-end t) 4))
      (test (equal (position-if #'evenp '(1 3 5 2 0 7 4)) 3))
      (test (equal (position-if #'evenp '(1 3 5 2 0 7 4) :from-end t) 6))
      (test (equal (position-if-not #'oddp '(1 3 5 2 0 7 4)) 3))
      (test (equal (position-if-not #'oddp '(1 3 5 2 0 7 4) :from-end t) 6))
      (test (equal (substitute :y :x '(:a :b :x :c :y :z :x :d))
		   '(:a :b :y :c :y :z :y :d)))
      (test (equal (substitute-if 0 #'evenp  '(1 2 3 3 4 1 6 9))
		   '(1 0 3 3 0 1 0 9)))
      (test (equal (substitute-if-not 0 #'oddp  '(1 2 3 3 4 1 6 9))
		   '(1 0 3 3 0 1 0 9)))
      (test (some #'evenp '(1 2 3)))
      (test (not (notany #'evenp '(1 2 3))))
      (test (notany #'evenp #(1 3 5)))
      (test (some #'evenp (set 1 3 6 5)))
      (test (notany #'evenp (set 1 3 5)))
      (test (notany #'identity (set)))
      (test (notany #'= '(1 1) (set 2)))

      (test (every #'= '(1 2 3) '(1 2 3)))
      (test (not (notevery #'= '(1 2 3) '(1 2 3))))
      (test (every #'= '(1 2) '(1 2 3)))
      (test (every #'= '(1 2 3) '(1 2)))
      (test (every #'= '(1 2) (set)))
      (test (every #'= (set) '(1 2)))
      (test (notevery #'= '(1 2 3) (set 1 2 4)))
      (test (notevery #'= '(1 2 3) '(1 2 4)))

      (test (equal (sort (copy-list (union '(1 2) '(1 3))) #'<) '(1 2 3)))
      (test (equal (length (union '(1) '(2) :test (constantly t))) 1))
      (test (equal (sort (copy-list (union '(1 2) '(1 3) :test #'=)) #'<) '(1 2 3)))
      (test (equal (sort (copy-list (union '(1 2) '(1 3) :test-not #'/=)) #'<) '(1 2 3)))
      (test (equal (sort (copy-list (intersection '(0 1 2 3 5) '(6 3 7 1 9 2 8))) #'<) '(1 2 3)))
      (test (equal (intersection '(0 1 2) '(1 2 3 4) :test (lambda (x y) (and (eql x y) (> x 1))))
                   '(2)))
      (test (equal (intersection '(0 1 2) '(1 2 3 4) :test-not (lambda (x y) (not (and (eql x y) (> x 1)))))
                   '(2)))
      (test (equal (sort (copy-list (set-difference '(1 2 3 4 5) '(4 2 8 0))) #'<)
                   '(1 3 5)))
      (test (equal (sort (copy-list
                          (set-difference '(1 2 3 4 5) '(4 2 8 0)
                                          :test (lambda (x y) (and (eql x y) (> x 3)))))
                         #'<)
                   '(1 2 3 5)))
      (test (equal (sort (copy-list
                          (set-difference '(1 2 3 4 5) '(4 2 8 0)
                                          :test-not (lambda (x y) (not (and (eql x y)  (> x 3))))))
                         #'<)
                   '(1 2 3 5)))

      (test (equal (concat '(1 2 3) '(4 5 6)) '(1 2 3 4 5 6)))
      (test (equal (concat () '(1 2 3) '(4 5 6)) '(1 2 3 4 5 6)))
      (test (equal (concat () '(1 2) '(3) '(4 5 6)) '(1 2 3 4 5 6)))
      (test (equal (concat '(1 2 3) (seq 4 5 6)) '(1 2 3 4 5 6)))
      (test (equal (convert 'list '(1 2 3)) '(1 2 3)))
      (test (equalp (convert 'vector #(1 2 3)) #(1 2 3)))

      (test (equal? (default (concat (with-default (seq 'a 'b) 'x)
                                     (with-default (seq 'c 'd) 'y)))
                    'x))

      (test (equal (multiple-value-list (partition 'evenp '(1 2 3 4 5)))
		   '((2 4) (1 3 5))))
      (locally (declare (notinline lastcons head tail))
	(let* ((lc (list 3))
	       (l (cons 1 (cons 2 lc))))
	  (test (eq (lastcons l) lc))
	  (test (eql (head l) 1))
	  (test (eq (tail (tail l)) lc))))
      (test (equal? (compose (map (1 2) (2 6)) (lambda (x) (when x (1+ x))))
		    (map (1 3) (2 7))))
      (test (equal? (split-from (set 0 1 2) 1) (set 1 2)))
      (test (equal? (split-from (set 0 2 4) 1) (set 2 4)))
      (test (equal? (split-above (set 0 23 7 4 19) 7) (set 19 23)))
      (test (equal? (split-above (set 0 23 7 4 19) 6) (set 7 19 23)))
      (test (equal? (split-through (set 0 3 5 8 10) 5) (set 0 3 5)))
      (test (equal? (split-through (set 0 3 5 8 10) 6) (set 0 3 5)))
      (test (equal? (split-through (set 0 3 5 8 10) 20) (set 0 3 5 8 10)))
      (test (equal? (split-below (set 7 3 1 2) 4) (set 1 2 3)))
      (test (equal? (split-below (set 7 3 1 2) 3) (set 1 2)))

      (test (equal? (split-from (bag 0 1 1 2 2) 1) (bag 1 1 2 2)))
      (test (equal? (split-from (bag 0 0 2 4 4) 1) (bag 2 4 4)))
      (test (equal? (split-above (bag 0 23 7 4 19 19) 7) (bag 19 19 23)))
      (test (equal? (split-above (bag 0 23 23 7 4 19) 6) (bag 7 19 23 23)))
      (test (equal? (split-through (bag 0 3 3 5 5 8 10) 5) (bag 0 3 3 5 5)))
      (test (equal? (split-through (bag 0 0 3 5 5 8 10) 6) (bag 0 0 3 5 5)))
      (test (equal? (split-through (bag 0 3 3 5 8 8 10) 20) (bag 0 3 3 5 8 8 10)))
      (test (equal? (split-below (bag 7 3 1 1 1 2) 4) (bag 1 1 1 2 3)))
      (test (equal? (split-below (bag 7 3 1 1 1 2) 3) (bag 1 1 1 2)))

      (test (equal? (split-from (map (0 'a) (1 'w) (2 'e)) 1) (map (1 'w) (2 'e))))
      (test (equal? (split-from (map (0 'f) (2 'r) (4 'd)) 1) (map (2 'r) (4 'd))))
      (test (equal? (split-above (map (0 'b) (23 'g) (7 'l) (4 'x) (19 'w)) 7) (map (19 'w) (23 'g))))
      (test (equal? (split-above (map (0 'm) (23 'p) (7 'e) (4 'o) (19 'q)) 6) (map (7 'e) (19 'q) (23 'p))))
      (test (equal? (split-through (map (0 'c) (3 'h) (5 's) (8 'e) (10 'h)) 5) (map (0 'c) (3 'h) (5 's))))
      (test (equal? (split-through (map (0 'c) (3 'h) (5 's) (8 'e) (10 'h)) 6) (map (0 'c) (3 'h) (5 's))))
      (test (equal? (split-through (map (0 'c) (3 'h) (5 's) (8 'e) (10 'h)) 20)
		    (map (0 'c) (3 'h) (5 's) (8 'e) (10 'h))))
      (test (equal? (split-below (map (7 'z) (3 'i) (1 'n) (2 'w)) 4) (map (1 'n) (2 'w) (3 'i))))
      (test (equal? (split-below (map (7 'z) (3 'i) (1 'n) (2 'w)) 3) (map (1 'n) (2 'w))))

      (test (equal? (filter 'evenp (set 1 2 3 7 8 12 17)) (set 2 8 12)))
      (test (equal? (filter #'evenp (set 1 2 3 7 8 12 17)) (set 2 8 12)))
      (test (equal? (filter (map (1 t) (2 nil) (4 t)) (set 0 1 2 3 4 5))
		    (set 1 4)))
      (test (equal? (filter 'evenp (ch-set 1 2 3 7 8 12 17)) (ch-set 2 8 12)))
      (test (equal? (filter #'evenp (ch-set 1 2 3 7 8 12 17)) (ch-set 2 8 12)))
      (test (equal? (filter (map (1 t) (2 nil) (4 t)) (ch-set 0 1 2 3 4 5))
		    (ch-set 1 4)))
      (test (equal? (filter (set) (set)) (set)))
      (test (equal? (filter (set 0 2 4 7) (set 0 1 2 3 5 6 7 8 9 10))
		    (set 0 2 7)))
      (test (equal? (filter (bag) (set)) (set)))
      (test (equal? (filter (bag 0 0 3 5 6 6 7) (set -1 0 2 5 8))
		    (set 0 5)))
      (test (equal? (multiple-value-list (partition 'evenp (set 0 1 2 3 4 5 6 7)))
		    (list (set 0 2 4 6) (set 1 3 5 7))))
      (test (equal? (multiple-value-list (partition 'evenp (ch-set 0 1 2 3 4 5 6 7)))
		    (list (ch-set 0 2 4 6) (ch-set 1 3 5 7))))
      (test (equal? (multiple-value-list (fset2:partition 'evenp (set 0 1 2 3 4 5 6 7)))
		    (list (set 0 2 4 6) (set 1 3 5 7))))
      (test (equal? (multiple-value-list (fset2:partition 'evenp (ch-set 0 1 2 3 4 5 6 7)))
		    (list (ch-set 0 2 4 6) (ch-set 1 3 5 7))))
      (test (equal? (multiple-value-list (partition (map (1 t) (4 t) (7 t)) (set 0 1 2 3 4 5 6 7)))
		    (list (set 1 4 7) (set 0 2 3 5 6))))
      (test (equal? (multiple-value-list (partition (map (1 t) (4 t) (7 t)) (ch-set 0 1 2 3 4 5 6 7)))
		    (list (ch-set 1 4 7) (ch-set 0 2 3 5 6))))
      (test (equal? (multiple-value-list (fset2:partition (map (1 t) (4 t) (7 t)) (set 0 1 2 3 4 5 6 7)))
		    (list (set 1 4 7) (set 0 2 3 5 6))))
      (test (equal? (multiple-value-list (fset2:partition (map (1 t) (4 t) (7 t)) (ch-set 0 1 2 3 4 5 6 7)))
		    (list (ch-set 1 4 7) (ch-set 0 2 3 5 6))))

      (test (equal? (with-last (seq 1 2 3) 4) (seq 1 2 3 4)))
      (test (equal? (with (seq 'a 'b 'c) 1 'd) (seq 'a 'd 'c)))
      (test (equal? (with (seq 'a 'b 'c) -1 'd) (seq 'd 'a 'b 'c)))
      (test (equal? (with (seq 'a 'b 'c) 3 'd) (seq 'a 'b 'c 'd)))
      (test (equal? (with (seq 'a 'b 'c) 4 'd) (seq 'a 'b 'c nil 'd)))
      (test (equal? (with (with-default (seq 'a 'b 'c) 'z) 4 'd)
		    (with-default (seq 'a 'b 'c 'z 'd) 'z)))
      (test (equal? (with (with-default (seq 'a 'b 'c) 'z) -2 'd)
		    (with-default (seq 'd 'z 'a 'b 'c) 'z)))

      (test (equal? (splice (with-default (seq 'a 'b) 'x) -2 (seq 'c 'd))
		    (with-default (seq 'c 'd 'x 'x 'a 'b) 'x)))
      (test (equal? (splice (with-default (seq) 'x) -2 (seq 'c 'd))
		    (with-default (seq 'c 'd 'x 'x) 'x)))
      (test (equal? (splice (seq 'a 'b) -1 (seq 'c 'd)) (seq 'c 'd nil 'a 'b)))
      (test (equal? (splice (seq 'a 'b) -1 '(c d)) (seq 'c 'd nil 'a 'b)))
      (test (equal? (splice (with-default (seq) 'x) -1 (seq 'c 'd))
		    (with-default (seq 'c 'd 'x) 'x)))
      (test (equal? (splice (with-default (seq) 'x) 0 (seq 'c 'd))
		    (with-default (seq 'c 'd) 'x)))
      (test (equal? (default (splice (with-default (seq) 'x) 0 (seq 'c 'd))) 'x))
      (test (equal? (splice (with-default (seq) 'x) 1 (seq 'c 'd))
		    (with-default (seq 'x 'c 'd) 'x)))
      (test (equal? (splice (with-default (seq) 'x) 2 (seq 'c 'd))
		    (with-default (seq 'x 'x 'c 'd) 'x)))
      (test (equal? (splice (seq 'a 'b) 0 (seq 'c)) (seq 'c 'a 'b)))
      (test (equal? (splice (seq 'a 'b) 0 '(c)) (seq 'c 'a 'b)))
      (test (equal? (splice (seq 'a 'b) 1 (seq 'c)) (seq 'a 'c 'b)))
      (test (equal? (splice (seq 'a 'b) 1 '(c)) (seq 'a 'c 'b)))
      (test (equal? (splice (seq 'a 'b) 1 (seq)) (seq 'a 'b)))
      (test (equal? (splice (seq 'a 'b) 1 nil) (seq 'a 'b)))
      (test (equal? (splice (seq 'a 'b) 2 (seq 'c 'd)) (seq 'a 'b 'c 'd)))
      (test (equal? (splice (seq 'a 'b) 3 (seq 'c 'd)) (seq 'a 'b nil 'c 'd)))

      (test (equal? (splice (with-default (seq 'a 'b) 'd) 2 (seq 'c))
                    (with-default (seq 'a 'b 'c) 'd)))
      (test (equal? (splice (seq 'a 'b) 2 (with-default (seq 'c) 'd))
                    (seq 'a 'b 'c)))

      (test (equal? (insert (seq) 0 'a) (seq 'a)))
      (test (equal? (insert (seq) 1 'a) (seq nil 'a)))
      (test (equal? (insert (seq) -1 'a) (seq 'a nil)))

      (test (equal? (less (seq) 0) (seq)))
      (test (equal? (less (seq 'a) 0) (seq)))
      (test (equal? (less (seq 'a 'b) -1) (seq 'a 'b)))
      (test (equal? (less (seq 'a 'b) 0) (seq 'b)))
      (test (equal? (less (seq 'a 'b) 1) (seq 'a)))
      (test (equal? (less (seq 'a 'b) 2) (seq 'a 'b)))

      (test (equal? (subseq (seq) 0) (seq)))
      (test (equal? (subseq (seq 'a) 0) (seq 'a)))
      (test (equal? (subseq (seq 'a) -1) (seq 'a)))
      (test (let ((s (seq 'a 'b)))
              (eql s (subseq s 0 2))))
      (test (equal? (subseq (seq 'a) 0 2) (seq 'a)))
      (test (equal? (subseq (seq 'a) 0 0) (seq)))
      (test (equal? (subseq (seq 'a) 0 1) (seq 'a)))
      (test (equal? (subseq (seq 'a 'b) 0 0) (seq)))
      (test (equal? (subseq (seq 'a 'b) 0 1) (seq 'a)))
      (test (equal? (subseq (seq 'a 'b) 0 2) (seq 'a 'b)))
      (test (equal? (subseq (seq 'a 'b) 1 1) (seq)))
      (test (equal? (subseq (seq 'a 'b) 1 2) (seq 'b)))
      (test (equal? (subseq (with-default (seq 'a 'b) 'c) 0 1)
		    (with-default (seq 'a) 'c)))
      (test (equal? (default (subseq (with-default (seq 'a 'b) 'c) 0 1)) 'c))

      (test (equal? (reverse (seq)) (seq)))
      (test (equal? (reverse (with-default (seq) 'z))
		    (with-default (seq) 'z)))
      (test (equal? (default (reverse (with-default (seq 'a 'b) 'c))) 'c))
      (test (equal? (reverse (seq 'a)) (seq 'a)))
      (test (equal? (reverse (seq 'a 'b)) (seq 'b 'a)))
      (test (equal? (reverse (with-default (seq 'a 'b) 'z))
		    (with-default (seq 'b 'a) 'z)))
      (let* ((s (seq 1 3 2))
	     (ns (sort s #'<)))
	(test (equal? s (seq 1 3 2)))
	(test (equal? ns (seq 1 2 3))))
      (let* ((s (seq 1 3 2))
	     (ns (stable-sort s #'<)))
	(test (equal? s (seq 1 3 2)))
	(test (equal? ns (seq 1 2 3))))

      (test (equal? (sort-and-group (seq) #'< :key #'identity) (seq)))
      (test (equal? (sort-and-group (seq) #'<) (seq)))
      (test (equal? (sort-and-group (seq 1) #'<) (seq (seq 1))))
      (test (equal? (sort-and-group (seq 1 2) #'<) (seq (seq 1) (seq 2))))
      (test (equal? (sort-and-group (seq 2 1) #'<) (seq (seq 1) (seq 2))))
      (test (equal? (sort-and-group (seq 1 2 2) #'<) (seq (seq 1) (seq 2 2))))
      (test (equal? (sort-and-group (seq 1 2 2) #'< :key #'1+) (seq (seq 1) (seq 2 2))))

      (test (equal? (domain (seq)) (set)))
      (test (equal? (domain (seq 'a)) (set 0)))
      (test (equal? (domain (seq 'a 'b)) (set 0 1)))
      (test (equal? (domain (with-default (seq 'a 'b) 'z)) (set 0 1)))

      (test (equal? (range (seq)) (set)))
      (test (equal? (range (seq 'a)) (set 'a)))
      (test (equal? (range (seq 'a 'a)) (set 'a)))
      (test (equal? (range (seq 'a 'b 'a 'c)) (set 'a 'b 'c)))

      (test (equal? (convert 'wb-seq #(1 2 3)) (wb-seq 1 2 3)))
      (test (equal? (convert 'string (seq #\a #\b #\c)) "abc"))
      (test (equal? (convert 'wb-seq '(1 2 3)) (wb-seq 1 2 3)))
      (test (equal? (convert 'seq (set 1)) (seq 1)))
      (test (equal? (convert 'wb-seq (set 2)) (wb-seq 2)))
      (test (equal? (convert 'wb-seq (bag 1 1)) (wb-seq 1 1)))
      (test (equal? (convert 'wb-seq (map (1 2))) (wb-seq '(1 . 2))))

      (test (domain-contains? (seq 1) 0))
      (test (not (domain-contains? (seq 1) 1)))
      (test (not (domain-contains? (seq 1) -1)))
      (test (not (domain-contains? (seq 1) 2)))
      (test (not (domain-contains? (seq 1) 'x)))

      (test (not (range-contains? (seq) 0)))
      (test (eql (range-contains? (seq 'a) 'a) t))
      (test (eql (range-contains? (seq 'a 'b 'c) 'b) t))
      (test (not (range-contains? (seq 'a 'b 'c) 'd)))

      (test (equal? (filter #'evenp (seq 1 2 3 4 5)) (seq 2 4)))
      (test (equal? (filter #'evenp (with-default (seq 1 2 3 4 5) 17))
		    (with-default (seq 2 4) 17)))
      (test (equal? (filter 'evenp (seq 1 2 3 4 5)) (seq 2 4)))
      (test (equal? (filter (map (1 t) (3 t)) (seq 1 2 3 4 5)) (seq 1 3)))
      (test (equal? (filter (set 1 3 9) (seq 1 2 3 4 5)) (seq 1 3)))
      (test (equal? (filter (bag 1 1 3 9) (seq 1 2 3 4 5)) (seq 1 3)))

      (test (equal? (multiple-value-list (partition (constantly t) (seq 1 2 3)))
		    (list (seq 1 2 3) (seq))))
      (test (equal? (multiple-value-list (partition 'evenp (seq 1 2 3 4)))
		    (list (seq 2 4) (seq 1 3))))
      (test (equal? (multiple-value-list (partition (map (1 t) (4 t)) (seq 0 1 2 3 4 5 6)))
		    (list (seq 1 4) (seq 0 2 3 5 6))))
      (test (equal? (multiple-value-list (partition (set 1 4) (seq 0 1 2 3 4 5 6)))
		    (list (seq 1 4) (seq 0 2 3 5 6))))
      (test (equal? (multiple-value-list (partition (bag 4 4 1 17) (seq 0 1 2 3 4 5 6)))
		    (list (seq 1 4) (seq 0 2 3 5 6))))

      (test (equal? (image #'1+ (seq 1 7 5)) (seq 2 8 6)))
      (test (equal? (image '1+ (seq 1 7 5)) (seq 2 8 6)))
      (test (equal? (image #'1+ (with-default (seq 1 7 5) 0))
		    (with-default (seq 2 8 6) 0)))
      (test (equal? (image (map (1 8) (3 10)) (seq 0 1 2 3 4 5))
		    (seq nil 8 nil 10 nil nil)))
      (test (equal? (image (set -3 1 3 21) (seq 0 1 2 3 4 5))
		    (seq nil t nil t nil nil)))
      (test (equal? (image (bag 1 3 3 10) (seq 0 1 2 3 4 5))
		    (seq nil t nil t nil nil)))
      (let ((s (convert 'seq "abcdefghijklmnopqrstuvwxyz"))
	    ((s2 (image (fn (c) (code-char (+ (mod (+ (- (char-code c) (char-code #\a)) 13) 26)
					      (char-code #\a))))
			s))))
	(test (verify s2))
	(test (equal? s2 (concat (subseq s 13) (subseq s 0 13)))))
      (let ((s (convert 'seq "abcdefghijklmnopqrstuvwxyz"))
	    ((s2 (image (fn (c) (if (or (eql c #\e) (eql c #\x))
				    (intern (string c) (symbol-package 'test-misc-2))
				  c))
			s))))
	(test (verify s2))
	(test (equal? s2 (with (with s 4 '\e) 23 '\x))))
      (let ((s (convert 'seq '(a b c d e f g h i j k l m n o p q r s t u v w x y z)))
	    ((s2 (image (fn (x) (schar (symbol-name x) 0))
			s))))
	(test (verify s2))
	(test (equal? s2 (convert 'seq "ABCDEFGHIJKLMNOPQRSTUVWXYZ")))))))

(defun Test-Misc-3 ()
  "Tests some things that don't need extensive random test cases generated."
  (declare (optimize (debug 3)))
  (macrolet ((test (form)
	       `(unless ,form
		  (error "Test failed: ~S" ',form))))
    (flet ((equal? (a b)
	     (and (equal? a b)
		  (equal? b a))))
      (with-standard-io-syntax
	(let ((*package* (find-package :fset))
	      (*readtable* *fset-readtable*)
	      (*print-readably* nil))
	  (test (equal? (prin1-to-string (bag 1)) "#{% 1 %}"))
	  (test (equal? (prin1-to-string (bag 1 2)) "#{% 1 2 %}"))
	  (test (equal? (prin1-to-string (bag 1 1)) "#{% #%(1 2) %}"))))

      (test (equal? (reduce #'+ (seq)) 0))
      (test (equal? (reduce '+ (seq)) 0))
      (test (equal? (reduce #'+ (seq 1 2 3) :key #'1+) 9))
      (test (equal? (reduce #'+ (seq 1 2 3) :key '1+) 9))
      (test (equal? (reduce '+ (seq 1 2 3) :key #'1+) 9))
      (test (equal? (reduce '+ (seq 1 2 3) :key '1+) 9))
      (test (equal? (reduce #'+ (seq -1 1 2 3 17) :start 1 :end 3 :key #'1+) 5))
      (test (equal? (reduce '+ (seq -1 1 2 3 17) :start 1 :end 3 :key #'1+) 5))
      (test (equal? (reduce #'- (seq 0 1 2 3 4)) -10))
      (test (equal? (reduce '- (seq 0 1 2 3 4)) -10))
      (test (equal? (reduce #'- (seq 0 1 2 3 4) :from-end t) -2))
      (test (equal? (reduce '- (seq 0 1 2 3 4) :from-end t) -2))

      (test (equal? (reduce #'+ (seq) :initial-value 17) 17))
      (test (equal? (reduce 'cons (seq 'a)) 'a))
      (test (equal (reduce 'cons (seq 'a 'b)) '(a . b)))
      (test (equal (reduce 'cons (seq 'a 'b) :from-end t) '(b . a)))
      (test (equal? (reduce 'cons (seq 'a) :from-end t) 'a))
      (test (equal? (reduce 'cons (seq 'a) :initial-value nil :from-end t) '(nil . a)))
      (test (equal? (reduce #'+ (seq 1 2 5) :start 1 :initial-value 0) 7))
      (test (equal? (reduce '+ (seq 1 2 5) :start 1 :initial-value 0) 7))
      (test (equal? (reduce #'+ (seq 1 2 4) :end 2 :initial-value 0) 3))
      (test (equal? (reduce '+ (seq 1 2 4) :end 2 :initial-value 0) 3))

      (test (equal (position :x (seq)) nil))
      (test (equal (position :x (seq :x)) 0))
      (test (equal (position :x (seq :x :a)) 0))
      (test (equal (position :x (seq :x :a) :start 1) nil))
      (test (equal (position :x (seq :x :a) :from-end t) 0))
      (test (equal (position :x (seq :a :x)) 1))
      (test (equal (position :x (seq :a :x) :start 1) 1))
      (test (equal (position :x (seq :a :x) :end 1) nil))
      (test (equal (position :x (seq :a :x) :from-end t) 1))
      (test (equal (position :x (seq :a :x) :from-end t :start 1) 1))
      (test (equal (position :x (seq :x :x)) 0))
      (test (equal (position :x (seq :a :x :x) :key #'identity :start 1) 1))
      (test (equal (position :x (seq :x :x) :from-end t) 1))
      (test (equal (position :x (seq :x :x) :from-end t :start 1) 1))
      (test (equal (position :x (seq :x :x) :from-end t :end 1) 0))
      (test (equal (position :x (seq :x :x) :test #'eq) 0))
      (test (equal (position :x (seq :x :x) :start 2 :test #'eq) nil))
      (test (equal (position :x (seq :x :x :a :b) :start 1 :key #'identity) 1))
      (test (equal (position :x (seq :a :b :c :d :e :f) :key #'identity) nil))
      (test (equal (position :x (seq :a :x :c :d :x :f) :key #'identity
                             :from-end t)
                   4))
      (test (equal (position :x (seq :a :a :x :c :d :x :f) :key #'identity
                             :from-end t)
                   5))
      (test (equal (position :x (seq 1 2 3 4 5 6) :key #'identity :test #'eql) nil))
      (test (equal (position :x (seq 1 2 :x 4 5 6) :key #'identity :test #'eql)
                   2))
      (test (equal (position :x (seq 1 2 :x 4 5 6) :key #'identity :test #'eql
                             :from-end t)
                   2))
      (test (equal (position :x (seq :x :x) :key #'identity
                             :start 2 :test #'eq)
                   nil))
      (test (equal (position :x (seq :a :b :c :d :e) :key #'identity
                             :test #'eq)
                   nil))
      (test (equal (position :x (seq :x) :test (complement #'eql)
                             :key #'identity)
                   nil))
      (test (equal (position :x (seq :x :y :x :y) :test (complement #'eql)
                             :key #'identity :from-end t)
                   3))
      (test (equal (position :x (seq :x :y :x :y) :test (complement #'eql)
                             :key #'identity)
                   1))
      (test (equal (position :x (seq :x :x) :from-end t :test #'eq) 1))
      (test (equal (position :x (seq :x :x) :from-end t :key 'identity
                             :test #'eq)
                   1))
      (test (equal (position :x (seq :x :a :b :x :c) :from-end t :test #'eq) 3))
      (test (equal (position :x (seq :x :x) :from-end t :start 1 :test #'eq) 1))
      (test (equal (position :x (seq :x :x) :from-end t :end 1 :test #'eq) 0))
      (test (equal (position :x (seq :x) :start 1 :from-end t :test #'eq) nil))
      (test (equal (position :x (seq :x) :from-end t :test (complement #'eql)) nil))

      (test (not (position-if #'identity (seq))))
      (test (not (position-if #'identity (seq nil))))
      (test (equal? (position-if #'identity (seq 1)) 0))
      (test (not (position-if #'identity (seq 1) :start 1)))
      (test (not (position-if #'identity (seq 1) :end 0)))
      (test (equal? (position-if #'identity (seq t nil t) :start 1) 2))
      (test (not (position-if #'identity (seq t nil t) :start 1 :end 2)))
      (test (equal? (position-if #'evenp (seq 1 2 3 4 5) :from-end t) 3))
      (test (equal? (position-if #'evenp (seq 1 2 3 4 5) :end 2 :from-end t) 1))
      (test (not (position-if #'evenp (seq 1 2 3 4 5) :start 4 :from-end t)))
      (test (equal? (position-if #'evenp (seq 2 3 4 5) :key #'1+) 1))
      (test (equal? (position-if #'evenp (seq 2 3 4 5) :key #'1+ :start 2) 3))
      (test (not (position-if #'evenp (seq 2 3 4 5) :key #'1+ :end 1)))
      (test (equal? (position-if #'evenp (seq 2 3 4 5 6) :key #'1+ :from-end t) 3))
      (test (equal (position-if #'evenp (seq 1 2 3 4 5) :from-end t) 3))
      (test (equal (position-if #'evenp (seq 1 2 3 4 5)
                                :from-end t :key #'identity)
                   3))
      (test (equal (position-if #'evenp (seq 1 2 3 4 5) :from-end t :end 3) 1))
      (test (equal (position-if #'evenp (seq 1 2 3 4 5) :from-end t :start 1) 3))
      (test (equal (position-if #'evenp (seq 1 2 3 4 5) :from-end t :start 2) 3))
      (test (equal (position-if #'evenp (seq 1 3 5 7 9 11)) nil))
      (test (equal (position-if #'evenp (seq 1 3 5 7 9 12)) 5))
      (test (equal (position-if #'evenp (seq 1 3 5 7 9 11) :key #'identity)
                   nil))
      (test (equal (position-if #'evenp (seq 1 3 5 7 9 12) :key #'identity)
                   5))

      (test (not (position-if-not #'identity (seq))))
      (test (equal? (position-if-not #'evenp (seq 2 3 4)) 1))
      (test (equal? (position-if-not #'evenp (seq 2 3 4) :key '1+) 0))
      (test (equal? (position-if-not #'evenp (seq 2 3 4) :key '1+ :from-end t) 2))
      (test (equal? (position-if-not #'evenp (seq 2 3 4) :key '1+ :start 1) 2))
      (test (equal? (position-if-not #'evenp (seq 2 3 4) :key '1+ :end 1 :from-end t) 0))

      (test (equal? (remove 1 (seq)) (seq)))
      (test (equal? (remove 1 (seq 0)) (seq 0)))
      (test (equal? (remove 1 (seq 1)) (seq)))
      (test (equal? (remove 1 (seq 1 1)) (seq)))
      (test (equal? (remove 1 (seq 1 1) :count 1) (seq 1)))
      (test (equal? (remove 1 (seq 0 0 0 0 1 3 1 2 1) :count 1 :start 3)
                    (seq 0 0 0 0 3 1 2 1)))
      (test (equal? (remove (seq 0) (seq 0 (seq 0))) (seq 0)))
      (test (equal? (remove nil (seq 2 3 4 5) :key #'evenp) (seq 2 4)))
      (test (equal? (remove nil (seq 2 3 4 5) :key #'evenp :count 1) (seq 2 4 5)))
      (test (equal? (remove nil (seq 2 3 4 5) :key #'evenp :count 1 :from-end t) (seq 2 3 4)))
      (test (equal? (remove 3 (seq 2 3 4 5) :test #'<) (seq 2 3)))
      (test (equal? (remove 3 (seq 2 3 4 5) :test #'< :start 3) (seq 2 3 4)))
      (test (equal? (remove 3 (seq 2 3 4 5) :test #'< :end 3) (seq 2 3 5)))

      (test (equal? (remove-if 'null (seq)) (seq)))
      (test (equal? (remove-if 'null (seq nil)) (seq)))
      (test (equal? (remove-if 'null (seq 1 nil 2)) (seq 1 2)))
      (test (equal? (remove-if #'null (seq 1 nil 2)) (seq 1 2)))
      (test (equal? (remove-if #'null (seq 1 nil 2 nil 3) :start 2)
		    (seq 1 nil 2 3)))
      (test (equal? (remove-if #'null (seq 1 nil 2 nil 3) :count 1)
		    (seq 1 2 nil 3)))
      (test (equal? (remove-if #'null (seq 1 nil 2 nil 3) :count 1 :from-end t)
		    (seq 1 nil 2 3)))
      (test (equal? (remove-if #'null (seq 1 nil 2 nil 3) :key #'not)
		    (seq nil nil)))
      (test (equal? (remove-if #'null (seq 1 nil 2 nil 3 nil) :end 5)
                    (seq 1 2 3 nil)))
      (test (equal? (remove-if #'null (seq 1 2 3) :key #'1+)
                    (seq 1 2 3)))
      (test (equal? (remove-if #'null (seq nil nil nil 1 2 nil 3 nil 4)
                               :start 3 :count 1)
                    (seq nil nil nil 1 2 3 nil 4)))

      (test (equal (remove-if #'oddp '(1 2 1 4)) '(2 4)))
      (test (equal (remove-if #'oddp '(1 2 1 4) :count 1) '(2 1 4)))
      (test (equal (remove-if #'oddp '(1 2 1 4) :start 1) '(1 2 4)))
      (test (equal (remove-if #'oddp '(1 2 1 4) :end 1) '(2 1 4)))
      (test (equal (remove-if #'oddp '(3 2 1 4) :key #'1+) '(3 1)))

      (test (equal? (remove-if-not 'identity (seq)) (seq)))
      (test (equal? (remove-if-not 'identity (seq nil)) (seq)))
      (test (equal? (remove-if-not 'identity (seq 1 nil 2)) (seq 1 2)))
      (test (equal? (remove-if-not #'identity (seq 1 nil 2)) (seq 1 2)))
      (test (equal? (remove-if-not #'identity (seq 1 nil 2 nil 3) :start 2)
		    (seq 1 nil 2 3)))
      (test (equal? (remove-if-not #'identity (seq 1 nil 2 nil 3) :count 1)
		    (seq 1 2 nil 3)))
      (test (equal? (remove-if-not #'identity (seq 1 nil 2 nil 3) :count 1 :from-end t)
		    (seq 1 nil 2 3)))
      (test (equal? (remove-if-not #'identity (seq 1 nil 2 nil 3) :key #'not)
		    (seq nil nil)))
      (test (equal? (remove-if-not #'null (seq 1 nil 2 nil 3))
                    (seq nil nil)))
      (test (equal? (remove-if-not #'identity (seq 1 nil 2 nil 3 nil 4)
                                   :end 4)
                    (seq 1 2 3 nil 4)))

      (test (equal? (remove-if-not #'identity '(1 2 nil 3 nil 4))
                    '(1 2 3 4)))
      (test (equal? (remove-if-not #'identity '(1 2 nil 3 nil 4) :start 3)
                    '(1 2 nil 3 4)))
      (test (equal? (remove-if-not #'identity '(1 2 nil 3 nil 4) :end 4)
                    '(1 2 3 nil 4)))
      (test (equal? (remove-if-not #'identity '(1 2 nil 3 nil 4 nil 5 nil)
                                   :count 2)
                    '(1 2 3 4 nil 5 nil)))

      (test (equal? (remove-if-not #'identity '(1 2 nil 3 nil 4 nil 5 nil)
                                   :count 1 :from-end t)
                    '(1 2 nil 3 nil 4 nil 5)))
      (test (equal? (remove-if-not #'identity '(1 nil 2 nil 3) :key #'null)
                    '(nil nil)))

      (test (equal? (substitute 1 2 (seq)) (seq)))
      (test (equal? (substitute 1 2 (seq 0 1 2 3)) (seq 0 1 1 3)))
      (test (equal? (substitute (seq 1) (seq 0) (seq 0 (seq 2) (seq 0) (seq 3) (seq 1) 1))
		    (seq 0 (seq 2) (seq 1) (seq 3) (seq 1) 1)))
      (test (equal? (substitute 'x 3 (seq 0 1 2 3 4 5) :test #'<=)
		    (seq 0 1 2 'x 'x 'x)))
      (test (equal? (substitute 'x nil (seq 0 1 2 3 4 5) :key #'evenp)
		    (seq 0 'x 2 'x 4 'x)))
      (test (equal? (substitute 1 0 (seq 1 0 2 0 3)) (seq 1 1 2 1 3)))
      (test (equal? (substitute 1 0 (seq 1 0 2 0 3) :count 1) (seq 1 1 2 0 3)))
      (test (equal? (substitute 1 0 (seq 1 0 2 0 3) :count 1 :from-end t) (seq 1 0 2 1 3)))
      (test (equal? (substitute :b :a (seq :a :b :a) :end 2)
                    (seq :b :b :a)))
      (test (equal? (substitute :b :a (seq :a :b :a) :start 1)
                    (seq :a :b :b)))
      (test (equal? (substitute :b :a (seq :c :c :c :a :b :b) :start 2 :count 1)
                    (seq :c :c :c :b :b :b)))

      (test (equal? (substitute :a :b '(:a :b :c)) '(:a :a :c)))
      (test (equal? (substitute :a :b '(:a :b :b :c) :start 2) '(:a :b :a :c)))
      (test (equal? (substitute :a :b '(:a :b :b :b :c) :end 2) '(:a :a :b :b :c)))
      (test (equal? (substitute :a :b '(:a :b :c) :test (complement #'equal))
                    '(:a :b :a)))
      (test (equal? (substitute :a :b '(:a :b :b :c) :count 1)
                    '(:a :a :b :c)))
      (test (equal? (substitute :a :b '(:a :b :b :c) :count 1 :from-end t)
                    '(:a :b :a :c)))
      (test (equal? (substitute nil 2 '(1 2 3 1 4 0) :key #'1+)
                    '(nil 2 3 nil 4 0)))

      (test (equal? (substitute-if 'x #'evenp (seq)) (seq)))
      (test (equal? (substitute-if 'x 'evenp (seq 1)) (seq 1)))
      (test (equal? (substitute-if 'x 'evenp (seq 1 2 3 4) :start 2) (seq 1 2 3 'x)))
      (test (equal? (substitute-if 'x 'evenp (seq 1 2 3 4) :end 2) (seq 1 'x 3 4)))
      (test (equal? (substitute-if 'x #'evenp (seq 2)) (seq 'x)))
      (test (equal? (substitute-if 'x #'evenp (seq 11 12) :key #'1+) (seq 'x 12)))
      (test (equal? (substitute-if 'x #'evenp (seq 1 2 3 4 5) :count 1) (seq 1 'x 3 4 5)))
      (test (equal? (substitute-if 'x #'evenp (seq 1 2 3 4 5 6 7 8) :count 2) (seq 1 'x 3 'x 5 6 7 8)))
      (test (equal? (substitute-if 'x #'evenp (seq 1 2 3 4 5) :count 1 :from-end t)
		    (seq 1 2 3 'x 5)))
      (test (equal? (substitute-if :a #'evenp (seq 1 2 3 4 5 6) :count 3 :key #'identity)
                    (seq 1 :a 3 :a 5 :a)))
      (test (equal? (substitute-if :a #'null (seq nil 1 :b nil :c))
                    (seq :a 1 :b :a :c)))
      (test (equal? (substitute-if :a #'null (seq nil 1 :b :d nil :c nil :e) :start 3 :count 2)
                    (seq nil 1 :b :d :a :c :a :e)))

      (test (equal? (substitute-if :a #'null '(nil 1 :b nil :c))
                    '(:a 1 :b :a :c)))
      (test (equal? (substitute-if :a #'null '(nil 1 :b nil :c) :start 1)
                    '(nil 1 :b :a :c)))
      (test (equal? (substitute-if :a #'null '(nil 1 :b nil :c) :end 2)
                    '(:a 1 :b nil :c)))
      (test (equal? (substitute-if :a #'null '(nil 1 :b nil :c) :count 1)
                    '(:a 1 :b nil :c)))
      (test (equal? (substitute-if :a #'evenp '(1 2 3 4 5 6) :count 3 :key #'identity)
                    '(1 :a 3 :a 5 :a)))
      (test (equal? (substitute-if :a #'null '(nil 1 :b nil :c) :count 1 :from-end t)
                    '(nil 1 :b :a :c)))
      (test (equal? (substitute-if :a #'null '(nil 1 :b nil :c) :key #'null)
                    '(nil :a :a nil :a)))

      (test (equal? (substitute-if-not 'x #'oddp (seq)) (seq)))
      (test (equal? (substitute-if-not 'x #'oddp (seq 1)) (seq 1)))
      (test (equal? (substitute-if-not 'x #'oddp (seq 2)) (seq 'x)))
      (test (equal? (substitute-if-not 'x 'oddp (seq 1 2) :key #'1+) (seq 'x 2)))
      (test (equal? (substitute-if-not 'x #'oddp (seq 1 2 3 4 5) :count 1) (seq 1 'x 3 4 5)))
      (test (equal? (substitute-if-not 'x #'oddp (seq 1 2 3 4 5) :count 1 :from-end t)
		    (seq 1 2 3 'x 5)))
      (test (equal? (substitute-if-not :a #'oddp (seq 1 2 3 4 5)) (seq 1 :a 3 :a 5)))
      (test (equal? (substitute-if-not :a #'oddp (seq 1 2 3 4 5) :end 3) (seq 1 :a 3 4 5)))
      (test (equal? (substitute-if-not :a #'oddp (seq 1 2 3 4 5 6 7) :start 2) (seq 1 2 3 :a 5 :a 7)))
      (test (equal? (substitute-if-not :a #'oddp (seq 1 2 3 4 5 6 7) :count 2) (seq 1 :a 3 :a 5 6 7)))
      (test (equal? (substitute-if-not :a #'oddp (seq 1 2 3 4 5 6 7) :count 2 :from-end t)
                    (seq 1 2 3 :a 5 :a 7)))

      (test (equal? (substitute-if-not :a #'identity '(nil 1 nil nil 2 nil)) '(:a 1 :a :a 2 :a)))
      (test (equal? (substitute-if-not :a #'identity '(nil 1 nil nil 2 nil) :start 1) '(nil 1 :a :a 2 :a)))
      (test (equal? (substitute-if-not :a #'identity '(nil 1 nil nil 2 nil) :end 3) '(:a 1 :a nil 2 nil)))
      (test (equal? (substitute-if-not :a #'identity '(nil 1 nil nil 2 nil) :count 2) '(:a 1 :a nil 2 nil)))
      (test (equal? (substitute-if-not :a #'identity '(nil 1 nil nil 2 nil) :count 2 :from-end t)
                    '(nil 1 nil :a 2 :a)))
      (test (equal? (substitute-if-not :a #'identity '(nil 1 nil nil 2 nil) :key #'null)
                    '(nil :a nil nil :a nil)))

      (test (empty? nil))
      (test (not (empty? '(x))))

      ;; `wb-replay-set' is arguably obsolete, but we test it anyway.
      (let ((rs (wb-replay-set 27 14 ($ (set 3 92)))))
	(test (eq (compare-fn-name (wb-custom-replay-set 'erapmoc 12 3 17 9)) 'erapmoc))
	(test (equal? (size rs) 4))
	(test (contains? rs 3))
	(test (equal? (first rs) 27))
	(test (equal? (last rs) 92))
	(test (contains? rs (arb rs)))
	(test (equal? (least rs) 3))
	(test (equal? (greatest rs) 92))
	(test (equal? (index rs 3) 2))
	(test (equal? (convert 'seq rs) (seq 27 14 3 92)))
	(test (equal? (let ((tmp nil))
			(do-set (x rs)
			  (push x tmp))
			(nreverse tmp))
		      '(27 14 3 92)))
	(test (equal? (convert 'seq (less rs 3)) (seq 27 14 92)))
	(test (equal? rs (convert 'wb-replay-set (convert 'list rs))))
	(test (equal? rs (convert 'wb-replay-set (convert 'seq rs))))
	(test (equal? rs (convert 'wb-replay-set (convert 'vector rs))))
	(test (equal? rs (convert 'wb-replay-set (convert 'ch-replay-set rs))))
	(test (equal? rs (convert 'wb-replay-set rs)))
	(test (equal? (convert 'wb-set rs) (convert 'wb-set (convert 'wb-replay-set rs :compare-fn-name 'erapmoc))))
	(test (equal? rs (gmap (:result wb-replay-set) nil (:arg replay-set rs))))
	(test (equal? rs (gmap (:result wb-replay-set) nil (:arg set rs))))
	(test (equal? rs (gmap (:result wb-replay-set) (fn (i) (at-index rs i)) (:arg index 0 (size rs)))))
	(test (equal? rs (wb-replay-set 27 14 3 92)))
	(test (not (equal? rs (wb-replay-set 27 3 14 92))))
	(test (equal? (union rs (wb-replay-set 38 14 6))
		      (wb-replay-set 27 14 3 92 38 6)))
	(test (equal? (intersection rs (set 14 27))
		      (wb-replay-set 27 14))))

      ;; Tests `ch-replay-set'.
      (let ((rs (replay-set 27 14 ($ (set 3 92)))))
	(test (eq (compare-fn-name (ch-custom-replay-set 'erapmoc 12 3 17 9)) 'erapmoc))
	(test (equal? (size rs) 4))
	(test (contains? rs 3))
	(test (equal? (first rs) 27))
	(test (equal? (last rs) 92))
	(test (contains? rs (arb rs)))
	(test (equal? (index rs 3) 2))
	(test (equal? (convert 'seq rs) (seq 27 14 3 92)))
	(test (equal? (let ((tmp nil))
			(do-set (x rs)
			  (push x tmp))
			(nreverse tmp))
		      '(27 14 3 92)))
	(test (equal? (convert 'seq (less rs 3)) (seq 27 14 92)))
	(test (equal? rs (convert 'replay-set (convert 'list rs))))
	(test (equal? rs (convert 'replay-set (convert 'seq rs))))
	(test (equal? rs (convert 'replay-set (convert 'vector rs))))
	(test (equal? rs (convert 'ch-replay-set rs)))
	(test (equal? rs (convert 'ch-replay-set (convert 'wb-replay-set rs))))
	(test (equal? (convert 'ch-set rs) (convert 'ch-set (convert 'ch-replay-set rs :compare-fn-name 'erapmoc))))
	(test (equal? rs (gmap (:result ch-replay-set) nil (:arg replay-set rs))))
	(test (equal? rs (gmap (:result ch-replay-set) nil (:arg set rs))))
	(test (equal? rs (gmap (:result ch-replay-set) (fn (i) (at-index rs i)) (:arg index 0 (size rs)))))
	(test (equal? rs (ch-replay-set 27 14 3 92)))
	(test (not (equal? rs (ch-replay-set 27 3 14 92))))
	(test (equal? (union rs (ch-replay-set 38 14 6))
		      (ch-replay-set 27 14 3 92 38 6)))
	(test (equal? (intersection rs (ch-set 14 27))
		      (ch-replay-set 27 14))))

      ;; `wb-replay-map' is arguably obsolete, but we test it anyway.
      (let ((rm (wb-replay-map (19 'foo) (12 'bar) :default 'xyzzy (8 'quux) ($ (map (2 'gubbish) (34 'ork))))))
	(let ((crm (convert 'wb-replay-map rm :key-compare-fn-name 'erapmoc :val-compare-fn-name 'eql-compare)))
	  (test (eq (key-compare-fn-name crm) 'erapmoc))
	  (test (eq (val-compare-fn-name crm) 'eql-compare)))
	(let ((crm (wb-custom-replay-map 'erapmoc 'eql-compare (19 'foo) (12 'bar) :default 'xyzzy (8 'quux)
					 ($ (map (2 'gubbish) (34 'ork))))))
	  (test (eq (key-compare-fn-name crm) 'erapmoc))
	  (test (eq (val-compare-fn-name crm) 'eql-compare)))
	(test (equal? (size rm) 5))
	(test (equal? (@ rm 8) 'quux))
	(let ((k v (first rm)))
	  (test (and (equal? k 19) (equal? v 'foo))))
	(let ((k v (last rm)))
	  (test (and (equal? k 34) (equal? v 'ork))))
	(test (domain-contains? rm (arb rm)))
	(let ((k v (least rm)))
	  (test (and (equal? k 2) (equal? v 'gubbish))))
	(let ((k v (greatest rm)))
	  (test (and (equal? k 34) (equal? v 'ork))))
	(test (equal? (index rm 8) 2))
	(test (equal? (convert 'seq rm) (seq '(19 . foo) '(12 . bar) '(8 . quux) '(2 . gubbish) '(34 . ork))))
	(test (equal? (domain rm) (wb-replay-set 19 12 8 2 34)))
	(excludef rm 12)
	(setf (@ rm 8) 'the-great-quux)
	(test (equal? (let ((tmp nil))
			(do-map (x y rm)
			  (push (cons x y) tmp))
			(nreverse tmp))
		      '((19 . foo) (8 . the-great-quux) (2 . gubbish) (34 . ork))))
	(test (equal? (with-default rm nil) (convert 'wb-replay-map (convert 'list rm))))
	(test (equal? (with-default rm nil) (convert 'wb-replay-map (convert 'seq rm))))
	(test (equal? (with-default rm nil) (convert 'wb-replay-map (convert 'vector rm))))
	(test (equal? rm (convert 'wb-replay-map (convert 'ch-replay-map rm))))
	(test (equal? (with-default rm nil) (gmap (:result wb-replay-map) nil (:arg replay-map rm))))
	(test (equal? (with-default rm nil) (gmap (:result wb-replay-map) nil (:arg map rm))))
	(test (equal? rm (gmap (:result wb-replay-map :default 'xyzzy) nil (:arg map rm))))
	(test (equal? (with-default rm nil)
		      (gmap (:result wb-replay-map) (fn (i) (at-index rm i)) (:arg index 0 (size rm)))))
	(test (equal? rm (wb-replay-map (19 'foo) (8 'the-great-quux) (2 'gubbish) (34 'ork)
					:default 'xyzzy)))
	(test (not (equal? rm (wb-replay-map (19 'foo) (8 'the-great-quux) (3 'gubbish) (34 'ork)
					     :default 'xyzzy))))
	(test (not (equal? rm (wb-replay-map (19 'bar) (8 'the-great-quux) (2 'gubbish) (34 'ork)
					     :default 'xyzzy)))))

      ;; Tests `ch-replay-map'.
      (let ((rm (replay-map (19 'foo) (12 'bar) :default 'xyzzy (8 'quux) ($ (map (2 'gubbish) (34 'ork))))))
	(let ((crm (convert 'ch-replay-map rm :key-compare-fn-name 'erapmoc :val-compare-fn-name 'eql-compare)))
	  (test (eq (key-compare-fn-name crm) 'erapmoc))
	  (test (eq (val-compare-fn-name crm) 'eql-compare)))
	(let ((crm (ch-custom-replay-map 'erapmoc 'eql-compare (19 'foo) (12 'bar) :default 'xyzzy (8 'quux)
					 ($ (map (2 'gubbish) (34 'ork))))))
	  (test (eq (key-compare-fn-name crm) 'erapmoc))
	  (test (eq (val-compare-fn-name crm) 'eql-compare)))
	(test (equal? (size rm) 5))
	(test (equal? (@ rm 8) 'quux))
	(let ((k v (first rm)))
	  (test (and (equal? k 19) (equal? v 'foo))))
	(let ((k v (last rm)))
	  (test (and (equal? k 34) (equal? v 'ork))))
	(test (domain-contains? rm (arb rm)))
	(test (equal? (index rm 8) 2))
	(test (equal? (convert 'seq rm) (seq '(19 . foo) '(12 . bar) '(8 . quux) '(2 . gubbish) '(34 . ork))))
	(test (equal? (domain rm) (ch-replay-set 19 12 8 2 34)))
	(excludef rm 12)
	(setf (@ rm 8) 'the-great-quux)
	(test (equal? (let ((tmp nil))
			(do-map (x y rm)
			  (push (cons x y) tmp))
			(nreverse tmp))
		      '((19 . foo) (8 . the-great-quux) (2 . gubbish) (34 . ork))))
	(test (equal? (with-default rm nil) (convert 'replay-map (convert 'list rm))))
	(test (equal? (with-default rm nil) (convert 'ch-replay-map (convert 'list rm))))
	(test (equal? (with-default rm nil) (convert 'replay-map (convert 'seq rm))))
	(test (equal? (with-default rm nil) (convert 'replay-map (convert 'vector rm))))
	(test (equal? rm (convert 'ch-replay-map (convert 'wb-replay-map rm))))
	(test (equal? (with-default rm nil) (gmap (:result ch-replay-map) nil (:arg replay-map rm))))
	(test (equal? (with-default rm nil) (gmap (:result ch-replay-map) nil (:arg map rm))))
	(test (equal? rm (gmap (:result ch-replay-map :default 'xyzzy) nil (:arg map rm))))
	(test (equal? (with-default rm nil)
		      (gmap (:result ch-replay-map) (fn (i) (at-index rm i)) (:arg index 0 (size rm)))))
	(test (equal? rm (ch-replay-map (19 'foo) (8 'the-great-quux) (2 'gubbish) (34 'ork)
					:default 'xyzzy)))
	(test (not (equal? rm (ch-replay-map (19 'foo) (8 'the-great-quux) (3 'gubbish) (34 'ork)
					     :default 'xyzzy))))
	(test (not (equal? rm (ch-replay-map (19 'bar) (8 'the-great-quux) (2 'gubbish) (34 'ork)
					     :default 'xyzzy)))))

      #+sbcl
      (progn
	(test (empty? (make-instance 'my-sequence)))
	(test (not (empty? (make-instance 'my-sequence :actual '(3 5)))))
	(test (equal? (size (make-instance 'my-sequence)) 0))
	(test (equal (multiple-value-list
                      (lookup (make-instance 'my-sequence :actual '(a b c)) 0))
                     '(a t)))
	(test (equal? (multiple-value-list
                       (lookup (make-instance 'my-sequence :actual '(a b c)) 1))
                      '(b t)))
        (test (equal (multiple-value-list
                      (funcall (iterator (make-instance 'my-sequence)) :get))
                     '(nil nil)))
        (test (equal (my-sequence-actual
                      (subseq (make-instance 'my-sequence :actual '(a b c d e f)) 2 4))
                     '(c d))))

      (test (= (size (empty-set)) 0))
      (locally (declare (notinline empty-set))
	(test (= (size (empty-set)) 0)))
      (test (= (size (empty-wb-set)) 0))
      (locally (declare (notinline empty-wb-set))
	(test (= (size (empty-wb-set)) 0)))
      (test (= (size (set 1 2 1 3)) 3))
      (test (= (size (map ('x 1) ('y 2) ('x 3))) 2))
      (test (= (size (bag 1 2 1 3)) 4))
      (test (= (size (seq 1 2 3)) 3))
      (test (= (set-size (set 1 2 1 3)) 3))
      (test (= (set-size (bag 1 2 1 3)) 3))
      (test (let ((val val? (arb (set))))
	      (and (null val) (not val?))))
      (test (let ((s (set 1 4 8))
		  ((val val? (arb s))))
	      (and val? (contains? s val))))
      (test (handler-case (progn (contains? (set 1) 1 nil) nil)
              (simple-program-error () t)))
      (test (handler-case (progn (contains? (wb-set 1) 1 nil) nil)
              (simple-program-error () t)))
      (test (let ((val mult val? (arb (bag))))
	      (and (null val) (null mult) (not val?))))
      (test (let ((b (bag 1 4 8))
		  ((val mult val? (arb b))))
	      (and val? (contains? b val) (= mult 1))))
      (test (let ((key val pr? (arb (map))))
	      (and (null key) (null val) (not pr?))))
      (test (let ((m (map ('x 0) ('y 1) ('z 3)))
		  ((key val pr? (arb m))))
	      (and pr? (equal? val (lookup m key)))))
      (test (contains? (set 1 2 1) 1))
      (test (contains? (bag 1 2 1) 2))
      (test (handler-case (progn (contains? (bag 1) 1 nil) nil)
              (simple-program-error () t)))
      (test (domain-contains? (map ('x 0) ('y 1)) 'y))
      (test (domain-contains? (ch-map ('x 0) ('y 1)) 'y))
      (test (domain-contains? (seq 'a 'e 'g 'x) 3))
      (test (= (multiplicity (bag 1 2 1) 1) 2))
      (test (= (multiplicity (bag 1 2 1) 2) 1))
      (test (let ((val val? (least (set 13 7 42))))
	      (and (= val 7) (eq val? t))))
      (test (equal (multiple-value-list (least (set)))
                   '(nil nil)))
      (test (let ((val mult val? (least (bag 4 9 13 4 7))))
	      (and (= val 4) (= mult 2) (eq val? t))))
      (test (equal (multiple-value-list (least (bag)))
                   '(nil nil nil)))
      (test (let ((key val pr? (least (map ('x 4) ('y 7)))))
	      (and (eq key 'x) (= val 4) (eq pr? t))))
      (test (equal (multiple-value-list (least (map)))
                   '(nil nil nil)))
      (test (let ((key val pr? (least (map))))
	      (and (null key) (null val) (not pr?))))
      (test (let ((val val? (greatest (set 13 7 42))))
	      (and (= val 42) (eq val? t))))
      (test (equal (multiple-value-list (greatest (set)))
                   '(nil nil)))
      (test (let ((val mult val? (greatest (bag 4 9 13 4 7))))
	      (and (= val 13) (= mult 1) (eq val? t))))
      (test (equal (multiple-value-list (greatest (bag)))
                   '(nil nil nil)))
      (test (let ((key val pr? (greatest (map ('x 4) ('y 7)))))
	      (and (eq key 'y) (= val 7) (eq pr? t))))
      (test (equal (multiple-value-list (greatest (map)))
                   '(nil nil nil)))
      (test (equal (multiple-value-list (lookup (map ('x 'a) ('y 'b)) 'x)) '(a t x)))
      (test (equal (multiple-value-list (lookup (map ('x 'a) ('y 'b)) 'z)) '(nil nil nil)))
      (test (eq (lookup (seq 'a 'b 'c) 1) 'b))
      (test (let ((s0 "x")
		  (s1 "y")
		  ((val canon (lookup (set s0 s1) "x"))))
	      (and val (eq canon s0))))
      (test (let ((s0 "x")
		  (s1 "y")
		  ((val canon (lookup (bag s0 s1) "x"))))
	      (and val (eq canon s0))))
      (test (let ((rank val? (rank (set 1 2 3 4) 2)))
	      (and (= rank 1) val?)))
      (test (let ((rank val? (rank (set 1 2 3 4) 3.5)))
	      (and (= rank 2) (not val?))))
      (test (let ((rank val? (rank (set 1 2 3 4) 5)))
	      (and (= rank 3) (not val?))))
      (test (let ((rank val? (rank (set) 5)))
	      (and (= rank -1) (not val?))))
      (test (let ((rank val? (rank (bag 1 2 3 4) 2)))
	      (and (= rank 1) val?)))
      (test (let ((rank val? (rank (bag 1 2 3 4) 3.5)))
	      (and (= rank 2) (not val?))))
      (test (let ((rank val? (rank (bag 1 2 3 4) 5)))
	      (and (= rank 3) (not val?))))
      (test (let ((rank val? (rank (bag) 5)))
	      (and (= rank -1) (not val?))))
      (test (let ((rank val? (rank (map (1 12) (2 27) (3 39) (4 46)) 2)))
	      (and (= rank 1) val?)))
      (test (let ((rank val? (rank (map (1 12) (2 27) (3 39) (4 46)) 3.5)))
	      (and (= rank 2) (not val?))))
      (test (let ((rank val? (rank (map (1 12) (2 27) (3 39) (4 46)) 5)))
	      (and (= rank 3) (not val?))))
      (test (let ((rank val? (rank (map) 5)))
	      (and (= rank -1) (not val?))))
      (test (eql (at-rank (set 4 8 2 3 6) 3) 6))
      (test (eql (at-rank (bag 4 8 2 4 3 2 6) 3) 6))
      (test (handler-case (progn (at-rank (set) 0) nil)
              (simple-type-error (e) e)))
      (test (handler-case (progn (at-rank (set 0) -1) nil)
              (simple-type-error (e) e)))
      (test (handler-case (progn (at-rank (set 0) 1) nil)
              (simple-type-error (e) e)))
      (test (handler-case (progn (at-rank (set 0 1) 2) nil)
              (simple-type-error (e) e)))
      (test (handler-case (progn (at-rank (set 0 1) 3) nil)
              (simple-type-error (e) e)))
      (test (handler-case (progn (at-rank (bag 0) -1) nil)
              (simple-type-error (e) e)))
      (test (handler-case (progn (at-rank (bag) 0) nil)
              (simple-type-error (e) e)))
      (test (handler-case (progn (at-rank (bag 0) 1) nil)
              (simple-type-error (e) e)))
      (test (handler-case (progn (at-rank (bag 0 1) 2) nil)
              (simple-type-error (e) e)))
      (test (handler-case (progn (at-rank (bag 0 1) 3) nil)
              (simple-type-error (e) e)))
      (test (handler-case (progn (at-rank (map (1 3) (2 10)) -1) nil)
              (simple-type-error (e) e)))
      (test (handler-case (progn (at-rank (map) 0) nil)
              (simple-type-error (e) e)))
      (test (handler-case (progn (at-rank (map (1 3) (2 10)) 2) nil)
              (simple-type-error (e) e)))
      (test (handler-case (progn (at-rank (map (1 3) (2 10)) 3) nil)
              (simple-type-error (e) e)))
      (test (let ((key val (at-rank (map ('a 3) ('d 7) ('c 3) ('g 1) ('e 6)) 3)))
	      (and (eq key 'e) (eql val 6))))
      (test (let ((key val (at-rank (tuple (+k0+ 'foo) (+k1+ 'bar) (+k2+ "xyzzy") (+k3+ 42)) 2)))
	      ;; The current tuple implementation keeps the keys in the order of the `def-tuple-key' forms.
	      (and (eq key +k2+) (equal val "xyzzy"))))
      ;; Good start, but &&& more to do here.
      (test (equal (reduce (lambda (x y) (cons y x)) (seq 3 7 9 13)
			   :initial-value nil :from-end t :start 1 :end 3)
		   '(7 9)))
      (test (eql (lookup (map (#C(5 16) 41) (#C(-4 15) 43) (-8 52) (-9 53) (#C(14 8) 42))
                         #C(-4 15))
                 43))
      (dolist (x (list (wb-set 3 17 'a '(mumble))
		       (wb-custom-set 'erapmoc 3 17 'a '(mumble))
		       (ch-set 19 7 'c '(eek))
		       (ch-custom-set 'erapmoc 19 7 'c '(eek))
		       (wb-bag 7 2 3 'd 2 9 4 2 7 'd)
		       (wb-custom-bag 'erapmoc 7 2 3 'd 2 9 4 2 7 'd)
		       (wb-map ('a 'foo) (7 14) ('(yow) '(x y zzy)))
		       (wb-custom-map 'erapmoc 'erapmoc ('a 'foo) (7 14) ('(yow) '(x y zzy)))
		       (ch-map ('a 'baz) (7 42) ('(yow!) '(y zzy x)))
		       (ch-custom-map 'erapmoc 'erapmoc ('a 'baz) (7 42) ('(yow!) '(y zzy x)))
		       (wb-seq 21 #\q 19 'zot '(urgh) 17.2d0 'glitch)
		       (dyn-tuple (+k0+ 27) (+k1+ 'foo) (+k2+ -21.3) (+k4+ '(fizz buzz)))
		       (wb-2-relation ('a 3) ('a 4) ('b 5) ('c 6))
		       (wb-custom-2-relation 'erapmoc 'erapmoc ('a 3) ('a 4) ('b 5) ('c 6))
		       (ch-2-relation ('a 3) ('a 4) ('b 5) ('c 6))
		       (ch-custom-2-relation 'erapmoc 'erapmoc ('a 3) ('a 4) ('b 5) ('c 6))))
	(test (equal? x (eval (make-load-form x))))))))

(defun Test-Misc-4 ()
  (macrolet ((test (form)
	       `(unless ,form
		  (error "Test failed: ~S" ',form))))
    ;; Bug in `WB-Set-Tree-Find-Equal'.
    (test (null (lookup (with (wb-set -5 -4 -3 -2 -1 1 2 3 4 5) 0) 0.0)))
    ;; Test `convert' methods that take custom compare-fns.
    (test (equal (convert 'list (convert 'wb-set (set 1 2) :compare-fn-name 'erapmoc))
		 '(2 1)))
    (test (equal (convert 'list (convert 'wb-set '(1 2) :compare-fn-name 'erapmoc))
		 '(2 1)))
    (test (equal (convert 'list (convert 'wb-set #(1 2) :compare-fn-name 'erapmoc))
		 '(2 1)))
    (test (equal (convert 'list (convert 'wb-set (seq 1 2) :compare-fn-name 'erapmoc))
		 '(2 1)))
    (let ((s (wb-custom-set 'erapmoc 2 6)))
      (test (eq s (convert 'wb-set s :compare-fn-name 'erapmoc))))
    (test (equal (convert 'list (convert 'ch-set (set 3 7) :compare-fn-name 'erapmoc))
		 '(7 3)))
    (test (equal (convert 'list (convert 'ch-set '(3 7) :compare-fn-name 'erapmoc))
		 '(7 3)))
    (test (equal (convert 'list (convert 'ch-set #(3 7) :compare-fn-name 'erapmoc))
		 '(7 3)))
    (let ((s (ch-custom-set 'erapmoc 2 6)))
      (test (eq s (convert 'ch-set s :compare-fn-name 'erapmoc))))
    (test (equal (convert 'list (convert 'wb-bag (bag 1 2 2 3) :compare-fn-name 'erapmoc))
		 '(3 2 2 1)))
    (let ((b (wb-custom-bag 'erapmoc 1 2 2 3)))
      (test (eq b (convert 'wb-bag b :compare-fn-name 'erapmoc))))
    (test (equal (convert 'list (convert 'wb-set (bag 1 2 2 3)))
		 '(1 2 3)))
    (test (equal (convert 'list (convert 'wb-set (bag 1 2 2 3) :compare-fn-name 'erapmoc))
		 '(3 2 1)))
    (test (equal (convert 'list (convert 'wb-bag (set 1 2 3)))
		 '(1 2 3)))
    (test (equal (convert 'list (convert 'wb-bag (set 1 2 3) :compare-fn-name 'erapmoc))
		 '(3 2 1)))
    (test (equal (convert 'list (convert 'wb-bag '(1 2 3 2)))
		 '(1 2 2 3)))
    (test (equal (convert 'list (convert 'wb-bag '(1 2 3 2) :compare-fn-name 'erapmoc))
		 '(3 2 2 1)))
    (test (equal (convert 'list (convert 'wb-bag (seq 1 2 3 2)))
		 '(1 2 2 3)))
    (test (equal (convert 'list (convert 'wb-bag (seq 1 2 3 2) :compare-fn-name 'erapmoc))
		 '(3 2 2 1)))
    (test (equal (convert 'list (convert 'wb-map (ch-map ('a 3) ('b 4))))
		 '((a . 3) (b . 4))))
    (test (equal (convert 'list (convert 'wb-map (ch-map ('a 3) ('b 4)) :key-compare-fn-name 'erapmoc))
		 '((b . 4) (a . 3))))
    (test (equal (convert 'list (convert 'wb-map (wb-map ('a 3) ('b 4))))
		 '((a . 3) (b . 4))))
    (test (equal (convert 'list (convert 'wb-map (wb-map ('a 3) ('b 4)) :key-compare-fn-name 'erapmoc))
		 '((b . 4) (a . 3))))
    (let ((m (wb-custom-map 'erapmoc nil ('a 7) ('b 42))))
      (test (eq m (convert 'wb-map m :key-compare-fn-name 'erapmoc))))
    (let ((m (ch-custom-map 'erapmoc nil ('a 7) ('b 42))))
      (test (eq m (convert 'ch-map m :key-compare-fn-name 'erapmoc))))
    (let ((m (wb-map ('a 3) ('b 42))))
      (test (equal? m (gmap (:result wb-map) nil (:arg wb-map m)))))
    (test (equal (convert 'list (convert 'map '((a . 3) (b . 4))))
		 '((a . 3) (b . 4))))
    (test (equal (convert 'list (convert 'wb-map '((a . 3) (b . 4)) :key-compare-fn-name 'erapmoc))
		 '((b . 4) (a . 3))))
    (test (equal (convert 'list (convert 'map (seq '(a . 3) '(b . 4))))
		 '((a . 3) (b . 4))))
    (test (equal (convert 'list (convert 'wb-map (seq '(a . 3) '(b . 4)) :key-compare-fn-name 'erapmoc))
		 '((b . 4) (a . 3))))
    (test (equal (convert 'list (convert 'map (seq '(a . 3) '(b . 4)) :input-sorted? t))
		 '((a . 3) (b . 4))))
    (test (equal (convert 'list (convert 'wb-map (seq '(a . 3) '(b . 4))
					 :input-sorted? t :key-compare-fn-name 'erapmoc))
		 '((b . 4) (a . 3))))
    (test (equal? (convert 'wb-map (bag 1 2 2 3))
		  (map (1 1) (2 2) (3 1))))
    (test (equal? (convert 'list (convert 'ch-map (wb-map (3 'a) (4 'b))))
		  '((3 . a) (4 . b))))
    (test (equal? (convert 'list (convert 'ch-map (wb-map (3 'a) (4 'b)) :key-compare-fn-name 'erapmoc))
		  '((4 . b) (3 . a))))
    (test (equal? (convert 'list (convert 'ch-map (seq '(3 . a) '(4 . b))))
		  '((3 . a) (4 . b))))
    (test (equal? (convert 'list (convert 'ch-map (seq '(3 . a) '(4 . b)) :key-compare-fn-name 'erapmoc))
		  '((4 . b) (3 . a))))
    (test (equal? (convert 'list (convert 'ch-map (list '(3 . a) '(4 . b))))
		  '((3 . a) (4 . b))))
    (test (equal? (convert 'list (convert 'ch-map (list '(3 . a) '(4 . b)) :key-compare-fn-name 'erapmoc))
		  '((4 . b) (3 . a))))
    (test (equal? (convert 'list (convert 'ch-map #((3 . a) (4 . b))))
		  '((3 . a) (4 . b))))
    (test (equal? (convert 'list (convert 'ch-map #((3 . a) (4 . b)) :key-compare-fn-name 'erapmoc))
		  '((4 . b) (3 . a))))
    (let ((ht (make-hash-table)))
      (setf (gethash 'a ht) 17)
      (setf (gethash 'b ht) 31)
      (test (equal? (convert 'wb-map ht) (wb-map ('a 17) ('b 31))))
      (test (equal? (convert 'ch-map ht) (ch-map ('a 17) ('b 31)))))
    (let ((m (ch-map ('a 3) ('b 42))))
      (test (equal? m (gmap (:result ch-map) nil (:arg ch-map m)))))
    ;; Check that our hash mixing operations do NOT check for overflow.
    (test (= (hash-mix-func most-negative-fixnum most-negative-fixnum) 0))

    (let ((long (gmap (:result seq) nil (:arg index 0 64))))
      (test (= (size long) 64))
      (test (not (char-seq? long)))
      (test (eql (lookup long 23) 23))
      (test (eql (first long) 0))
      (test (eql (last long) 63))
      (test (equal? (with-first long -1) (gmap (:result seq) nil (:arg index -1 64))))
      (test (equal? (less-first long) (gmap (:result seq) nil (:arg index 1 64))))
      (test (equal? (with-last long 64) (gmap (:result seq) nil (:arg index 0 65))))
      (test (equal? (less-last long) (gmap (:result seq) nil (:arg index 0 63))))
      (test (equal? (insert long 37 'a) (concat (gmap (:result seq) nil (:arg index 0 37))
						(seq 'a)
						(gmap (:result seq) nil (:arg index 37 64)))))
      (test (equal? (splice long 37 (seq 'a 'b)) (concat (gmap (:result seq) nil (:arg index 0 37))
							 (seq 'a 'b)
							 (gmap (:result seq) nil (:arg index 37 64)))))
      (test (equal? (less long 41) (concat (gmap (:result seq) nil (:arg index 0 41))
					   (gmap (:result seq) nil (:arg index 42 64)))))
      (test (equal? (subseq long 7 53) (gmap (:result seq) nil (:arg index 7 53))))
      (test (equal? (reverse long) (gmap (:result seq) nil (:arg index 64 0 :incr -1)))))

    (test (= (search "xyz" (seq ($ "xyzzyfubarxyz"))) 0))
    (test (= (search "xyz" (seq ($ "quuxxyzzyfubarxyz"))) 4))
    (test (= (search "xyz" (seq ($ "quuxxyzzyfubarxyzyz")) :from-end t) 14))
    (test (= (search "xxx" (seq ($ "xyxxyxxxxxy"))) 5))
    (test (= (search "xxx" (seq ($ "xyxxyxxxxxy")) :start1 1 :start2 1) 2))
    (test (= (search "xxx" (seq ($ "xyxxyxxxxxy")) :start2 2 ) 5))
    (test (= (search "xxx" (seq ($ "xyxxyxxxxxy")) :from-end t) 7))
    (test (= (search (seq 0 1) (seq 2 4 6 1 3 5) :key #'oddp) 2))

    (test (null (mismatch "xyz" (seq ($ "xyz")))))
    (test (= (mismatch "xyz" (seq ($ "xyq"))) 2))
    (test (= (mismatch "" (seq ($ "xyq"))) 0))
    (test (= (mismatch (seq ($ "abcdefghijklmnop")) "ghijx" :start1 6) 10))
    (test (= (mismatch (seq ($ "abcdefghijklmnop")) "xwijk" :start1 6 :end1 11 :from-end t) 8))
    (test (null (mismatch (seq ($ "abcdefghijklmnop")) "fghij" :start1 5 :end1 10)))))

;;; Outlined so SBCL constant propagation doesn't do the test at compile time.
(defun hash-mix-func (a b)
  (hash-mix a b))

(defun Test-Reader ()
  (macrolet ((test (str form)
	       `(let ((r (parse ',str)))
		  (unless (equal? (eval r) (eval ',form))
		    (error "Reader test failed: ~S, ~S, ~S" ,str r ',form)))))
    (flet ((parse (str)
	     (with-standard-io-syntax
	       (let ((*readtable* *fset-readtable*)
		     (*package* (find-package :fset)))
		 (read-from-string str))))
	   (error-test (str)
	     (with-standard-io-syntax
	       (let ((*readtable* *fset-readtable*)
		     (*package* (find-package :fset)))
		 (block nil
		   (handler-case
		       (read-from-string str)
		     (error () (return t)))
		   (error "Reading ~s did not cause an error" str))))))

      (test "#[1]" (seq 1))
      (error-test "#[")
      (test "#[1 #$(seq 3 4)]" (seq 1 3 4))
      (test "#{1 2}" (set 1 2))
      (error-test "#{")
      (test "#{1 2 #$(set 3 5)}" (set 1 2 3 5))
      (test "#{}" (empty-set))
      (test "##{17 42}" (ch-set 17 42))
      (test "#{| (1 2) (3 4) |}" (map (1 2) (3 4)))
      (test "##{| (1 2) (3 4) |}" (ch-map (1 2) (3 4)))
      (error-test "#{| |x")
      (error-test "#{|}")
      (test "#{%%}" (bag))
      (error-test "#{%%x}")
      (error-test "#{%%")
      (test "#{% 1 1 2 3 4 4 5 %}" (bag 1 1 2 3 4 4 5))
      (test "#{% #%(1 4) 3 %}" (bag 1 1 1 1 3))
      (error-test "#{% #%x %}")
      (error-test "#{% #%(1) %}")
      (error-test "#{% #%(1 . 2) %}")
      (error-test "#{% #%(1 2 . 3) %}")
      (error-test "#{% #%(1 2 3) %}")
      (test "#{| #$(map (1 2)) (3 4) |}" (map (1 2) (3 4)))
      (test "#~< >" (tuple))
      (error-test "#~[")
      (error-test "#~<")
      (test "#~< (+K0+ 1) >" (tuple (+K0+ 1)))
      (test "#~< #$(tuple (+K0+ 1)) (+K1+ 3) >" (tuple (+K0+ 1) (+K1+ 3))))))

(defun Test-Rereader ()
  (with-standard-io-syntax
    (let ((*readtable* *fset-rereading-readtable*)
	  (*package* (find-package :fset))
	  (*print-readably* t))
      (dolist (x (list (seq) (set) (seq 1 2 3) (set 'a 'b 2)
		       (wb-custom-set 'erapmoc 3 42)
		       (ch-set 32 19)
		       (ch-custom-set 'erapmoc 11 41)
		       (map) (tuple) (bag)
		       (map (1 2) (3 4))
		       (wb-custom-map 'erapmoc nil ('foo 3) ('bar 19))
		       (ch-custom-map 'erapmoc nil ('foo 3) ('bar 19))
		       (with-default (map (1 2) (3 4)) 'x)
		       (wb-custom-map 'erapmoc nil (1 2) (3 'xyzzy) :default 'fubar)
		       (ch-custom-map 'erapmoc nil (1 2) (3 'xyzzy) :default 'fubar)
		       (with-default (seq 4 17 33) 42)
		       (tuple (+K0+ 1))
		       (bag 1 '(% foo 3))
		       (bag 1 2)
		       (bag 1 1)
		       (wb-custom-bag 'erapmoc 1 1 2)))
	 (let ((str (prin1-to-string x)))
	   ;; (let ((*print-readably* nil)) (format t "str = ~s~%"str))
	   (let ((y (read-from-string str)))
	     (unless (equal? x y)
	       (error "Rereader failure: ~s, ~s, ~s"
		      x str y)))))
      ;; Error cases
      (dolist (x '("#[" "#{|}" "#{| |x" "#{%%" "#{%%x" "#{" "#{%" "#~<" "#~["
		   "#~< 1 >" "#~< (1) >" "#~< ( 1 . 2 ) >" "#~< (1 2 . 3) >"
		   "#~< (1 2 3) >" "#~< #(1 2) >"))
	 (block nil
	   (handler-case (read-from-string x)
	     (error () (return nil)))
	   (error "Rereading ~s did not cause an error" x))))))

(defun Test-Compare-Lexicographically ()
  (macrolet ((test (form)
	       `(unless ,form
		  (error "Test failed: ~S" ',form))))
    (flet ((equal? (a b)
	     (and (eql (compare-lexicographically a b) :equal)
		  (eql (compare-lexicographically b a) :equal)))
	   (less-than? (a b)
	     (and (eql (compare-lexicographically a b) :less)
		  (eql (compare-lexicographically b a) :greater)))
	   (unequal? (a b)
	     (and (eql (compare-lexicographically a b) :unequal)
		  (eql (compare-lexicographically b a) :unequal))))
      (test (equal? "a" "a"))
      (test (equal? "a" (make-array '(1) :element-type 'base-char
				    :initial-element #\a)))
      (test (less-than? "a" "b"))
      (test (less-than? "a" "ab"))
      (test (less-than? "ab" "b"))

      (test (let ((v #(1))) (equal? v v)))
      (test (equal? "a" (make-array '(1) :element-type 'character
				 :adjustable t :initial-element #\a)))
      (test (less-than? "a" (make-array '(1) :element-type 'character
					:adjustable t :initial-element #\b)))
      (test (less-than? "a" (make-array '(2) :element-type 'character
					:adjustable t
					:initial-contents '(#\a #\b))))
      (test (less-than? "ab" (make-array '(1) :element-type 'character
					 :adjustable t :initial-element #\b)))

      (test (less-than? #(1 2 3) (make-array '(3) :initial-contents '(1 3 3) :adjustable t)))
      (test (less-than? #(1 2) (make-array '(3) :initial-contents '(1 2 3) :adjustable t)))
      (test (less-than? #(1) (make-array '(3) :initial-contents '(1 2 3) :adjustable t)))
      (test (less-than? (make-array '(2) :initial-contents '(1 3) :adjustable t) #(1 3 5)))
      (test (less-than? (make-array '(1) :initial-contents '(1) :adjustable t) #(1 3 5)))
      (test (less-than? (make-array '(0) :adjustable t) #(1)))
      (test (less-than? (make-array '(1) :initial-element 1 :adjustable t)
                        (make-array '(1) :initial-element 2 :adjustable t)))

      (test (equal? nil nil))
      (test (equal? (list 1) (list 1)))
      (test (less-than? nil '(1)))
      (test (less-than? '(1) '(1 2)))
      (test (less-than? '(1 2) '(3)))
      (test (less-than? '(1 2) '(1 3)))

      (test (equal? #() #()))
      (test (equal? (vector) (vector)))
      (test (equal? (vector 1) (vector 1)))
      (test (less-than? #() #(1)))
      (test (less-than? #(1) #(2)))
      (test (less-than? #(1) #(1 2)))
      (test (less-than? #(1 2) #(3)))
      (test (less-than? #(1 2) #(1 3)))

      (test (less-than? (seq) (seq 1)))
      (test (less-than? (seq 1) (seq 2)))
      (test (less-than? (seq 1) (seq 1 2)))
      (test (less-than? (seq 1 2) (seq 3)))
      (test (less-than? (seq 1 2) (seq 1 3)))

      (test (equal? #() (make-array '(0) :adjustable t)))
      (test (equal? #(1) (make-array '(1) :adjustable t
				     :initial-contents '(1))))
      (test (equal? #(#\a) "a"))
      (test (equal? "a" #(#\a)))
      (test (less-than? "a" #(#\a #\b)))
      (test (less-than? #(#\a) "ab"))
      (test (less-than? "ab" (make-array '(1) :initial-contents '(#\c))))
      (test (less-than? "ab" (make-array '(2) :initial-contents '(#\a #\c))))

      (test (unequal? (list (make-instance 'my-unhandled-obj))
		      (list (make-instance 'my-unhandled-obj))))
      (test (unequal? (vector (make-instance 'my-unhandled-obj))
		      (vector (make-instance 'my-unhandled-obj))))
      (test (unequal?
	     (make-array '(1)
			 :initial-element (make-instance 'my-unhandled-obj)
			 :adjustable t)
	     (vector (make-instance 'my-unhandled-obj)))))))

(defun Test-Equivalent-Sets (&optional (size 20) (reps 1000))
  (declare (optimize (debug 3)))
  (macrolet ((test (form)
	       `(unless ,form
		  (error "Test in Test-Equivalent-Sets failed: ~S" ',form))))
    (dotimes (i reps)
      (let* ((size (+ 5 (random size)))
	     (objs (gmap (:result list) (fn (i) (make-instance 'my-unhandled-obj :value i))
			 (:arg index 0 size)))
	     (all (convert 'set objs)))
	(flet ((%rset ()
		 (let ((max (random (1+ size))))
		   (gmap (:result set :filterp (fn (_x) (= (random 2) 0)))
                         (fn (x _i) x)
			 (:arg list objs) (:index 0 max)))))
	  (let* ((o (elt objs (random size)))
		 (s0 (set o))
		 (s1 (%rset))
		 (s2 (%rset))
		 (l1 (convert 'list s1))
		 (l2 (convert 'list s2))
		 (lu (union l1 l2))
		 (li (intersection l1 l2))
		 (su (union s1 s2))
		 (si (intersection s1 s2))
		 (sd1 (set-difference s1 s2))
		 (sd2 (set-difference s2 s1)))
	    (test (member? o s0))
	    (test (member? o (union s0 s1)))
	    (test (member? o (union s0 s2)))
	    (test (equal? (union s0 s1) (with s1 o)))
	    (test (equal? (union s2 s0) (with s2 o)))
	    (test (subset? s1 (with s1 o)))
	    (test (subset? s2 (with s2 o)))
	    (test (= (size (union s0 s1))
		     (if (member? o s1)
			 (size s1)
			 (1+ (size s1)))))
	    (test (= (size li) (size si)))
	    (test (= (size lu) (size su)))
	    (test (equal? (convert 'set li) si))
	    (test (equal? (convert 'set lu) su))
	    (test (subset? s1 su))
	    (test (subset? s2 su))
	    (test (subset? si s1))
	    (test (subset? si s2))
	    (test (subset? si all))
	    (test (subset? su all))
	    (test (subset? sd1 s1))
	    (test (subset? sd2 s2))
	    (test (empty? (intersection sd1 s2)))
	    (test (disjoint? sd1 s2))
	    (test (empty? (intersection sd2 s1)))
	    (test (disjoint? sd2 s1))
	    (test (disjoint? sd1 sd2))
	    (test (equal? (union sd1 sd2)
			  (set-difference su si)))))))))

(defun Test-Modify-Macros ()
  ;; Use EVAL so defmacro bodies can be covered
  (macrolet ((test (form)
	       `(unless ,form
		  (error "Test failed: ~S" ',form))))
    (test (eval '(let ((s (set 1)))
		  (and
		   (equal? (includef s 2) (set 1 2))
		   (equal? s (set 1 2))))))
    (test (eval '(let ((s (set 1 2 3)))
		  (and
		   (equal? (excludef s 2) (set 1 3))
		   (equal? s (set 1 3))))))
    (test (eval '(let ((s1 (set 1 2 3))
		       (s2 (set 3 4 5)))
		  (intersectf s1 s2)
		  (equal? s1 (set 3)))))
    (test (eval '(let ((s (set 1 2 3)))
		  (imagef s #'(lambda (x) (+ x 6)))
		  (equal? s (set 7 8 9)))))
    (test (eval '(let ((s '(1 2 3)))
		  (and (eq (appendf s '(4 5 6)) s)
		   (equal s '(1 2 3 4 5 6))))))
    (test (eval '(let ((s (seq 1 2 3)))
		  (and (eq (appendf s (seq 4 5 6)) s)
		   (equal? s (seq 1 2 3 4 5 6))))))
    (test (eval '(let ((s '(1 2 3)))
		  (and (eq (prependf s '(4 5 6)) s)
		   (equal s '(4 5 6 1 2 3))))))
    (test (eval '(let ((s (seq 1 2 3)))
		  (and (eq (prependf s (seq 4 5 6)) s)
		   (equal? s (seq 4 5 6 1 2 3))))))
    (test (eval '(let ((s (seq 1 2 3)))
		  (and (eql (pop-first s) 1)
		   (equal? s (seq 2 3))))))
    (test (eval '(let ((s (seq 1 2 3)))
		  (and (eql (pop-last s) 3)
		   (equal? s (seq 1 2))))))
    (test (eval '(let ((m (map (1 2) (3 6))))
		  (and (eql (composef m (lambda (x) (when x (1+ x)))) m)
		   (equal? m (map (1 3) (3 7)))))))
    (test (eval '(let ((s (seq 1 2)))
		  (and (eql (push-first s :a) s)
		   (equal? (seq :a 1 2) s)))))))

(defun Test-Functional-Deep-Update ()
  (macrolet ((test (form)
	       `(unless ,form
		  (error "Test failed: ~S" ',form))))
    (let ((s (seq 1 (seq 2 3) 4)))
      (test (and (equal? (update (constantly :a) s 1 1) (seq 1 (seq 2 :a) 4))
		 (equal? s (seq 1 (seq 2 3) 4))))
      (test (and (equal? (update #'(lambda (x) (declare (ignore x)) :a)
				 s 1 1)
                         (seq 1 (seq 2 :a) 4))
		 (equal? s (seq 1 (seq 2 3) 4))))
      (test (equal? (update '- s 1 1) (seq 1 (seq 2 -3) 4))))))

(defun Test-Set-Operations (i)
  (declare (optimize (speed 0) (safety 3) (debug 3)))
  (let ((fs0-cfn (if (logbitp 0 i) 'erapmoc 'compare))
	((fs0 (empty-wb-set fs0-cfn)))
	(s0 nil)
	(fs1-cfn (if (logbitp 1 i) 'erapmoc 'compare))
	((fs1 (empty-wb-set fs1-cfn)))
	(s1 nil))
    (dotimes (j 100)
      (let* ((r (Make-My-Integer (random 200)))
	     (tmp (with fs0 r)))
	(pushnew r s0 :test #'equal?)
	(unless (verify tmp)
	  (error "Set verify failed on iteration ~D, adding ~A" i r))
	(unless (= (size tmp) (length s0))
	  (error "Set size or with failed on iteration ~D, adding ~A: ~D, ~D" i r
		 (size tmp) (length s0)))
	(unless (contains? tmp r)
	  (error "Set contains? failed on iteration ~D" i))
	(unless (and (subset? fs0 tmp)
		     (or (contains? fs0 r) (not (subset? tmp fs0))))
	  (error "Set subset? failed on iteration ~D" i))
	(setq fs0 tmp)
	;; Can't say much about `hash-value', but at least we can check that it doesn't crash.
	(hash-value fs0)))
    (dotimes (j 100)
      (let* ((r (Make-My-Integer (random 200)))
	     (tmp (with fs1 r)))
	(pushnew r s1 :test #'equal?)
	(unless (verify tmp)
	  (error "Set verify failed on iteration ~D, adding ~A" i r))
	(unless (= (size tmp) (length s1))
	  (error "Set size or with failed on iteration ~D, adding ~A: ~D, ~D" i r
		 (size tmp) (length s1)))
	(unless (and (subset? fs1 tmp)
		     (or (contains? fs1 r) (not (subset? tmp fs1))))
	  (error "Set subset? failed on iteration ~D" i))
	(setq fs1 tmp)
	(unless (eqv (disjoint? fs0 fs1)
		     (disjoint? fs1 fs0)
		     (not (do-set (x fs1 nil)
			    (when (contains? fs0 x)
			      (return t)))))
	  (error "Set disjoint? failed on iteration ~D" i))))
    (dotimes (j 20)
      (let ((r (Make-My-Integer (random 200))))
	(unless (eqv (contains? fs0 r) (member r s0 :test #'equal?))
	  (error "Set contains? failed (fs0) on iteration ~D, ~A" i r))
	(setq s0 (remove r s0 :test #'equal?))
	(let ((tmp (less fs0 r)))
	  (unless (verify tmp)
	    (error "Set verify failed on iteration ~D, removing ~A" i r))
	  (unless (= (size tmp) (length s0))
	    (error "Set size or less failed (fs0) on iteration ~D, removing ~A" i r))
	  (setq fs0 tmp))))
    (dotimes (j 20)
      (let ((r (Make-My-Integer (random 200))))
	(unless (eqv (contains? fs1 r) (member r s1 :test #'equal?))
	  (error "Set contains? failed (fs1) on iteration ~D" i))
	(setq s1 (remove r s1 :test #'equal?))
	(let ((tmp (less fs1 r)))
	  (unless (verify tmp)
	    (error "Set verify failed on iteration ~D, removing ~A" i r))
	  (unless (= (size tmp) (length s1))
	    (error "Set size or less failed (fs1) on iteration ~D, removing ~A" i r))
	  (setq fs1 tmp))))
    (when (= i 0)
      (let ((tmp (with fs0 nil)))
	(unless (verify tmp)
	  (error "Set verify failed adding NIL"))
	(setq tmp (less tmp nil))
	(unless (verify tmp)
	  (error "Set verify failed removing NIL"))))
    (unless (contains? fs0 (arb fs0))
      (error "Set arb/contains? failed (fs0) on iteration ~D" i))
    (unless (contains? fs1 (arb fs1))
      (error "Set arb/contains? failed (fs1) on iteration ~D" i))
    (unless (member (compare (least fs0)
			     (reduce (lambda (mi1 mi2)
				       (if (less-than?-cmp (My-Integer-Value mi1) (My-Integer-Value mi2)
							   (compare-fn fs0))
					   mi1 mi2))
				     s0))
		    '(:equal :unequal))
      (error "Set least failed on iteration ~D" i))
    (unless (member (compare (greatest fs0)
			     (reduce (lambda (mi1 mi2)
				       (if (greater-than?-cmp (My-Integer-Value mi1) (My-Integer-Value mi2)
							      (compare-fn fs0))
					   mi1 mi2))
				     s0))
		    '(:equal :unequal))
      (error "Set greatest failed on iteration ~D" i))
    (unless (equal? fs0 (convert 'wb-set s0 :compare-fn-name fs0-cfn))
      (error "Set equal? failed (fs0) on iteration ~D" i))
    (unless (equal? fs1 (convert 'wb-set s1 :compare-fn-name fs1-cfn))
      (error "Set equal? failed (fs1) on iteration ~D" i))
    (unless (equal? (convert 'list fs0)
		    ;; Written this way to test both the driver and the iterator.
		    (gmap (:result list) (fn (a b) (if (evenp i) a b))
			  (:arg set fs0)
			  (:arg set fs0)))
      (error "Set iterator failed (fs0) on iteration ~D" i))
    (unless (equal? fs1 (gmap (:result wb-set :compare-fn-name fs1-cfn) nil (:arg list (convert 'list fs1))))
      (error "Set iterator or accumulator failed (fs1) on iteration ~D" i))
    (unless (equal? fs0 (convert 'wb-set (sort s0 (fn (a b) (less-than?-cmp a b #'compare)))
				 :input-sorted? t :compare-fn-name fs0-cfn))
      (error "Set conversion from sorted list failed (fs0) on iteration ~D" i))
    (unless (equal? fs0 (convert 'wb-set (convert 'seq s0) :compare-fn-name fs0-cfn))
      (error "Set conversion from seq failed (fs0) on iteration ~D" i))
    (unless (equal? fs0 (convert 'wb-set (sort (convert 'seq s0) (fn (a b) (less-than?-cmp a b #'compare)))
				 :input-sorted? t :compare-fn-name fs0-cfn))
      (error "Set conversion from sorted seq failed (fs0) on iteration ~D" i))
    (unless (equal? fs0 (convert 'wb-set (convert 'vector s0) :compare-fn-name fs0-cfn))
      (error "Set conversion from vector failed (fs0) on iteration ~D" i))
    (unless (equal? fs0 (convert 'wb-set (sort (convert 'vector s0) (fn (a b) (less-than?-cmp a b #'compare)))
				 :input-sorted? t :compare-fn-name fs0-cfn))
      (error "Set conversion from sorted vector failed (fs0) on iteration ~D" i))
    (unless (equal? (gmap (:result list) nil (:arg fun-sequence fs0))
		    (convert 'list fs0))
      (error "Set fun-iterator failed on iteration ~D" i))
    (unless (equal? (gmap (:result list) nil (:arg fun-sequence fs0 :from-end? t))
		    (reverse (convert 'list fs0)))
      (error "Set rev-fun-iterator failed on iteration ~D" i))
    (flet ((check-pref (result label &optional right?)
	     (let ((bad (gmap :or (fn (x) (let ((val? val (lookup result x)))
					    (and val? (not (eq x val)) x)))
			      (:arg set (if right? fs1 fs0)))))
	       (when bad
		 (error "~A failed ~A preference on iteration ~D: ~A" label (if right? "right" "left") i bad)))))
      (let ((fsu (union fs0 fs1))
	    (su (cl:union s0 s1 :test #'equal?)))
	(unless (and (verify fsu) (equal? fsu (convert 'wb-set su :compare-fn-name fs0-cfn)))
	  (error "Set union failed on iteration ~D " i))
	(check-pref fsu "Set union"))
      (let ((fsi (intersection fs0 fs1))
	    (si (cl:intersection s0 s1 :test #'equal?)))
	(unless (and (verify fsi) (equal? fsi (convert 'wb-set si :compare-fn-name fs0-cfn)))
	  (error "Set intersection failed on iteration ~D " i))
	(check-pref fsi "Set intersection"))
      (let ((fsd (set-difference fs0 fs1))
	    (sd (cl:set-difference s0 s1 :test #'equal?)))
	(unless (and (verify fsd) (equal? fsd (convert 'wb-set sd :compare-fn-name fs0-cfn)))
	  (error "Set difference failed on iteration ~D " i))
	(check-pref fsd "Set difference"))
      (let ((fsd1 fsd2 (set-difference-2 fs0 fs1))
	    (sd1 (cl:set-difference s0 s1 :test #'equal?))
	    (sd2 (cl:set-difference s1 s0 :test #'equal?)))
	(unless (and (verify fsd1) (equal? fsd1 (convert 'wb-set sd1 :compare-fn-name fs0-cfn)))
	  (error "Set-difference-2 failed (fsd1) on iteration ~D " i))
	(check-pref fsd1 "Set difference-2")
	(unless (and (verify fsd2) (equal? fsd2 (convert 'wb-set sd2 :compare-fn-name fs1-cfn)))
	  (error "Set-difference-2 failed (fsd2) on iteration ~D " i))
	(check-pref fsd2 "Set difference-2" t)))
    (when (eq fs0-cfn fs1-cfn)
      (let ((fs0a (less fs0 (Pick fs0)))
	    (fs0b (less fs0 (Pick fs0))))
	(unless (eq (compare fs0a fs0b)
		    (Set-Compare fs0a fs0b))
	  (error "Set compare failed (fs0) on iteration ~D" i)))
      (let ((fs1a (less fs1 (Pick fs1)))
	    (fs1b (less fs1 (Pick fs1))))
	(unless (eq (compare fs1a fs1b)
		    (Set-Compare fs1a fs1b))
	  (error "Set compare failed (fs1) on iteration ~D" i))))
    (unless (gmap (:result and) (fn (x i)
				  (and (eql (rank fs0 x) i)
				       (eql (fset2:rank fs0 x) i)
				       (equal? x (at-rank fs0 i))))
		  (:arg set fs0)
		  (:arg index 0 (size fs0)))
      (error "Set rank, at-rank, or iterator failed"))
    (unless (gmap (:result and) (fn (x i)
				  (and (eql (index fs0 x) i)
				       (equal? x (at-index fs0 i))))
		  (:arg set fs0)
		  (:arg index 0 (size fs0)))
      (error "Set index, at-index, or iterator failed"))
    (let ((r (do ((r (random 200) (random 200)))
		 ;; Equivalent-but-unequal `My-Integer's make this a little tricky.
		 ((and (not (contains? fs0 (make-my-integer r)))
		       (not (contains? fs0 (make-my-integer (logxor r 1)))))
		  r))))
      (let ((ri (make-my-integer r))
	    ((fs0a (with fs0 ri))
	     (ri-rank (rank fs0 ri))
	     (ri-rank2 (fset2:rank fs0 ri))))
	(unless (= (1+ ri-rank) (rank fs0a ri))
	  (error "Set rank of non-member failed: ~A ~A" r fs0))
	(unless (= ri-rank2 (rank fs0a ri))
	  (error "Set fset2:rank of non-member failed: ~A ~A" r fs0))))
    fs0))


(defun Test-Map-Operations (i a-set)
  (declare (optimize (speed 0) (safety 3) (debug 3)))
  (let ((fm0-cfn (if (logbitp 1 i) 'erapmoc 'compare))
	((fm0 (empty-wb-map nil fm0-cfn)))
	(m0 nil)
	(fm1-cfn (if (logbitp 2 i) 'erapmoc 'compare))
	((fm1 (empty-wb-map nil fm1-cfn)))
	(m1 nil))
    (dotimes (j 100)
      (let* ((r (Make-My-Integer (random 100)))
	     (v (random 3))
	     (tmp (with fm0 r v)))
	(setq m0 (Alist-Assign m0 r v))
	(unless (verify tmp)
	  (error "Map verify failed (a) on iteration ~D, adding ~A -> ~A; ~D, ~D"
		 i r v m0 tmp))
	(unless (= (size tmp) (length m0))
	  (error "Map size or with failed (a) on iteration ~D, adding ~A -> ~A; ~D, ~D"
		 i r v m0 tmp))
	(setq fm0 tmp)
	;; Can't say much about `hash-value', but at least we can check that it doesn't crash.
	(hash-value fm0)))
    (dotimes (j 100)
      (let* ((r (Make-My-Integer (random 100)))
	     (v (random 3))
	     (tmp (with fm1 r v)))
	(setq m1 (Alist-Assign m1 r v))
	(unless (verify tmp)
	  (error "Map verify failed (a) on iteration ~D, adding ~A -> ~A; ~D, ~D"
		 i r v m1 tmp))
	(unless (= (size tmp) (length m1))
	  (error "Map size or with failed (b) on iteration ~D, adding ~A -> ~A; ~D, ~D"
		 i r v m1 tmp))
	(setq fm1 tmp)))
    (dotimes (j 20)
      (let ((r (Make-My-Integer (random 100)))
	    ((val val? mkey (lookup fm0 r))))
	(unless (or (not val?) (and (equal? mkey r) (not (eq mkey r))))
	  (error "Map lookup failed to return key on iteration ~D" i))
	(unless (eql val (cdr (assoc r m0 :test #'equal?)))
	  (error "Map lookup failed (fm0) on iteration ~D: ~A, ~A, ~A" i fm0 m0 r))
	(let ((tmp tval (less fm0 r)))
	  (unless (or (equal? tmp fm0) (equal? tval (@ fm0 r)))
	    (error "Map `less' failed to return value on iteration ~D" i))
	  (setq m0 (Alist-Remove m0 r))
	  (unless (verify tmp)
	    (error "Map verify failed (fm0) on iteration ~D, removing ~A" i r))
	  (unless (= (size tmp) (length m0))
	    (error "Map size or less failed (fm0) on iteration ~D, removing ~A: ~A, ~A"
		   i r tmp m0))
	  (setq fm0 tmp))))
    (dotimes (j 20)
      (let ((r (Make-My-Integer (random 100))))
	(unless (eql (lookup fm1 r) (cdr (assoc r m1 :test #'equal?)))
	  (error "Map lookup failed (fm1) on iteration ~D: ~A, ~A, ~A" i fm1 m1 r))
	(let ((tmp (less fm1 r)))
	  (setq m1 (Alist-Remove m1 r))
	  (unless (verify tmp)
	    (error "Map verify failed (fm1) on iteration ~D, removing ~A" i r))
	  (unless (= (size tmp) (length m1))
	    (error "Map size or less failed (fm1) on iteration ~D, removing ~A" i r))
	  (setq fm1 tmp))))
    (unless (domain-contains? fm0 (arb fm0))
      (error "Map arb/contains? failed (fm0) on iteration ~D" i))
    (unless (domain-contains? fm1 (arb fm1))
      (error "Map arb/contains? failed (fm1) on iteration ~D" i))
    (unless (member (compare (least fm0)
			     (reduce (lambda (mi1 mi2)
				       (if (less-than?-cmp (My-Integer-Value mi1) (My-Integer-Value mi2)
							   (key-compare-fn fm0))
					   mi1 mi2))
				     (mapcar #'car m0)))
		    '(:equal :unequal))
      (error "Map least failed on iteration ~D" i))
    (unless (member (compare (greatest fm0)
			     (reduce (lambda (mi1 mi2)
				       (if (greater-than?-cmp (My-Integer-Value mi1) (My-Integer-Value mi2)
							      (key-compare-fn fm0))
					   mi1 mi2))
				     (mapcar #'car m0)))
		    '(:equal :unequal))
      (error "Map greatest failed on iteration ~D" i))
    (unless (equal? fm0 (convert 'wb-map m0 :key-compare-fn-name fm0-cfn))
      (error "Map equal? failed (fm0) on iteration ~D" i))
    (unless (equal? fm1 (convert 'wb-map m1 :key-compare-fn-name fm1-cfn))
      (error "Map equal? failed (fm1) on iteration ~D" i))
    (unless (eq (Map-Compare (convert 'list fm0)
			     ;; Written this way to test both the driver and the iterator.
			     (gmap (:result list) (fn (k1 _v1 _k2 v2) (cons k1 v2))
				   (:arg map fm0)
				   (:arg map fm0))
			     nil)
		':equal)
      (error "Map iterator failed (fm0) on iteration ~D" i))
    (unless (equal? fm1 (gmap (:result wb-map :key-compare-fn-name fm1-cfn) nil
			      (:arg alist (convert 'list fm1))))
      (error "Map iterator/accumulator failed (fm1) on iteration ~D" i))
    (unless (equal? fm0 (convert 'wb-map (convert 'alist fm0) :input-sorted? t :key-compare-fn-name fm0-cfn))
      (error "Map conversion from sorted list failed (fm0) on iteration ~D" i))
    (unless (equal? fm0 (convert 'wb-map (convert 'seq m0) :key-compare-fn-name fm0-cfn))
      (error "Map conversion from seq failed (fm0) on iteration ~D" i))
    (unless (equal? fm0 (convert 'wb-map (sort (convert 'seq m0) (fn (a b) (less-than?-cmp a b #'compare))
					       :key #'car)
				 :input-sorted? t :key-compare-fn-name fm0-cfn))
      (error "Map conversion from sorted seq failed (fm0) on iteration ~D" i))
    (unless (equal? fm0 (convert 'wb-map (convert 'vector m0) :key-compare-fn-name fm0-cfn))
      (error "Map conversion from vector failed (fm0) on iteration ~D" i))
    (unless (equal? fm0 (convert 'wb-map (sort (convert 'vector m0) (fn (a b) (less-than?-cmp a b #'compare))
					       :key #'car)
				 :input-sorted? t :key-compare-fn-name fm0-cfn))
      (error "Map conversion from sorted vector failed (fm0) on iteration ~D" i))
    (unless (equal? (gmap (:result alist) nil (:arg fun-map fm0))
		    (convert 'alist fm0))
      (error "Map fun-iterator failed on iteration ~D" i))
    (unless (equal? (gmap (:result alist) nil (:arg fun-map fm0 :from-end? t))
		    (reverse (convert 'alist fm0)))
      (error "Map rev-fun-iterator failed on iteration ~D" i))
    (unless (eq (Map-Compare (convert 'list fm0) m0 nil) ':equal)
      (error "Map equal? failed (fm1) on iteration ~D" i))
    (unless (eq (Map-Compare (convert 'list fm1) m1 nil) ':equal)
      (error "Map equal? failed (fm1) on iteration ~D" i))
    (let ((fm0-dom (domain fm0))
	  (fm1-dom (domain fm1)))
      (let ((fm0a (with (less fm0 (Pick fm0-dom)) (Pick fm0-dom) (random 3)))
	    (fm0b (with (less fm0 (Pick fm0-dom)) (Pick fm0-dom) (random 3))))
	(unless (eq (compare fm0a fm0b)
		    (Map-Compare (convert 'list fm0a) (convert 'list fm0b) (eq fm0-cfn 'erapmoc)))
	  (error "Map compare failed (fm0) on iteration ~D" i)))
      (let ((fm1a (with (less fm1 (Pick fm1-dom)) (Pick fm1-dom) (random 3)))
	    (fm1b (with (less fm1 (Pick fm1-dom)) (Pick fm1-dom) (random 3))))
	(unless (eq (compare fm1a fm1b)
		    (Map-Compare (convert 'list fm1a) (convert 'list fm1b) (eq fm1-cfn 'erapmoc)))
	  (error "Map compare failed (fm1) on iteration ~D" i))))
    (flet ((check-pref (result source label &optional right?)
	     (let ((bad (gmap :or (fn (k v) (let ((mv mv? mk (lookup result k)))
					      (and mv? (or (not (eq k mk))
							   (and (equal? v mv) (not (eql v mv))))
						   k)))
			      (:arg map source))))
	       (when bad
		 (error "~A failed ~:[left~;right~] preference on iteration ~D: ~A"
			label right? i bad)))))
      (let ((fmu (map-union fm0 fm1))
	    (mu m0))
	(dolist (pr m1)
	  (setq mu (Alist-Assign mu (car pr) (cdr pr))))
	(unless (and (verify fmu)
		     (equal? fmu (convert 'wb-map mu :key-compare-fn-name fm0-cfn)))
	  (error "Map union failed on iteration ~D: ~A, ~A, ~A, ~A" i mu fmu fm0 fm1))
	(check-pref fmu fm0 "Map union")
	(let ((fmd1 fmd2 (map-difference-2 fmu fm0)))
	  (unless (and (equal? fm0 (map-union (restrict fmu (domain fm0)) fmd2))
		       (equal? (convert 'wb-map fm1 :key-compare-fn-name fm0-cfn)
			       (map-union (restrict fmu (domain fm1)) fmd1)))
	    (error "Map difference failed on iteration ~D" i))
	  (check-pref fmu fmd1 "Map difference")
	  (check-pref fm0 fmd2 "Map difference" t)))
      (let ((fmi (map-intersection fm0 fm1))
	    (mi nil))
	(dolist (pr m1)
	  (when (assoc (car pr) m0 :test #'equal?)
	    (setq mi (Alist-Assign mi (car pr) (cdr pr)))))
	(unless (and (verify fmi)
		     (equal? fmi (convert 'wb-map mi :key-compare-fn-name fm0-cfn)))
	  (error "Map intersection failed on iteration ~D: ~A, ~A, ~A, ~A"
		 i mi fmi fm0 fm1))
	(check-pref fmi fm0 "Map intersection")))
    (let ((fmr (restrict fm0 a-set))
	  (mr (remove-if-not #'(lambda (pr) (contains? a-set (car pr))) m0)))
      (unless (and (verify fmr)
		   (equal? fmr (convert 'wb-map mr :key-compare-fn-name fm0-cfn)))
	(error "Map restrict failed on iteration ~D: ~A, ~A" i fmr mr)))
    (let ((fmr (restrict-not fm0 a-set))
	  (mr (remove-if #'(lambda (pr) (contains? a-set (car pr))) m0)))
      (unless (and (verify fmr)
		   (equal? fmr (convert 'wb-map mr :key-compare-fn-name fm0-cfn)))
	(error "Map restrict-not failed on iteration ~D: ~A, ~A, ~A" i fmr mr fm0)))
    (unless (gmap (:result and) (fn (x _n i)
				  (and (eql (index fm0 x) i)
				       (equal? x (at-index fm0 i))))
		  (:arg map fm0)
		  (:arg index 0 (size fm0)))
      (error "Map index, at-index, or iterator failed"))
    (unless (gmap (:result and) (fn (x y i)
				  (and (eql (rank fm0 x) i)
				       (eql (fset2:rank fm0 x) i)
				       (let ((rx ry (at-rank fm0 i)))
					 (and (equal? x rx)
					      (= y ry)))))
		  (:arg map fm0)
		  (:arg index 0 (size fm0)))
      (error "Map rank, at-rank, or iterator failed"))
    (let ((r (do ((r (random 200) (random 200)))
		 ;; Equivalent-but-unequal `My-Integer's make this a little tricky.
		 ((and (not (domain-contains? fm0 (make-my-integer r)))
		       (not (domain-contains? fm0 (make-my-integer (logxor r 1)))))
		  r))))
      (let ((ri (make-my-integer r))
	    ((fm0a (with fm0 ri 42))
	     (ri-rank (rank fm0 ri))
	     (ri-rank2 (fset2:rank fm0 ri))))
	(unless (= (1+ ri-rank) (rank fm0a ri))
	  (error "Map rank of non-member failed: ~A ~A" r fm0))
	(unless (= ri-rank2 (rank fm0a ri))
	  (error "Map fset2:rank of non-member failed: ~A ~A" r fm0))))))


(defun Test-Bag-Operations (i)
  (declare (optimize (speed 0) (safety 3) (debug 3)))
  (let ((fb0-cfn (if (logbitp 0 i) 'erapmoc 'compare))
	((fb0 (empty-wb-bag fb0-cfn)))
	(b0 nil)
	(fb1-cfn (if (logbitp 1 i) 'erapmoc 'compare))
	((fb1 (empty-wb-bag fb1-cfn)))
	(b1 nil))
    (dotimes (j 100)
      (let* ((r (Make-My-Integer (random 200)))
	     (tmp (with fb0 r)))
	(setq b0 (Alist-Assign b0 r (1+ (or (cdr (assoc r b0 :test #'equal?)) 0))))
	(unless (verify tmp)
	  (error "Bag verify failed (fb0) on iteration ~D, adding ~A" i r))
	(unless (= (size tmp) (Alist-Bag-Size b0))
	  (error "Bag size or with failed (fb0) on iteration ~D, adding ~A: ~D, ~D" i r
		 (size tmp) (Alist-Bag-Size b0)))
	(unless (= (set-size tmp) (length b0))
	  (error "Bag set-size failed (fb0) on iteration ~D" i))
	(unless (and (subbag? fb0 tmp) (not (subbag? tmp fb0)))
	  (error "Bag subbag? failed (fb0) on iteration ~D" i))
	(setq fb0 tmp)
	;; Can't say much about `hash-value', but at least we can check that it doesn't crash.
	(hash-value fb0)))
    (dotimes (j 100)
      (let* ((r (Make-My-Integer (random 200)))
	     (tmp (with fb1 r)))
	(setq b1 (Alist-Assign b1 r (1+ (or (cdr (assoc r b1 :test #'equal?)) 0))))
	(unless (verify tmp)
	  (error "Bag verify failed (fb1) on iteration ~D, adding ~A" i r))
	(unless (= (size tmp) (Alist-Bag-Size b1))
	  (error "Bag size or with failed (fb1) on iteration ~D, adding ~A: ~D, ~D" i r
		 (size tmp) (Alist-Bag-Size b1)))
	(unless (= (set-size tmp) (length b1))
	  (error "Bag set-size failed (fb1) on iteration ~D" i))
	(unless (and (subbag? fb1 tmp) (not (subbag? tmp fb1)))
	  (error "Bag Subbag? failed (fb1) on iteration ~D" i))
	(setq fb1 tmp)))
    (dotimes (j 20)
      (let ((r (Make-My-Integer (random 200))))
	(unless (eqv (contains? fb0 r) (assoc r b0 :test #'equal?))
	  (error "Bag contains? failed (fb0) on iteration ~D, ~A" i r))
	(unless (= (or (cdr (assoc r b0 :test #'equal?)) 0)
		   (multiplicity fb0 r))
	  (error "Bag multiplicity failed (fb0) on iteration ~D, ~A" i r))
	(let ((rn (cdr (assoc r b0 :test #'equal?))))
	  (when rn
	    (let ((rnrn (1+ (random rn))))
	      (setq b0 (Alist-Bag-Remove b0 r rnrn))
	      (let ((tmp (less fb0 r rnrn)))
		(unless (verify tmp)
		  (error "Bag verify failed on iteration ~D, removing ~D*~A" i rnrn r))
		(unless (= (size tmp) (Alist-Bag-Size b0))
		  (error "Bag size or less failed (fb0) on iteration ~D, removing ~D*~A" i rnrn r))
		(setq fb0 tmp)))))))
    (dotimes (j 20)
      (let ((r (Make-My-Integer (random 200))))
	(unless (eqv (contains? fb1 r) (assoc r b1 :test #'equal?))
	  (error "Bag contains? failed (fb1) on iteration ~D" i))
	(unless (= (or (cdr (assoc r b0 :test #'equal?)) 0)
		   (multiplicity fb0 r))
	  (error "Bag multiplicity failed (fb1) on iteration ~D, ~A" i r))
	(let ((rn (cdr (assoc r b0 :test #'equal?))))
	  (when rn
	    (let ((rnrn (1+ (random rn))))
	      (setq b1 (Alist-Bag-Remove b1 r rnrn))
	      (let ((tmp (less fb1 r rnrn)))
		(unless (verify tmp)
		  (error "Bag verify failed on iteration ~D, removing ~D*~A" i rnrn r))
		(unless (= (size tmp) (Alist-Bag-Size b1))
		  (error "Bag size or less failed (fb1) on iteration ~D, removing ~D*~A" i rnrn r))
		(setq fb1 tmp)))))))
    (when (= i 0)
      (let ((tmp (with fb0 nil)))
	(unless (verify tmp)
	  (error "Bag verify failed adding NIL"))
	(setq tmp (less tmp nil))
	(unless (verify tmp)
	  (error "Bag verify failed removing NIL"))))
    (unless (contains? fb0 (arb fb0))
      (error "Bag arb/contains? failed (fb0) on iteration ~D" i))
    (unless (contains? fb1 (arb fb1))
      (error "Bag arb/contains? failed (fb1) on iteration ~D" i))
    (unless (member (compare (least fb0)
			     (reduce (lambda (mi1 mi2)
				       (if (less-than?-cmp (My-Integer-Value mi1) (My-Integer-Value mi2)
							   (compare-fn fb0))
					   mi1 mi2))
				     (mapcar #'car b0)))
		    '(:equal :unequal))
      (error "Bag least failed on iteration ~D" i))
    (unless (member (compare (greatest fb0)
			     (reduce (lambda (mi1 mi2)
				       (if (greater-than?-cmp (My-Integer-Value mi1) (My-Integer-Value mi2)
							      (compare-fn fb0))
					   mi1 mi2))
				     (mapcar #'car b0)))
		    '(:equal :unequal))
      (error "Bag greatest failed on iteration ~D" i))
    (unless (equal? fb0 (convert 'wb-bag b0 :from-type 'alist :compare-fn-name fb0-cfn))
      (error "Bag equal? failed (fb0) on iteration ~D" i))
    (unless (equal? fb1 (convert 'wb-bag b1 :from-type 'alist :compare-fn-name fb1-cfn))
      (error "Bag equal? failed (fb1) on iteration ~D" i))
    (unless (equal? (convert 'list fb0) (gmap (:result list) nil (:arg bag fb0)))
      (error "Bag iterator failed (fb0) on iteration ~D" i))
    (unless (equal? fb1 (gmap (:result wb-bag :compare-fn-name fb1-cfn) nil
			      (:arg list (convert 'list fb1))))
      (error "Bag iterator/accumulator failed (fb1) on iteration ~D" i))
    (unless (eq (Map-Compare (convert 'alist fb0)
			     ;; Written this way to test both the driver and the iterator.
			     (gmap (:result list) (fn (e1 _n1 _e2 n2) (cons e1 n2))
				   (:arg bag-pairs fb0)
				   (:arg bag-pairs fb0))
			     nil)
		':equal)
      (error "Bag pair iterator failed (fb0) on iteration ~D" i))
    (unless (equal? fb1 (gmap (:result wb-bag-pairs :compare-fn-name fb1-cfn) nil
			      (:arg alist (convert 'alist fb1))))
      (error "Bag pair iterator/accumulator failed (fb1) on iteration ~D" i))
    (unless (equal? fb0 (convert 'wb-bag (convert 'list fb0)
				 :input-sorted? t :compare-fn-name fb0-cfn))
      (error "Bag conversion from sorted list failed (fb0) on iteration ~D" i))
    (unless (equal? fb0 (convert 'wb-bag (convert 'alist fb0)
				 :input-sorted? t :from-type 'alist :compare-fn-name fb0-cfn))
      (error "Bag conversion from sorted alist failed (fb0) on iteration ~D" i))

    (unless (equal? fb0 (convert 'wb-bag (convert 'seq fb0) :compare-fn-name fb0-cfn))
      (error "Bag conversion from seq failed (fb0) on iteration ~D" i))
    (unless (equal? fb0 (convert 'wb-bag (convert 'seq b0) :pairs? t :compare-fn-name fb0-cfn))
      (error "Bag conversion from seq-of-pairs failed (fb0) on iteration ~D" i))

    (unless (equal? fb0 (convert 'wb-bag (convert 'seq fb0) :input-sorted? t :compare-fn-name fb0-cfn))
      (error "Bag conversion from sorted seq failed (fb0) on iteration ~D" i))
    (unless (equal? fb0 (convert 'wb-bag (sort (convert 'seq b0) (fn (a b) (less-than?-cmp a b #'compare))
					       :key #'car)
				 :pairs? t :input-sorted? t :compare-fn-name fb0-cfn))
      (error "Bag conversion from sorted seq-of-pairs failed (fb0) on iteration ~D" i))

    (unless (equal? fb0 (convert 'wb-bag (convert 'vector fb0) :compare-fn-name fb0-cfn))
      (error "Bag conversion from vector failed (fb0) on iteration ~D" i))
    (unless (equal? fb0 (convert 'wb-bag (convert 'vector b0) :pairs? t :compare-fn-name fb0-cfn))
      (error "Bag conversion from vector-of-pairs failed (fb0) on iteration ~D" i))
    (unless (equal? fb0 (convert 'wb-bag (convert 'vector fb0) :input-sorted? t :compare-fn-name fb0-cfn))
      (error "Bag conversion from sorted vector failed (fb0) on iteration ~D" i))
    (unless (equal? fb0 (convert 'wb-bag (sort (convert 'vector b0) (fn (a b) (less-than?-cmp a b #'compare))
					       :key #'car)
				 :pairs? t :input-sorted? t :compare-fn-name fb0-cfn))
      (error "Bag conversion from sorted vector-of-pairs failed (fb0) on iteration ~D" i))

    (unless (equal? (gmap (:result list) nil (:arg fun-sequence fb0))
		    (convert 'list fb0))
      (error "Bag fun-iterator failed on iteration ~D" i))
    (unless (equal? (gmap (:result alist) nil (:arg fun-bag-pairs fb0))
		    (convert 'alist fb0))
      (error "Bag pair fun-iterator failed on iteration ~D" i))
    (unless (equal? (gmap (:result list) nil (:arg fun-sequence fb0 :from-end? t))
		    (reverse (convert 'list fb0)))
      (error "Bag rev-fun-iterator failed on iteration ~D" i))
    (unless (equal? (gmap (:result alist) nil (:arg fun-bag-pairs fb0 :from-end? t))
		    (reverse (convert 'alist fb0)))
      (error "Bag pair fun-iterator failed on iteration ~D" i))
    (flet ((check-result (result label &optional ref)
	     (unless (or (null ref) (equal? result ref))
	       (error "~A failed on iteration ~D" label i))
	     (let ((bad (gmap :or (fn (x _c) (let ((val? val (lookup result x)))
					       (and val? (not (eq x val)) x)))
			      (:arg bag-pairs fb0))))
	       (when bad
		 (error "~A failed left preference on iteration ~D: ~A" label i bad)))))
      (let ((fbu (union fb0 fb1))
	    (bu (Alist-Bag-Union b0 b1)))
	(unless (and (verify fbu) (equal? fbu (convert 'wb-bag bu :from-type 'alist :compare-fn-name fb0-cfn)))
	  (error "Bag union failed on iteration ~D" i))
	(check-result fbu "Bag union"))
      (let ((fbsu (union fb0 (convert 'set fb1)))
	    (fbbu (union fb0 (convert 'bag (convert 'set fb1)))))
	(check-result fbsu "Bag-set union" fbbu))
      (let ((fsbu (union (convert 'set fb0) fb1))
	    (fbbu (union (convert 'bag (convert 'set fb0)) fb1)))
	(check-result fsbu "Set-bag union" fbbu))
      (let ((fbi (intersection fb0 fb1))
	    (bi (Alist-Bag-Intersection b0 b1)))
	(unless (and (verify fbi) (equal? fbi (convert 'wb-bag bi :from-type 'alist :compare-fn-name fb0-cfn)))
	  (error "Bag intersection failed on iteration ~D " i))
	(check-result fbi "Bag intersection"))
      (let ((fbsi (intersection fb0 (convert 'set fb1)))
	    (fbbi (convert 'set (intersection fb0 (convert 'bag (convert 'set fb1))))))
	(check-result fbsi "Bag-set intersection" fbbi))
      (let ((fsbi (intersection (convert 'set fb0) fb1))
	    (fbbi (convert 'set (intersection (convert 'bag (convert 'set fb0)) fb1))))
	(check-result fsbi "Set-bag intersection" fbbi))
      (let ((fbd (bag-difference fb0 fb1))
	    (bd (Alist-Bag-Difference b0 b1)))
	(unless (and (verify fbd) (equal? fbd (convert 'wb-bag bd :from-type 'alist :compare-fn-name fb0-cfn)))
	  (error "Bag difference failed on iteration ~D " i))
	(check-result fbd "Bag difference"))
      (let ((fbsd (bag-difference fb0 (convert 'set fb1)))
	    (fbbd (bag-difference fb0 (convert 'bag (convert 'set fb1)))))
	(check-result fbsd "Bag-set difference" fbbd))
      (let ((fsbd (bag-difference (convert 'set fb0) fb1))
	    (fbbd (bag-difference (convert 'bag (convert 'set fb0)) fb1)))
	(check-result fsbd "Set-bag difference" fbbd))
      (let ((fbs (bag-sum fb0 fb1))
	    (bs (Alist-Bag-Sum b0 b1)))
	(unless (and (verify fbs) (equal? fbs (convert 'wb-bag bs :from-type 'alist :compare-fn-name fb0-cfn)))
	  (error "Bag sum failed on iteration ~D " i))
	(check-result fbs "Bag sum"))
      (let ((fbss (bag-sum fb0 (convert 'set fb1)))
	    (fbbs (bag-sum fb0 (convert 'bag (convert 'set fb1)))))
	(check-result fbss "Bag-set sum" fbbs))
      (let ((fsbs (bag-sum (convert 'set fb0) fb1))
	    (fbbs (bag-sum (convert 'bag (convert 'set fb0)) fb1)))
	(check-result fsbs "Set-bag sum" fbbs))
      (let ((fbp (bag-product fb0 fb1))
	    (bp (Alist-Bag-Product b0 b1)))
	(unless (and (verify fbp) (equal? fbp (convert 'wb-bag bp :from-type 'alist :compare-fn-name fb0-cfn)))
	  (error "Bag product failed on iteration ~D " i))
	(check-result fbp "Bag product"))
      (let ((fbsp (bag-product fb0 (convert 'set fb1)))
	    (fbbp (bag-product fb0 (convert 'bag (convert 'set fb1)))))
	(check-result fbsp "Bag-set product" fbbp))
      (let ((fsbp (bag-product (convert 'set fb0) fb1))
	    (fbbp (bag-product (convert 'bag (convert 'set fb0)) fb1)))
	(check-result fsbp "Set-bag product" fbbp)))
    (when (eq fb0-cfn fb1-cfn)
      (let ((fb0a (less fb0 (Pick fb0)))
	    (fb0b (less fb0 (Pick fb0))))
	(unless (eq (compare fb0a fb0b)
		    (Map-Compare (convert 'alist fb0a) (convert 'alist fb0b)
				 (eq (compare-fn-name fb0) 'erapmoc)))
	  (error "Bag compare failed (fb0) on iteration ~D: ~A, ~A" i fb0a fb0b)))
      (let ((fb1a (less fb1 (Pick fb1)))
	    (fb1b (less fb1 (Pick fb1))))
	(unless (eq (compare fb1a fb1b)
		    (Map-Compare (convert 'alist fb1a) (convert 'alist fb1b)
				 (eq (compare-fn-name fb1) 'erapmoc)))
	  (error "Bag compare failed (fb1) on iteration ~D" i))))
    (unless (gmap (:result and) (fn (x _n i)
				  (and (eql (index fb0 x) i)
				       (equal? x (at-index fb0 i))))
		  (:arg bag-pairs fb0)
		  (:arg index 0 (size fb0)))
      (error "Bag index, at-index, or iterator failed"))
    (unless (gmap (:result and) (fn (x n i)
				  (and (eql (rank fb0 x) i)
				       (eql (fset2:rank fb0 x) i)
				       (let ((rx rn (at-rank fb0 i)))
					 (and (equal? x rx)
					      (= n rn)))))
		  (:arg bag-pairs fb0)
		  (:arg index 0 (size fb0)))
      (error "Bag rank, at-rank, or iterator failed"))
    (let ((r (do ((r (random 200) (random 200)))
		 ;; Equivalent-but-unequal `My-Integer's make this a little tricky.
		 ((and (not (contains? fb0 (make-my-integer r)))
		       (not (contains? fb0 (make-my-integer (logxor r 1)))))
		  r))))
      (let ((ri (make-my-integer r))
	    ((fb0a (with fb0 ri))
	     (ri-rank (rank fb0 ri))
	     (ri-rank2 (fset2:rank fb0 ri))))
	(unless (= (1+ ri-rank) (rank fb0a ri))
	  (error "Bag rank of non-member failed: ~A ~A" r fb0))
	(unless (= ri-rank2 (rank fb0a ri))
	  (error "Bag fset2:rank of non-member failed: ~A ~A" r fb0))))
    fb0))


(defun Test-Seq-Operations (i)
  (declare (optimize (debug 3)))
  (let ((fs0 (empty-seq))
	(s0 nil)
	(fs1 (empty-seq))
	(s1 nil))
    ;; &&& There's more stuff to test here, like conversion to/from vectors, and
    ;; the special treatment of sequences of characters (particularly in implementations
    ;; with extended characters).  That code has been lightly hand-exercised, but that's
    ;; all.
    (dotimes (j 100)
      (let ((rand (random 100))
	    ((r (if (< rand 8) (Make-My-Integer rand)
		  #+FSet-Ext-Strings (make-char (+ rand 16) (random 3))
		  #-FSet-Ext-Strings (code-char rand))))
	    (pos (if (null s0) 0 (random (length s0))))
	    (which (random 6))
	    (tmp nil))
	(cond ((and (= which 0) s0)
	       (when (= pos (length s0))
		 (decf pos))
	       (unless (equal? (lookup fs0 pos) (nth pos s0))
		 (error "Seq indexing failed (fs0) on iteration ~D" i))
	       (setq tmp (with fs0 pos r))
	       (List-Set-Elt s0 pos r)
	       (unless (equal? s0 (convert 'list tmp))
		 (error "Seq with failed (fs0) on iteration ~D" i)))
	      ((and (= which 1) s0)
	       (setq tmp (less fs0 pos))
	       (setq s0 (List-Remove s0 pos))
	       (unless (equal? s0 (convert 'list tmp))
		 (error "Seq remove failed (fs0) on iteration ~D" i)))
	      (t
	       (setq tmp (insert fs0 pos r))
	       (setq s0 (List-Insert s0 pos r))
	       (unless (equal? s0 (convert 'list tmp))
		 (error "Seq insert failed (fs0) on iteration ~D" i))))
	(unless (verify tmp)
	  (error "Seq verify (fs0) failed on iteration ~D (~A ~D ~D)"
		 i (case which (0 "update") (1 "delete") (t "insert")) pos r))
	(setq fs0 tmp)
	;; Can't say much about `hash-value', but at least we can check that it doesn't crash.
	(hash-value fs0)))
    (dotimes (j 100)
      (let ((r (Make-My-Integer (random 200)))
	    (pos (if (null s1) 0 (random (length s1))))
	    (which (random 5))
	    (tmp nil))
	(cond ((and (= which 0) s1)
	       (unless (equal? (lookup fs1 pos) (nth pos s1))
		 (error "Seq indexing failed (fs1) on iteration ~D" i))
	       (setq tmp (with fs1 pos r))
	       (List-Set-Elt s1 pos r))
	      ((and (= which 1) s1)
	       (setq tmp (less fs1 pos))
	       (setq s1 (List-Remove s1 pos)))
	      (t
	       (setq tmp (insert fs1 pos r))
	       (setq s1 (List-Insert s1 pos r))))
	(unless (verify tmp)
	  (error "Seq verify (fs1) failed on iteration ~D (~A ~D ~D)"
		 i (case which (0 "update") (1 "delete") (t "insert")) pos r))
	(setq fs1 tmp)))
    (Test-CL-Generic-Sequence-Ops i fs0 s0 fs1 s1)
    (unless (equal? (convert 'list fs0) s0)
      (error "Seq equality failed (fs0, A), on iteration ~D" i))
    (unless (equal? fs0 (convert 'seq s0))
      (error "Seq equality failed (fs0, B), on iteration ~D" i))
    (unless (equal? fs0 (convert 'seq (reverse s0) :reverse? t))
      (error "Seq reverse convert from list failed on iteration ~D" i))
    (unless (gmap (:result and) #'equal? (:arg seq fs0) (:arg list s0))
      (error "Seq iterator failed on iteration ~D" i))
    (unless (equal? (gmap (:result list) nil (:arg fun-sequence fs0))
		    (convert 'list fs0))
      (error "Seq fun-iterator failed on iteration ~D" i))
    (unless (equal? (gmap (:result list) nil (:arg fun-sequence fs0 :from-end? t))
		    (reverse (convert 'list fs0)))
      (error "Seq rev-fun-iterator failed on iteration ~D" i))
    (unless (gmap (:result and) #'equal? (:arg seq fs0) (:arg sequence s0))
      (error "Seq or list iterator failed on iteration ~D" i))
    (unless (gmap (:result and) #'equal? (:arg seq fs0) (:arg sequence (coerce s0 'simple-vector)))
      (error "Seq or simple-vector iterator failed on iteration ~D" i))
    (unless (equal? (convert 'vector fs1) (coerce s1 'vector))
      (error "Seq equality failed (fs1, A), on iteration ~D" i))
    (unless (equal? fs1 (convert 'seq (coerce s1 'vector)))
      (error "Seq equality failed (fs1, B), on iteration ~D" i))
    (unless (equal? (convert 'list fs0) (gmap (:result list) nil (:arg seq fs0)))
      (error "Seq iterator failed (fs0) on iteration ~D" i))
    (unless (equal? fs1 (gmap (:result seq) nil (:arg list (convert 'list fs1))))
      (error "Seq iterator/accumulator failed (fs1) on iteration ~D" i))
    (let* ((lo (random (size fs0)))
	   (hi (+ lo (random (- (size fs0) lo))))
	   (fss (subseq fs0 lo hi))
	   (ss (cl:subseq s0 lo hi)))
      (unless (equal? (convert 'list fss) ss)
	(error "Seq subseq failed on iteration ~D" i))
      (let ((lo1 (random (size fs1)))
	    ((fsc (concat fss (subseq fs1 lo1)))
	     (sc (append ss (subseq s1 lo1)))))
	(unless (equal? (convert 'list fsc) sc)
	  (error "Seq concat failed on iteration ~D" i))))
    (let ((start (random (floor (size fs0) 1.5)))
	  ((end (+ start (random (- (size fs0) start))))))
      (unless (equal? (gmap (:result seq) nil (:arg seq fs0 :start start :end end))
		      (subseq fs0 start end))
	(error "Seq iterator restriction failed on iteration ~D" i))
      (unless (equal? (gmap (:result seq) nil (:arg wb-seq fs0 :start start :end end))
		      (subseq fs0 start end))
	(error "WB-Seq iterator restriction failed on iteration ~D" i))
      (unless (equal? (gmap (:result seq) nil (:arg seq fs0 :start start :end end :from-end? t))
		      (reverse (subseq fs0 start end)))
	(error "Seq iterator restriction (reverse) failed on iteration ~D" i))
      (unless (equal? (gmap (:result seq) nil (:arg wb-seq fs0 :start start :end end :from-end? t))
		      (reverse (subseq fs0 start end)))
	(error "WB-Seq iterator restriction (reverse) failed on iteration ~D" i)))
    (let ((delposa (random (size fs0)))
	  ((fs0a (less fs0 delposa))
	   (s0a (List-Remove s0 delposa))))
      (unless (equal? (convert 'list fs0a) s0a)
	(error "Seq remove failed on iteration ~D" i))
      (let ((delposb (random (size fs0)))
	    ((fs0b (less fs0 delposb))
	     (s0b (List-Remove s0 delposb))))
	(unless (eq (compare fs0a fs0b) (Seq-Compare s0a s0b))
	  (error "Seq compare failed on iteration ~D" i))))))

(defun Test-CL-Generic-Sequence-Ops (i fs0 s0 fs1 s1)
  (declare (ignore fs0 s0))		; for now
  (dotimes (j 20)
    (let ((r (Make-My-Integer (random 200)))
	  (s (random (size fs1)))
	  ((e (+ s (random (- (size fs1) s))))))
      ;; The use of `eql' checks that we find the correct instance.
      (unless (and (eql (find r s1 :start s :end e :test #'equal? :from-end t)
			(find r fs1 :start s :end e :from-end t))
		   (eql (find (My-Integer-Value r) s1
			      :start s :end e :key #'My-Integer-Value)
			(find (My-Integer-Value r) fs1
			      :start s :end e :key #'My-Integer-Value))
		   (eql (find r s1 :start s :end e :test (fn (a b) (less-than?-cmp a b #'compare)))
			(find r fs1 :start s :end e :test (fn (a b) (less-than?-cmp a b #'compare))))
		   (eql (find (My-Integer-Value r) s1
			      :start s :end e :key #'My-Integer-Value :test #'>)
			(find (My-Integer-Value r) fs1
			      :start s :end e :key #'My-Integer-Value :test #'>)))
	(error "Find failed on iteration ~D" i)))))


(deflex Tuple-Keys (gmap (:result vector :length 40)
			 #'get-tuple-key
			 (:arg index 0 40)))

(defun Test-Tuple-Operations (i)
  (let ((tup (tuple))
	(m (map))
	(nkeys (length Tuple-Keys)))
    (dotimes (j 100)
      (let ((key (svref Tuple-Keys (random nkeys)))
	    (val (Make-My-Integer (random 8)))
	    (prev-m m)
	    (prev-tup tup))
	(setq tup (with tup key val))
	(setq m (with m key val))
	(unless (equal? m (convert 'map tup))
	  (error "Tuple `with' failed on iteration ~D" i))
	(do-map (k v m)
	  (unless (equal? v (lookup tup k))
	    (error "Tuple `lookup' failed on iteration ~D" i)))
	(unless (eq (compare prev-tup tup) (compare prev-m m))
	  (error "Tuple `compare' failed on iteration ~D" i))))))


;;; ================================================================================
;;; Internals

(defun Set-Compare (s1 s2)
  (let ((s1 (convert 'list s1))
	(s2 (convert 'list s2))
	(cmp-fn (wb-set-compare-fn s1))
	((len1 (length s1))
	 (len2 (length s2))))
    (cond ((< len1 len2) ':less)
	  ((> len1 len2) ':greater)
	  (t
	   (do ((ts1 s1 (cdr ts1))
		(ts2 s2 (cdr ts2))
		(unequal? nil))
	       ((null ts1)
		(if unequal? ':unequal ':equal))
	     (let ((e1 (car ts1))
		   (e2 (car ts2))
		   ((cmp (funcall cmp-fn e1 e2))))
	       (when (member cmp '(:less :greater))
		 (return cmp))
	       (when (eq cmp ':unequal)
		 (setq unequal? t))))))))

(defun Map-Compare (m1 m2 keys-reversed?)
  ;; Rather too hairy to be a good reference implementation.  Seems to be
  ;; correct, though.
  (let ((len1 (length m1))
	(len2 (length m2))
	(result ':equal))
    (cond ((< len1 len2) ':less)
	  ((> len1 len2) ':greater)
	  (t
	   (setq m1 (Map-Sort-And-Group m1 keys-reversed?))
	   (setq m2 (Map-Sort-And-Group m2 keys-reversed?))
	   (do ((tm1 m1 (cdr tm1))
		(tm2 m2 (cdr tm2)))
	       ((null tm1)
		result)
	     (let* ((g1 (car tm1))
		    (g2 (car tm2))
		    (pr1 (car g1))
		    (pr2 (car g2))
		    (k1 (car pr1))
		    (k2 (car pr2))
		    (k12 (ash k1 -1))
		    (k22 (ash k2 -1)))
	       (cond ((< k12 k22) (return (if keys-reversed? ':greater ':less)))
		     ((> k12 k22) (return (if keys-reversed? ':less ':greater)))
		     ((and (null (cdr g1)) (null (cdr g2)))
		      (let ((comp (compare (cdr pr1) (cdr pr2))))
			(unless (eq comp ':equal)
			  (return comp)))
		      (unless (= k1 k2)
			(setq result ':unequal)))
		     ;; If `g1' is shorter than `g2', the next element following `g1' (which must exist)
		     ;; will then be greater than any element of `g2'.
		     ((< (length g1) (length g2)) (return ':greater))
		     ((> (length g1) (length g2)) (return ':less))
		     ((cl:notevery #'(lambda (pr1)
				       (let ((pr2 (assoc (car pr1) g2)))
					 (and pr2 (= (cdr pr1) (cdr pr2)))))
				   g1)
		      (let ((vals1 (convert 'wb-set (mapcar #'cdr g1)))
			    (vals2 (convert 'wb-set (mapcar #'cdr g2)))
			    ((comp (compare vals1 vals2))))
			(if (eq comp ':equal)
			    (setq result ':unequal)
			  (return comp)))))))))))

(defun Map-Sort-And-Group (m reversed?)
  (let ((m (cl:sort (mapcar #'(lambda (pr) (cons (My-Integer-Value (car pr)) (cdr pr)))
			    m)
		    (if reversed? #'> #'<) :key #'car))
	(g nil)
	(grouped nil))
    (dolist (pr m)
      (when (and g (/= (ash (car pr) -1) (ash (caar g) -1)))
	(push g grouped)
	(setq g nil))
      (push pr g))
    (push g grouped)
    (nreverse grouped)))

(defun Alist-Assign (al r v)
  (cons (cons r v) (Alist-Remove al r)))

(defun Alist-Remove (al r)
  (remove r al :key #'car :test #'equal?))

(defun Alist-Bag-Remove (al r n)
  (let ((pr (assoc r al :test #'equal?)))
    (cond ((null pr) al)
	  ((<= (cdr pr) n) (remove pr al))
	  (t
	   (cons (cons (car pr) (- (cdr pr) n))
		 (remove pr al))))))

(defun Alist-Bag-Size (al)
  (gmap (:result sum) #'cdr (:arg list al)))

(defun Alist-Bag-Union (al1 al2)
  (Alist-Bag-Combine al1 al2 #'max))

(defun Alist-Bag-Intersection (al1 al2)
  (Alist-Bag-Combine al1 al2 #'min))

(defun Alist-Bag-Difference (al1 al2)
  (Alist-Bag-Combine al1 al2 #'-))

(defun Alist-Bag-Sum (al1 al2)
  (Alist-Bag-Combine al1 al2 #'+))

(defun Alist-Bag-Product (al1 al2)
  (Alist-Bag-Combine al1 al2 #'*))

(defun Alist-Bag-Combine (al1 al2 fn)
  (let ((result nil)
	(al2 (copy-list al2)))
    (dolist (pr1 al1)
      (let ((pr2 (assoc (car pr1) al2 :test #'equal?))
	    ((new-count (funcall fn (cdr pr1) (if pr2 (cdr pr2) 0)))))
	(when pr2 (setq al2 (delete pr2 al2 :test #'eq)))
	(unless (<= new-count 0)
	  (push (cons (car pr1) new-count) result))))
    (dolist (pr2 al2)
      (let ((new-count (funcall fn 0 (cdr pr2))))
	(unless (<= new-count 0)
	  (push (cons (car pr2) new-count) result))))
    result))

(defun List-Set-Elt (s pos val)
  (setf (car (nthcdr pos s)) val))

(defun List-Remove (s pos)
  (cl:append (cl:subseq s 0 pos) (cl:subseq s (1+ pos))))

(defun List-Insert (s pos r)
  (cl:append (cl:subseq s 0 pos) (cons r (cl:subseq s pos))))

(defun Seq-Position (x s)
  (let ((i 0))
    (do-seq (y s :value nil)
      (when (equal? y x)
	(return i))
      (incf i))))

(defun Seq-Compare (s1 s2)
  (let ((len1 (length s1))
	(len2 (length s2)))
    (cond ((< len1 len2) ':less)
	  ((> len1 len2) ':greater)
	  (t
	   (do ((ts1 s1 (cdr ts1))
		(ts2 s2 (cdr ts2))
		(unequal? nil))
	       ((null ts1)
		(if unequal? ':unequal ':equal))
	     (case (compare (car ts1) (car ts2))
	       (:less (return ':less))
	       (:greater (return ':greater))
	       (:unequal (setq unequal? t))))))))

(defun Test-Type-Dispatch-Speed (n)
  (let ((stuff '(nil 3 #\a foo "bar" #(zot) '(quux))))
    (dolist (x stuff)
      (dolist (y stuff)
	(time (progn
		(format t "~&~S vs. ~S~%" x y)
		(dotimes (i n) (compare x y))))))))

(defun Pick (fs)
  (if (empty? fs)
      (error "`Pick' on empty set")
    (do ((r (Make-My-Integer (random 200)) (Make-My-Integer (random 200))))
	((contains? fs r)
	 r))))


(defmethod compare ((x My-Integer) (y My-Integer))
  (let ((xv (My-Integer-Value x))
	(yv (My-Integer-Value y)))
    (if (= xv yv) ':equal
      (let ((x2 (floor (the fixnum xv) 2))
	    (y2 (floor (the fixnum yv) 2)))
	(cond ((< x2 y2) ':less)
	      ((> x2 y2) ':greater)
	      (t ':unequal))))))

(defun Random-Test (n)
  (dotimes (i n)
    (let ((s0 (empty-set))
	  (s1 (empty-set)))
      (dotimes (i 200)
	(let* ((mi (Make-My-Integer (random 200)))
	       (tmp (with s0 mi)))
	  ;;(unless (Verify tmp)
	  ;;  (break "Verify failed adding ~A to ~S~% getting ~S"
	  ;;	   mi s0 tmp))
	  (setq s0 tmp)))
      (dotimes (i 200)
	(let* ((mi (Make-My-Integer (random 200)))
	       (tmp (with s1 mi)))
	  ;;(unless (Verify tmp)
	  ;;  (break "Verify failed adding ~A to ~S~% getting ~S"
	  ;;	   mi s1 tmp))
	  (setq s1 tmp)))
      (dotimes (i 20)
	(let* ((mi (Make-My-Integer (random 200)))
	       (tmp (less s0 mi)))
	  ;;(unless (Verify tmp)
	  ;;  (break "Verify failed removing ~A from ~S~% getting ~S"
	  ;;	   mi s0 tmp))
	  (setq s0 tmp)))
      (dotimes (i 20)
	(let* ((mi (Make-My-Integer (random 200)))
	       (tmp (less s1 mi)))
	  ;;(unless (Verify tmp)
	  ;;  (break "Verify failed removing ~A from ~S~% getting ~S"
	  ;;	   mi s1 tmp))
	  (setq s1 tmp)))
      (union s0 s1)
      (intersection s0 s1)
      (set-difference s0 s1))))

(defun Test-Bounded-Sets ()
  "Simple tests on the Bounded Sets operations"
  (macrolet ((test (form)
               `(unless ,form
                  (error "Test failed: ~S" ',form))))
    (let ((u (gmap (:result set) nil (:arg index-inc 1 10))))
      (test (equal? (make-bounded-set u (set 1 2)) (set 1 2)))
      (test (equal? (make-bounded-set u (set 1 2 3 4 5 6)) (set 1 2 3 4 5 6)))
      (test (equal? (complement (make-bounded-set u (set 1 3 5 7)))
                    (set 2 4 6 8 9 10)))
      (test (equal? (make-bounded-set u (set 1 3 5 7) t)
                    (set 2 4 6 8 9 10)))
      (test (equal? (make-bounded-set u (set 1 3 5 7 9 10) t)
                    (set 2 4 6 8)))
      (test (equal? (complement (complement (make-bounded-set u (set 3 9 2 1))))
                    (set 1 2 3 9)))
      (test (equal? (complement (make-bounded-set u (set 3 9 2 1) t))
                    (set 1 2 3 9)))
      (test (empty? (make-bounded-set (set) (set))))
      (test (empty? (make-bounded-set u (set))))
      (test (handler-case (progn (make-bounded-set u (set 11)) nil)
              (error () t)))

      (test (contains? (make-bounded-set u (set 1 2 3)) 1))
      (test (not (contains? (make-bounded-set u (set 1 2 3)) 4)))
      (test (not (contains? (make-bounded-set u (set 1 2 3) t) 1)))
      (test (contains? (make-bounded-set u (set 1 2 3) t) 4))

      (test (member (arb (make-bounded-set u (set 1 2 3))) '(1 2 3)))
      (test (member (arb (make-bounded-set u (set 1 2 3) t)) '(4 5 6 7 8 9 10)))

      (test (eql (size (make-bounded-set (set) (set))) 0))
      (test (eql (size (make-bounded-set u (set))) 0))
      (test (eql (size (make-bounded-set u (set 1 2 3))) 3))
      (test (eql (size (make-bounded-set u (set) t)) 10))
      (test (eql (size (make-bounded-set u (set 1 2 3) t)) 7))

      (test (equal? (make-bounded-set u (set 1))
                    (with (make-bounded-set u (set)) 1)))
      (test (equal? (with (make-bounded-set u (set 1 2 3) t) 2)
                    (make-bounded-set u (set 1 3) t)))
      (test (handler-case
                (progn (with (make-bounded-set u (set)) 11) nil)
              (error () t)))

      (test (equal? (less (make-bounded-set u (set 1 2 3)) 2)
                    (set 1 3)))
      (test (equal? (less (make-bounded-set u (set 1 2 3) t) 2)
                    (set 4 5 6 7 8 9 10)))
      (test (equal? (less (make-bounded-set u (set 1 2 3)) 4)
                    (set 1 2 3)))
      (test (equal? (less (make-bounded-set u (set 1 2 3) t) 4)
                    (set 5 6 7 8 9 10)))
      (test (handler-case
                (progn (less (make-bounded-set u (set)) 11) nil)
              (error () t)))

      (test (equal? (union (make-bounded-set u (set 1 5))
                           (make-bounded-set u (set 2 8 9)))
                    (set 1 2 5 8 9)))
      (test (equal? (union (make-bounded-set u (set 1 5))
                           (make-bounded-set u (set 2 8 9) t))
                    (set 1 3 4 5 6 7 10)))
      (test (equal? (union (make-bounded-set u (set 1 5) t)
                           (make-bounded-set u (set 2 8 9)))
                    (set 2 3 4 6 7 8 9 10)))
      (test (equal? (union (make-bounded-set u (set 1 4 5 9) t)
                           (make-bounded-set u (set 2 4 8 9) t))
                    (set 1 2 3 5 6 7 8 10)))
      (test (handler-case (progn
                            (union (make-bounded-set (set 1 2 3) (set 1))
                                   (make-bounded-set (set 1 2 3 4) (set 2)))
                            nil)
              (error () t)))

      (test (equal? (intersection (make-bounded-set u (set 1 3 5 7 8 10))
                                  (make-bounded-set u (set 2 5 7 9 10)))
                    (set 5 7 10)))
      (test (equal? (intersection (make-bounded-set u (set 1 3 5 7 8 10) t)
                                  (make-bounded-set u (set 2 5 7 9 10)))
                    (set 2 9)))
      (test (equal? (intersection (make-bounded-set u (set 1 3 8 10) t)
                                  (make-bounded-set u (set 2 5 7 9 10)))
                    (set 2 5 7 9)))
      (test (equal? (intersection (make-bounded-set u (set 1 3 5 7 8 10))
                                  (make-bounded-set u (set 2 5 7 9 10) t))
                    (set 1 3 8)))
      (test (equal? (intersection (make-bounded-set u (set 1 3 5 7 8 10))
                                  (make-bounded-set u (set 2 5 7 9) t))
                    (set 1 3 8 10)))
      (test (equal? (intersection (make-bounded-set u (set 1 3 5 7))
                                  (make-bounded-set u (set 2 5 7 9) t))
                    (set 1 3)))
      (test (equal? (intersection (make-bounded-set u (set 1 3 5 7 8 10) t)
                                  (make-bounded-set u (set 2 5 7 9 10) t))
                    (set 4 6)))
      (test (equal? (intersection (make-bounded-set u (set 1 3 8 10) t)
                                  (make-bounded-set u (set 2 5 7 9) t))
                    (set 4 6)))
      (test (handler-case
                (progn
                  (intersection (make-bounded-set (set 1 2 3) (set 1))
                                (make-bounded-set (set 1 2 3 4) (set 2)))
                  nil)
              (error () t)))

      (test (equal? (set-difference (make-bounded-set u (set 1 2 3 4 5))
                                    (make-bounded-set u (set 2 5)))
                    (set 1 3 4)))
      (test (equal? (set-difference (make-bounded-set u (set 1 2 3 4 5))
                                    (make-bounded-set u (set 2 5) t))
                    (set 2 5)))
      (test (equal? (set-difference (make-bounded-set u (set 1 2 3 4) t)
                                    (make-bounded-set u (set 2 5)))
                    (set 6 7 8 9 10)))
      (test (equal? (set-difference (make-bounded-set u (set 1 2 3 4) t)
                                    (make-bounded-set u (set 2 5) t))
                    (set 5)))
      (test (handler-case
                (progn
                  (set-difference (make-bounded-set (set 1 2 3) (set 1))
                                  (make-bounded-set (set 1 2 3 4) (set 2)))
                  nil)
              (error () t)))

      (test (subset? (make-bounded-set u (set 1 2 3))
                     (make-bounded-set u (set 1 2 3 4 5))))
      (test (not (subset? (make-bounded-set u (set 1 2 3) t)
                          (make-bounded-set u (set 1 2 3 4 5)))))
      (test (subset? (make-bounded-set u (set 1 2 3) t)
                     (make-bounded-set u (set 1 2) t)))
      (test (not (subset? (make-bounded-set u (set 1))
                          (make-bounded-set u (set 1 2) t))))
      (test (handler-case
                (progn
                  (subset? (make-bounded-set (set 1 2 3) (set 1))
                           (make-bounded-set (set 1 2 3 4) (set 2)))
                  nil)
              (error () t)))

      (test (disjoint? (make-bounded-set u (set)) (make-bounded-set u u)))
      (test (not (disjoint? (make-bounded-set u (set 1))
                            (make-bounded-set u u))))
      (test (disjoint? (make-bounded-set u (set 1))
                       (make-bounded-set u (set 1) t)))
      (test (disjoint? (make-bounded-set u (set 1))
                       (make-bounded-set u (set 1 2 3 4 5 6) t)))
      (test (disjoint? (make-bounded-set u (set 1) t)
                       (make-bounded-set u (set 1))))
      (test (not (disjoint? (make-bounded-set u (set 1) t)
                            (make-bounded-set u (set 1) t))))
      (test (handler-case
                (progn
                  (disjoint? (make-bounded-set (set 1 2 3) (set 1))
                             (make-bounded-set (set 1 2 3 4) (set 2)))
                  nil)
              (error () t)))
      )))

(defun Test-Complement-Sets ()
  "Simple tests on the Complement Sets operations"
  (macrolet ((test (form)
               `(unless ,form
                  (error "Test failed: ~S" ',form))))
    (test (funcall (complement #'not) t))
    (test (equal? (complement (set)) (complement (set))))
    (test (equal? (complement (set 1)) (complement (set 1))))
    (test (not (equal? (complement (set 1)) (complement (set 2)))))
    (test (equal? (complement (complement (set 1 5 19)))
                  (set 1 5 19)))
    (test (eql (size (complement (set 1 2 3))) -3))
    (test (contains? (complement (set 1)) 2))
    (test (not (contains? (complement (set 1)) 1)))
    (test (handler-case (progn (arb (complement (set 1))) nil)
            (error () t)))
    (test (equal? (with (complement (set 1 2 3)) 2)
                  (complement (set 1 3))))
    (test (equal? (with (complement (set 1 2 3)) 4)
                  (complement (set 1 2 3))))
    (test (equal? (less (complement (set 1 2 3)) 5)
                  (complement (set 1 2 3 5))))
    (test (equal? (less (complement (set 1 2 3)) 1)
                  (complement (set 1 2 3))))
    (test (equal? (union (complement (set 1 2 3 4 6))
                         (complement (set 2 5 6 7 8)))
                  (complement (set 2 6))))
    (test (equal? (union (set 1 2 3) (complement (set 3 5 7)))
                  (complement (set 5 7))))
    (test (equal? (union (set 1 2 3) (complement (ch-set 3 5 7)))
                  (complement (set 5 7))))
    (test (equal? (union (ch-set 1 2 3) (complement (ch-set 3 5 7)))
                  (complement (ch-set 5 7))))
    (test (equal? (union (complement (set 3 5 7))
                         (set 1 2 3))
                  (complement (set 5 7))))
    (test (equal? (intersection (complement (set 1 2 3))
                                (complement (set 2 4 8)))
                  (complement (set 1 2 3 4 8))))
    (test (equal? (intersection (set 1 2 3 4 5)
                                (complement (set 2 4 7 10)))
                  (set 1 3 5)))
    (test (equal? (intersection (complement (set 2 4 7 10))
                                (set 1 2 3 4 5))
                  (set 1 3 5)))
    (test (equal? (set-difference (complement (set 1 2 3 4 5))
                                  (complement (set 0 2 5 7)))
                  (set 0 7)))
    (test (equal? (set-difference (complement (set 1 2 3 4 5))
                                  (set 0 2 5 7))
                  (complement (set 0 1 2 3 4 5 7))))
    (test (equal? (set-difference (set 1 2 3 4 5)
                                  (complement (set 0 2 5 7)))
                  (set 2 5)))
    (test (subset? (complement (set 1)) (complement (set 1))))
    (test (subset? (complement (set 1 2)) (complement (set 1))))
    (test (not (subset? (complement (set 1)) (complement (set 1 2)))))
    (test (not (subset? (complement (set 1)) (set 2))))
    (test (subset? (set 1) (complement (set 0))))
    (test (not (subset? (set 1) (complement (set 1)))))

    (test (not (disjoint? (complement (set 1)) (complement (set 2)))))
    (test (disjoint? (complement (set 1)) (set 1)))
    (test (not (disjoint? (complement (set 1)) (set 2))))
    (test (disjoint? (set 1) (complement (set 1))))
    (test (not (disjoint? (set 2) (complement (set 1)))))

    (test (equal? (compare (complement (set 1)) (complement (set 2)))
                  (compare (set 2) (set 1))))
    (test (equal? (compare (complement (set 1)) (set 1))
                  :greater))
    (test (equal? (compare (set 1) (complement (set 1)))
                  :less))
    (test (equal
           (format nil "~a" (complement (set 1)))
           "~#{ 1 }"))))

(defun Test-2-Relations ()
  "Simple tests on binary relations."
  (macrolet ((test (form)
               `(unless ,form
                  (error "Test failed: ~S" ',form))))
    ;; WB
    (test (equal? (empty-wb-2-relation) (empty-wb-2-relation)))
    (test (empty? (empty-wb-2-relation)))
    (test (eql (size (empty-wb-2-relation)) 0))
    (test (eql (size (wb-2-relation (2 3) (2 4) (2 5))) 3))
    (test (equal (multiple-value-list (arb (empty-wb-2-relation))) '(nil nil nil)))
    (test (equal (multiple-value-list (arb (wb-2-relation (1 2))))
                 '(1 2 t)))
    (test (contains? (wb-2-relation (1 2) (1 3) (4 7)) 1 2))
    (test (not (contains? (wb-2-relation (1 2)) 1 3)))
    (test (equal? (lookup (empty-wb-2-relation) 1) (set)))
    (test (equal? (lookup (wb-2-relation (1 2)) 1) (set 2)))
    (test (equal? (lookup-inv (wb-2-relation (1 2)) 2) (set 1)))
    (test (equal? (domain (wb-2-relation (1 2))) (set 1)))
    (test (equal? (range (wb-2-relation (1 2))) (set 2)))
    (test (equal? (inverse (empty-wb-2-relation)) (empty-wb-2-relation)))
    (test (equal? (inverse (wb-2-relation (1 2)))
                  (wb-2-relation (2 1))))
    (hash-value (wb-2-relation (1 3) (1 7) (1 19) (1 32) (1 33) (1 47) (1 53)
			       (1 59) (1 61)))
    (test (equal? (wb-2-relation (1 7) (($ (set 4 9)) 2) (($ (set 3 6)) ($ (set 8 12)))
				 (7 ($ (set 11 13))))
		  (wb-2-relation (1 7) (4 2) (3 8) (3 12) (6 8) (6 12) (7 11) (7 13) (9 2))))

    (test (equal (multiple-value-list (least (empty-wb-2-relation)))
                 '(nil nil nil)))
    (test (equal? (multiple-value-list (least (wb-2-relation (1 2) (3 4))))
                  (list 1 (set 2) t)))
    (test (equal (multiple-value-list (greatest (empty-wb-2-relation)))
                 '(nil nil nil)))
    (test (equal? (multiple-value-list (greatest (wb-2-relation (1 2) (3 4))))
                  (list 3 (set 4) t)))

    (test (= 1 (size (with (wb-2-relation (1 2)) 1 2))))
    (test (equal? (wb-2-relation (1 2) (1 3))
                  (inverse (wb-2-relation (3 1) (2 1)))))
    (test (equal? (with (wb-2-relation (1 2)) '(1 . 3))
                  (convert 'wb-2-relation '((1 . 2) (1 . 3)))))
    (test (equal? (with (wb-2-relation (1 2)) 3 4)
                  (convert 'wb-2-relation '((1 . 2) (3 . 4)))))
    (test (equal? (with (wb-2-relation (1 2) (5 3)) 4 3)
                  (convert 'wb-2-relation '((1 . 2) (5 . 3) (4 . 3)))))
    (let ((rel (wb-2-relation (1 2) (2 3))))
      (inverse rel)
      (let ((rel1 (with (with rel 1 3) 4 7)))
	(verify rel1)
	(test (equal? (image rel1 (set 1 4)) (wb-set (wb-set 2 3) (wb-set 7))))))
    (let ((rel (wb-2-relation (1 2) (2 3))))
      (inverse rel)
      (let ((rel1 (with (with rel 1 3) 4 7)))
	(verify rel1)
	(test (equal? (image (inverse rel1) (wb-set 2 3)) (wb-set (wb-set 1) (wb-set 1 2))))))
    (let ((rela (wb-2-relation (1 3) (1 7) (1 19) (1 32) (1 33) (1 47) (1 53)
			       (1 59) (1 61)))
	  ((relb (with rela 1 67))))
      (test (= (size (union rela relb)) (size relb))))

    (test (equal? (less (empty-wb-2-relation) 1 2) (empty-wb-2-relation)))
    (test (equal? (less (wb-2-relation (1 2)) '(1 . 2)) (empty-wb-2-relation)))
    (test (equal? (less (wb-2-relation (1 2)) 1 3)
                  (wb-2-relation (1 2))))
    (test (equal? (less (wb-2-relation (1 2) (1 3)) 1 3)
                  (wb-2-relation (1 2))))
    (test (equal? (less (wb-2-relation (2 1) (3 1)) 3 1)
                  (wb-2-relation (2 1))))
    (let ((rel (wb-2-relation (1 2) (2 3))))
      (inverse rel)
      (let ((rel1 (with (less rel 1 2) 4 7)))
	(verify rel1)
	(test (equal? (image rel1 (wb-set 2 4)) (wb-set (wb-set 3) (wb-set 7))))))
    (let ((rel (wb-2-relation (1 2) (2 3))))
      (inverse rel)
      (let ((rel1 (with (less rel 1 2) 4 3)))
	(verify rel1)
	(test (equal? (image (inverse rel1) (wb-set 3)) (wb-set (wb-set 2 4))))))

    (test (equal? (union (empty-wb-2-relation) (empty-wb-2-relation)) (empty-wb-2-relation)))
    (test (equal? (union (wb-2-relation (1 2)) (empty-wb-2-relation))
                  (wb-2-relation (1 2))))
    (test (equal? (wb-2-relation (1 2))
                  (union (wb-2-relation (1 2)) (empty-wb-2-relation))))
    (test (equal? (union (wb-2-relation (1 2)) (wb-2-relation (1 2)))
                  (wb-2-relation (1 2))))
    (test (equal? (union (wb-2-relation (1 2)) (wb-2-relation (1 3)))
                  (wb-2-relation (1 2) (1 3))))
    (test (equal? (union (wb-2-relation (2 1)) (wb-2-relation (3 1)))
                  (wb-2-relation (2 1) (3 1))))
    (test (equal? (union (wb-custom-2-relation 'erapmoc 'erapmoc (3 1)) (wb-2-relation (2 1)))
		  (wb-custom-2-relation 'erapmoc 'erapmoc (2 1) (3 1))))
    (let ((rel (wb-2-relation (1 2) (1 3) (2 3))))
      (inverse rel)
      (let ((rel1 (union rel (wb-2-relation (4 3)))))
	(verify rel1)
	(test (equal? (image (inverse rel1) (wb-set 3)) (wb-set (wb-set 1 2 4))))))

    (test (equal? (intersection (empty-wb-2-relation) (empty-wb-2-relation)) (empty-wb-2-relation)))
    (test (equal? (intersection (wb-2-relation (1 2)) (empty-wb-2-relation)) (empty-wb-2-relation)))
    (test (equal? (intersection (empty-wb-2-relation) (wb-2-relation (1 2))) (empty-wb-2-relation)))
    (test (equal? (intersection (wb-2-relation (3 4)) (wb-2-relation (1 2))) (empty-wb-2-relation)))
    (test (equal? (intersection (wb-2-relation (1 2)) (wb-2-relation (1 2)))
                  (wb-2-relation (1 2))))
    (test (equal? (intersection (wb-2-relation (1 2)) (wb-2-relation (1 3))) (empty-wb-2-relation)))
    (test (equal? (intersection (wb-2-relation (2 1)) (wb-2-relation (3 1))) (empty-wb-2-relation)))
    (test (equal? (intersection (wb-2-relation ('a 7) ('b 12) ('c 17)) (wb-2-relation ('b 12) ('c 22)))
		  (wb-2-relation ('b 12))))
    (test (equal? (intersection (wb-custom-2-relation 'erapmoc 'erapmoc
						      ('a 7) ('b 12) ('c 17))
				(wb-2-relation ('b 12) ('c 22)))
		  (wb-custom-2-relation 'erapmoc 'erapmoc ('b 12))))
    (let ((rel (wb-2-relation (1 2) (1 3) (2 3))))
      (inverse rel)
      (let ((rel1 (intersection rel (wb-2-relation (1 3) (4 3)))))
	(verify rel1)
	(test (equal? (image (inverse rel1) (wb-set 3)) (wb-set (wb-set 1))))))

    (test (equal? (join (wb-2-relation ('a 3) ('a 5) ('b 7) ('b 8)) 1
			(wb-2-relation (3 "yo") (7 "eek") (7 "mrr")) 0)
		  (wb-2-relation ('a "yo") ('b "eek") ('b "mrr"))))
    (test (equal? (convert 'list (join (wb-custom-2-relation 'erapmoc 'erapmoc ('a 3) ('a 5) ('b 7) ('b 8)) 1
				       (wb-2-relation (3 "hey") (7 "eek") (7 "mrr")) 0))
		  '((b . "eek") (b . "mrr") (a . "hey"))))
    (test (equal? (convert 'list (join (wb-2-relation (3 "mrr") (7 "eek") (7 "mrr")) 0
				       (wb-custom-2-relation 'compare 'erapmoc ('a 3) ('a 5) ('b 7) ('b 8)) 1))
		  '(("eek" . b) ("mrr" . a) ("mrr" . b))))
    (test (equal? (convert 'list (join (wb-2-relation (3 "mrr") (7 "eek") (7 "mrr")) 0
				       (wb-custom-2-relation 'erapmoc 'erapmoc ('a 3) ('a 5) ('b 7) ('b 8)) 1))
		  '(("eek" . b) ("mrr" . b) ("mrr" . a))))

    (test (equal? (convert 'wb-2-relation (set '(a . 85) '(b . 17) '(b . 280) '(b . 880)))
		  (wb-2-relation ('a 85) ('b 17) ('b 280) ('b 880))))

    (test (equal? (compose (wb-2-relation ('a 3) ('a 5) ('b 3) ('c 4) ('c 8)) #'1+)
		  (wb-2-relation ('a 4) ('a 6) ('b 4) ('c 5) ('c 9))))
    (test (equal? (compose (wb-2-relation ('a 3) ('a 5) ('b 3) ('c 4) ('c 8))
			   (map (3 7) (4 6) (5 11) (8 15)))
		  (wb-2-relation ('a 7) ('a 11) ('b 7) ('c 6) ('c 15))))
    (test (equal? (compose (wb-2-relation ('a 3) ('a 5) ('b 3) ('c 4) ('c 8))
			   (seq 0 1 2 7 6 11 6 7 15))
		  (wb-2-relation ('a 7) ('a 11) ('b 7) ('c 6) ('c 15))))
    (test (equal? (compose (wb-2-relation ('a 3) ('a 5) ('b 3) ('c 4) ('c 8))
			   (wb-2-relation (3 7) (3 9) (5 11) (8 15)))
		  (wb-2-relation ('a 7) ('a 9) ('a 11) ('b 7) ('b 9) ('c 15))))

    (test (equal? (image (wb-2-relation ('a 3) ('a 5) ('b 3) ('c 4) ('c 8))
			 (set 'a 'c))
		  (set (set 3 5) (set 4 8))))

    (test (equal? (convert 'list (wb-2-relation ('a 3) ('a 5) ('b 7) ('b 8)))
		  '((a . 3) (a . 5) (b . 7) (b . 8))))
    (test (equal? (convert 'list (wb-custom-2-relation 'erapmoc 'erapmoc ('a 3) ('a 5) ('b 7) ('b 8)))
		  '((b . 8) (b . 7) (a . 5) (a . 3))))
    (test (equal? (gmap (:result list) #'cons
			(:arg wb-2-relation (wb-custom-2-relation 'erapmoc 'erapmoc ('a 3) ('a 5) ('b 7) ('b 8))))
		  '((b . 8) (b . 7) (a . 5) (a . 3))))
    (test (equal? (gmap (:result list) #'cons
			(:arg wb-2-relation (wb-2-relation ('a 3) ('a 5) ('b 7) ('b 8))))
		  '((a . 3) (a . 5) (b . 7) (b . 8))))
    (test (equal? (gmap (:result list) #'cons
			(:arg fun-2-relation (wb-custom-2-relation 'erapmoc 'erapmoc ('a 3) ('a 5) ('b 7) ('b 8))))
		  '((b . 8) (b . 7) (a . 5) (a . 3))))
    (test (equal? (gmap (:result list) #'cons
			(:arg fun-2-relation (wb-2-relation ('a 3) ('a 5) ('b 7) ('b 8))
			      :from-end? t))
		  '((b . 8) (b . 7) (a . 5) (a . 3))))

    (test (equal? (convert 'wb-2-relation (wb-2-relation ('a 3) ('a 5) ('b 3) ('c 4))
			   :key-compare-fn-name 'erapmoc :val-compare-fn-name 'erapmoc)
		  (wb-custom-2-relation 'erapmoc 'erapmoc ('a 3) ('a 5) ('b 3) ('c 4))))
    (test (equal? (convert 'set (wb-2-relation ('a 3) ('a 5) ('b 3) ('c 4)))
		  (set '(a . 3) '(a . 5) '(b . 3) '(c . 4))))
    (test (equal? (convert 'wb-2-relation (seq '(a . 3) '(a . 5) '(b . 3) '(c . 4)))
		  (wb-2-relation ('a 3) ('a 5) ('b 3) ('c 4))))
    (test (equal? (convert 'wb-2-relation (map ('a 5) ('b 3) ('c 4)))
		  (wb-2-relation ('a 5) ('b 3) ('c 4))))
    (test (equal? (convert '2-relation (map ('a (set 3 5)) ('b (set 2)) ('c (set 4 7)))
			   :from-type 'map-to-sets)
		  (wb-2-relation ('a 3) ('a 5) ('b 2) ('c 4) ('c 7))))
    (test (handler-case (progn
			  (convert 'map (wb-2-relation ('a 3) ('b 2) ('c 4) ('c 7)))
			  nil)
	    (error () t)))
    (test (equal? (convert 'map (wb-2-relation ('a 3) ('b 2) ('c 4)))
		  (map ('a 3) ('b 2) ('c 4))))
    (test (equal? (convert 'wb-map (wb-2-relation ('a 3) ('b 2) ('c 4)))
		  (map ('a 3) ('b 2) ('c 4))))
    (test (equal? (convert 'map-to-sets (wb-2-relation ('a 3) ('a 5) ('b 3) ('c 4) ('c 8)))
		  (map ('a (set 3 5)) ('b (set 3)) ('c (set 4 8)) :default (set))))
    (let ((conv (convert 'map-to-sets (wb-custom-2-relation 'compare 'int-compare
							    ('a 3) ('a 5) ('b 3) ('c 4) ('c 8)))))
      (test (gmap :and (fn (k s) (equal? s (@ conv k)))
		  (:arg map (wb-custom-map nil 'eql-compare
					   ('a (wb-custom-set 'int-compare 3 5)) ('b (wb-custom-set 'int-compare 3))
					   ('c (wb-custom-set 'int-compare 4 8)))))))

    (test (equal? (conflicts (wb-2-relation ('a 3) ('a 5) ('b 3) ('c 4) ('c 8)))
		  (wb-2-relation ('a 3) ('a 5) ('c 4) ('c 8))))

    (test (eq (compare (wb-2-relation ('a 3) ('a 5) ('b 6) ('b 8))
		       (wb-2-relation ('a 3) ('a 5) ('b 7) ('b 8)))
	      ':less))
    (test (eq (compare (wb-2-relation ('a 3) ('a 5) ('b 7) ('b 8))
		       (wb-2-relation ('a 3) ('a 5) ('b 6) ('b 8)))
	      ':greater))

    (test (equal? (transitive-closure (wb-2-relation (1 3) (1 4) (3 7) (3 8) (4 11) (5 14) (6 12) (11 23))
				      (set 1))
		  (set 1 3 4 7 8 11 23)))

    ;; CHAMP
    (test (equal? (empty-ch-2-relation) (empty-ch-2-relation)))
    (test (empty? (empty-ch-2-relation)))
    (test (eql (size (empty-ch-2-relation)) 0))
    (test (eql (size (ch-2-relation (2 3) (2 4) (2 5))) 3))
    (test (equal (multiple-value-list (arb (empty-ch-2-relation))) '(nil nil nil)))
    (test (equal (multiple-value-list (arb (ch-2-relation (1 2))))
                 '(1 2 t)))
    (test (contains? (ch-2-relation (1 2) (1 3) (4 7)) 1 2))
    (test (not (contains? (ch-2-relation (1 2)) 1 3)))
    (test (equal? (lookup (empty-ch-2-relation) 1) (ch-set)))
    (test (equal? (lookup (ch-2-relation (1 2)) 1) (ch-set 2)))
    (test (equal? (lookup-inv (ch-2-relation (1 2)) 2) (ch-set 1)))
    (test (equal? (domain (ch-2-relation (1 2))) (ch-set 1)))
    (test (equal? (range (ch-2-relation (1 2))) (ch-set 2)))
    (test (equal? (inverse (empty-ch-2-relation)) (empty-ch-2-relation)))
    (test (equal? (inverse (ch-2-relation (1 2)))
                  (ch-2-relation (2 1))))

    (test (= 1 (size (with (ch-2-relation (1 2)) 1 2))))
    (test (equal? (ch-2-relation (1 2) (1 3))
                  (inverse (ch-2-relation (3 1) (2 1)))))
    (test (equal? (with (ch-2-relation (1 2)) '(1 . 3))
                  (convert 'ch-2-relation '((1 . 2) (1 . 3)))))
    (test (equal? (with (ch-2-relation (1 2)) 3 4)
                  (convert 'ch-2-relation '((1 . 2) (3 . 4)))))
    (test (equal? (with (ch-2-relation (1 2) (5 3)) 4 3)
                  (convert 'ch-2-relation '((1 . 2) (5 . 3) (4 . 3)))))
    (let ((rel (ch-2-relation (1 2) (2 3))))
      (inverse rel)
      (test (equal? (image (with (with rel 1 3) 4 7) (ch-set 1 4)) (ch-set (ch-set 2 3) (ch-set 7)))))
    (let ((rel (ch-2-relation (1 2) (2 3))))
      (inverse rel)
      (test (equal? (image (inverse (with (with rel 1 3) 4 7)) (ch-set 2 3)) (ch-set (ch-set 1) (ch-set 1 2)))))
    (let ((rela (ch-2-relation (1 3) (1 7) (1 19) (1 32) (1 33) (1 47) (1 53)
			       (1 59) (1 61)))
	  ((relb (with rela 1 67))))
      (test (= (size (union rela relb)) (size relb))))

    (test (equal? (less (empty-ch-2-relation) 1 2) (empty-ch-2-relation)))
    (test (equal? (less (ch-2-relation (1 2)) '(1 . 2)) (empty-ch-2-relation)))
    (test (equal? (less (ch-2-relation (1 2)) 1 3)
                  (ch-2-relation (1 2))))
    (test (equal? (less (ch-2-relation (1 2) (1 3)) 1 3)
                  (ch-2-relation (1 2))))
    (test (equal? (less (ch-2-relation (2 1) (3 1)) 3 1)
                  (ch-2-relation (2 1))))
    (let ((rel (ch-2-relation (1 2) (2 3))))
      (inverse rel)
      (test (equal? (image (with (less rel 1 2) 4 7) (ch-set 2 4)) (ch-set (ch-set 3) (ch-set 7)))))
    (let ((rel (ch-2-relation (1 2) (2 3))))
      (inverse rel)
      (test (equal? (image (inverse (with (less rel 1 2) 4 3)) (ch-set 3)) (ch-set (ch-set 2 4)))))

    (test (equal? (union (empty-ch-2-relation) (empty-ch-2-relation)) (empty-ch-2-relation)))
    (test (equal? (union (ch-2-relation (1 2)) (empty-ch-2-relation))
                  (ch-2-relation (1 2))))
    (test (equal? (ch-2-relation (1 2))
                  (union (ch-2-relation (1 2)) (empty-ch-2-relation))))
    (test (equal? (union (ch-2-relation (1 2)) (ch-2-relation (1 2)))
                  (ch-2-relation (1 2))))
    (test (equal? (union (ch-2-relation (1 2)) (ch-2-relation (1 3)))
                  (ch-2-relation (1 2) (1 3))))
    (test (equal? (union (ch-2-relation (2 1)) (ch-2-relation (3 1)))
                  (ch-2-relation (2 1) (3 1))))
    (test (equal? (union (ch-custom-2-relation 'erapmoc 'erapmoc (3 1)) (ch-2-relation (2 1)))
		  (ch-custom-2-relation 'erapmoc 'erapmoc (2 1) (3 1))))
    (let ((rel (ch-2-relation (1 2) (1 3) (2 3))))
      (inverse rel)
      (test (equal? (image (inverse (union rel (ch-2-relation (4 3)))) (ch-set 3)) (ch-set (ch-set 1 2 4)))))

    (test (equal? (intersection (empty-ch-2-relation) (empty-ch-2-relation)) (empty-ch-2-relation)))
    (test (equal? (intersection (ch-2-relation (1 2)) (empty-ch-2-relation)) (empty-ch-2-relation)))
    (test (equal? (intersection (empty-ch-2-relation) (ch-2-relation (1 2))) (empty-ch-2-relation)))
    (test (equal? (intersection (ch-2-relation (3 4)) (ch-2-relation (1 2))) (empty-ch-2-relation)))
    (test (equal? (intersection (ch-2-relation (1 2)) (ch-2-relation (1 2)))
                  (ch-2-relation (1 2))))
    (test (equal? (intersection (ch-2-relation (1 2)) (ch-2-relation (1 3))) (empty-ch-2-relation)))
    (test (equal? (intersection (ch-2-relation (2 1)) (ch-2-relation (3 1))) (empty-ch-2-relation)))
    (test (equal? (intersection (ch-2-relation ('a 7) ('b 12) ('c 17)) (ch-2-relation ('b 12) ('c 22)))
		  (ch-2-relation ('b 12))))
    (test (equal? (intersection (ch-custom-2-relation 'erapmoc 'erapmoc
						      ('a 7) ('b 12) ('c 17))
				(ch-2-relation ('b 12) ('c 22)))
		  (ch-custom-2-relation 'erapmoc 'erapmoc ('b 12))))
    (let ((rel (ch-2-relation (1 2) (1 3) (2 3))))
      (inverse rel)
      (test (equal? (image (inverse (intersection rel (ch-2-relation (1 3) (4 3)))) (ch-set 3)) (ch-set (ch-set 1)))))

    (test (equal? (join (ch-2-relation ('a 3) ('a 5) ('b 7) ('b 8)) 1
			(ch-2-relation (3 "yo") (7 "eek") (7 "mrr")) 0)
		  (ch-2-relation ('a "yo") ('b "eek") ('b "mrr"))))
    (test (equal? (join (ch-custom-2-relation 'erapmoc 'erapmoc ('a 3) ('a 5) ('b 7) ('b 8)) 1
			(ch-2-relation (3 "hey") (7 "eek") (7 "mrr")) 0)
		  (ch-custom-2-relation 'erapmoc 'compare ('a "hey") ('b "eek") ('b "mrr"))))
    (test (equal? (join (ch-2-relation (3 "mrr") (7 "eek") (7 "mrr")) 0
			(ch-custom-2-relation 'compare 'erapmoc ('a 3) ('a 5) ('b 7) ('b 8)) 1)
		  (ch-2-relation ("eek" 'b) ("mrr" 'a) ("mrr" 'b))))
    (test (equal? (join (ch-2-relation (3 "mrr") (7 "eek") (7 "mrr")) 0
			(ch-custom-2-relation 'erapmoc 'erapmoc ('a 3) ('a 5) ('b 7) ('b 8)) 1)
		  (ch-custom-2-relation 'compare 'erapmoc ("eek" 'b) ("mrr" 'b) ("mrr" 'a))))

    (test (equal? (compose (ch-2-relation ('a 3) ('a 5) ('b 3) ('c 4) ('c 8)) #'1+)
		  (ch-2-relation ('a 4) ('a 6) ('b 4) ('c 5) ('c 9))))
    (test (equal? (compose (ch-2-relation ('a 3) ('a 5) ('b 3) ('c 4) ('c 8))
			   (ch-map (3 7) (4 6) (5 11) (8 15)))
		  (ch-2-relation ('a 7) ('a 11) ('b 7) ('c 6) ('c 15))))

    (test (equal? (image (ch-2-relation ('a 3) ('a 5) ('b 3) ('c 4) ('c 8))
			 (ch-set 'a 'c))
		  (ch-set (ch-set 3 5) (ch-set 4 8))))

    (test (equal? (convert 'set (ch-2-relation ('a 3) ('a 5) ('b 7) ('b 8)))
		  (ch-set '(a . 3) '(a . 5) '(b . 7) '(b . 8))))
    (test (equal? (convert 'ch-set (ch-custom-2-relation 'erapmoc 'erapmoc ('a 3) ('a 5) ('b 7) ('b 8))
			   :compare-fn-name 'erapmoc)
		  (ch-custom-set 'erapmoc '(b . 8) '(b . 7) '(a . 5) '(a . 3))))
    (test (equal? (gmap (:result ch-set) #'cons
			(:arg ch-2-relation (ch-custom-2-relation 'erapmoc 'erapmoc ('a 3) ('a 5) ('b 7) ('b 8))))
		  (ch-set '(b . 8) '(b . 7) '(a . 5) '(a . 3))))
    (test (equal? (gmap (:result ch-set) #'cons
			(:arg fun-2-relation (ch-2-relation ('a 3) ('a 5) ('b 7) ('b 8))))
		  (ch-set '(b . 8) '(b . 7) '(a . 5) '(a . 3))))
    (test (equal? (gmap (:result ch-set) #'cons
			(:arg fun-2-relation (ch-2-relation ('a 3) ('a 5) ('b 7) ('b 8))
			      :from-end? t))
		  (ch-set '(b . 8) '(b . 7) '(a . 5) '(a . 3))))

    (test (equal? (convert 'ch-2-relation (ch-2-relation ('a 3) ('a 5) ('b 3) ('c 4))
			   :key-compare-fn-name 'erapmoc :val-compare-fn-name 'erapmoc)
		  (ch-custom-2-relation 'erapmoc 'erapmoc ('a 3) ('a 5) ('b 3) ('c 4))))
    (test (equal? (convert 'set (ch-2-relation ('a 3) ('a 5) ('b 3) ('c 4)))
		  (ch-set '(a . 3) '(a . 5) '(b . 3) '(c . 4))))
    (test (equal? (convert 'ch-2-relation (ch-map ('a 5) ('b 3) ('c 4)))
		  (ch-2-relation ('a 5) ('b 3) ('c 4))))
    (test (equal? (convert 'ch-2-relation (ch-map ('a (ch-set 3 5)) ('b (ch-set 2)) ('c (ch-set 4 7)))
			   :from-type 'map-to-sets)
		  (ch-2-relation ('a 3) ('a 5) ('b 2) ('c 4) ('c 7))))
    (test (handler-case (progn
			  (convert 'map (ch-2-relation ('a 3) ('b 2) ('c 4) ('c 7)))
			  nil)
	    (error () t)))
    (test (equal? (convert 'map (ch-2-relation ('a 3) ('b 2) ('c 4)))
		  (ch-map ('a 3) ('b 2) ('c 4))))
    (test (equal? (convert 'map-to-sets (ch-2-relation ('a 3) ('a 5) ('b 3) ('c 4) ('c 8)))
		  (ch-map ('a (ch-set 3 5)) ('b (ch-set 3)) ('c (ch-set 4 8)) :default (ch-set))))

    (test (equal? (conflicts (ch-2-relation ('a 3) ('a 5) ('b 3) ('c 4) ('c 8)))
		  (ch-2-relation ('a 3) ('a 5) ('c 4) ('c 8))))

    (test (eq (compare (ch-2-relation ('a 3) ('a 5) ('b 6) ('b 8))
		       (ch-2-relation ('a 3) ('a 5) ('b 7) ('b 8)))
	      ':less))
    (test (eq (compare (ch-2-relation ('a 3) ('a 5) ('b 7) ('b 8))
		       (ch-2-relation ('a 3) ('a 5) ('b 6) ('b 8)))
	      ':greater))

    (test (equal? (transitive-closure (ch-2-relation (1 3) (1 4) (3 7) (3 8) (4 11) (5 14) (6 12) (11 23))
				      (ch-set 1))
		  (ch-set 1 3 4 7 8 11 23)))))

(defun Test-List-Relations ()
  "Simple tests on List-Relations and Query-Registries."
  (declare (optimize (debug 3)))
  (macrolet ((test (form)
               `(unless ,form
                  (error "Test failed: ~S" ',form))))
    (let ((3-rel (with (empty-wb-list-relation) '(age lydia 27)))
	  (q-reg (empty-wb-query-registry)))
      (test (= (arity 3-rel) 3))
      (test (= (size 3-rel) 1))
      (test (equal? (arb 3-rel) '(age lydia 27)))
      (test (contains? 3-rel '(age lydia 27)))
      (test (not (contains? 3-rel '(age lydia 28))))
      (includef 3-rel '(age riley 47))
      (test (equal? (query 3-rel '(age ? ?))
		    (set '(age lydia 27) '(age riley 47))))
      (includef 3-rel '(age riley 25))
      (includef 3-rel '(eye-color riley blue))
      (includef 3-rel '(age dana 31))
      (excludef 3-rel '(age riley 47))
      (test (equal? (query 3-rel '(age ? ?))
		    (set '(age lydia 27) '(age riley 25) '(age dana 31))))
      (test (equal? (query 3-rel '(age riley ?))
		    (set '(age riley 25))))
      (test (equal? (query 3-rel '(age fred ?))
		    (set)))
      (test (equal? (query-multi 3-rel (list (set 'age) (set 'lydia) '?))
		    (set '(age lydia 27))))
      (test (equal? (query-multi 3-rel (list (set 'age 'eye-color) (set 'lydia 'riley) '?))
		    (set '(age lydia 27) '(age riley 25) '(eye-color riley blue))))
      (test (equal? (query-multi-restricted 3-rel (list '? (set 'riley 'lydia) '?) (set 'riley))
		    (set '(age riley 25) '(eye-color riley blue))))
      (includef q-reg '(age ? ?) 'query0)
      (includef q-reg '(age riley ?) 'query1)
      (includef q-reg '(eye-color ? blue) 'query2)
      (includef q-reg '(eye-color ? green) 'query3)
      (test (equal? (lookup q-reg '(age lydia 27))
		    (set 'query0)))
      (test (equal? (lookup q-reg '(age riley 25))
		    (set 'query0 'query1)))
      (test (equal? (lookup-multi q-reg (list (set 'age 'eye-color) (set 'lydia) (set 27 'blue)))
		    (set 'query0 'query2)))
      (test (equal? (gmap (:result set) nil (:arg wb-list-relation 3-rel))
		    (set '(age lydia 27) '(age riley 25) '(eye-color riley blue) '(age dana 31)))))
    (let ((3-rel (with (empty-ch-list-relation 3) '(age lydia 27)))
	  (q-reg (empty-ch-query-registry)))
      (test (= (arity 3-rel) 3))
      (test (= (size 3-rel) 1))
      (test (equal? (arb 3-rel) '(age lydia 27)))
      (test (contains? 3-rel '(age lydia 27)))
      (test (not (contains? 3-rel '(age lydia 28))))
      (includef 3-rel '(age riley 47))
      (test (equal? (query 3-rel '(age ? ?))
		    (ch-set '(age lydia 27) '(age riley 47))))
      (includef 3-rel '(age riley 25))
      (includef 3-rel '(eye-color riley blue))
      (includef 3-rel '(age dana 31))
      (excludef 3-rel '(age riley 47))
      (test (equal? (query 3-rel '(age ? ?))
		    (ch-set '(age lydia 27) '(age riley 25) '(age dana 31))))
      (test (equal? (query 3-rel '(age riley ?))
		    (ch-set '(age riley 25))))
      (test (equal? (query 3-rel '(age fred ?))
		    (ch-set)))
      (test (equal? (query-multi 3-rel (list (ch-set 'age) (ch-set 'lydia) '?))
		    (ch-set '(age lydia 27))))
      (test (equal? (query-multi 3-rel (list (ch-set 'age 'eye-color) (ch-set 'lydia 'riley) '?))
		    (ch-set '(age lydia 27) '(age riley 25) '(eye-color riley blue))))
      (test (equal? (query-multi-restricted 3-rel (list '? (ch-set 'riley 'lydia) '?) (ch-set 'riley))
		    (ch-set '(age riley 25) '(eye-color riley blue))))
      (includef q-reg '(age ? ?) 'query0)
      (includef q-reg '(age riley ?) 'query1)
      (includef q-reg '(eye-color ? blue) 'query2)
      (includef q-reg '(eye-color ? green) 'query3)
      (test (equal? (lookup q-reg '(age lydia 27))
		    (ch-set 'query0)))
      (test (equal? (lookup q-reg '(age riley 25))
		    (ch-set 'query0 'query1)))
      (test (equal? (lookup-multi q-reg (list (ch-set 'age 'eye-color) (ch-set 'lydia) (ch-set 27 'blue)))
		    (ch-set 'query0 'query2)))

      (test (equal? (gmap (:result set) nil (:arg ch-list-relation 3-rel))
		    (set '(age lydia 27) '(age riley 25) '(eye-color riley blue) '(age dana 31)))))))


;;; ----------------
;;; Internal.
(defgeneric verify (coll))

(defmethod verify ((s wb-set))
  (WB-Set-Tree-Verify (wb-set-contents s) (wb-set-compare-fn s)))

(defmethod verify ((b wb-bag))
  (WB-Bag-Tree-Verify (wb-bag-contents b) (tree-set-org-compare-fn (wb-bag-org b))))

(defmethod verify ((m wb-map))
  (WB-Map-Tree-Verify (wb-map-contents m) (tree-map-org-key-compare-fn (wb-map-org m))))

(defmethod verify ((s wb-seq))
  (WB-Seq-Tree-Verify (wb-seq-contents s)))

(defmethod verify ((br wb-2-relation))
  (let ((org (wb-2-relation-org br))
	(map0 (wb-2-relation-map0 br))
	(map1 (wb-2-relation-map1 br))
	((map0-cmp-fn (tree-map-org-key-compare-fn org))
	 (map1-cmp-fn (tree-map-org-val-compare-fn org))))
    (and (WB-Map-Tree-Verify map0 map0-cmp-fn)
	 (let ((size 0))
	   (and (Do-WB-Map-Tree-Pairs (x ys (wb-2-relation-map0 br) t)
		  (WB-Set-Tree-Verify ys map1-cmp-fn)
		  (incf size (WB-Set-Tree-Size ys))
		  (or (null map1)
		      (and (Do-WB-Set-Tree-Members (y ys t)
			     (unless (WB-Map-Tree-Lookup map1 y map1-cmp-fn)
			       (cerror "Ignore and proceed."
				       "No inverse entry for ~S, found in value set for ~S" y x))))))
		(or (= size (wb-2-relation-size br))
		    (cerror "Ignore and proceed."
			    "Size discrepancy in wb-2-relation: expected ~D, found ~D"
			    size (wb-2-relation-size br)))))
	 (or (null map1)
	     (and (WB-Map-Tree-Verify map1 map1-cmp-fn)
		  (Do-WB-Map-Tree-Pairs (y xs map1 t)
		    (Do-WB-Set-Tree-Members (x xs)
		      (unless (WB-Map-Tree-Lookup map0 x map0-cmp-fn)
			(cerror "Ignore and proceed."
				"No entry for ~S, found in inverse value set for ~S" x y)))))))))


(defun Time-Seq-Iter (seq n)
  (time (dotimes (i n)
	  (gmap nil nil (:arg seq seq)))))

(defun Time-Index (seq n)
  (time (dotimes (i n)
	  (dotimes (j (size seq))
	    (WB-Seq-Tree-Subscript (wb-seq-contents seq) i)))))


;;; ================================================================================
;;; CHAMP testing

(defmethod hash-value ((x my-integer))
  ;; Drop the two low-order bits to force collisions, and spread the bits out to force more levels
  ;; to be created.  Also, values equal mod 1024 will have the same hash.
  (let ((val (ash (my-integer-value x) -2)))
    (dpb (ldb (byte 2 6) val)
	 (byte 2 15)
	 (dpb (ldb (byte 2 4) val)
	      (byte 2 10)
	      (dpb (ldb (byte 2 2) val)
		   (byte 2 5)
		   (ldb (byte 2 0) val))))))

(defmethod verify ((s ch-set))
  (ch-set-tree-verify (ch-set-contents s) (hash-set-org-hash-fn (ch-set-org s))))

(defparameter *seq-of-symbols*
  (let ((syms (seq)))
    (do-external-symbols (sym :cl)
      (push-last syms sym))
    syms))

(defun test-champ-sets (n)
  (declare (optimize (speed 0) (debug 3)))
  (macrolet ((test (form)
	       `(unless ,form
		  (error "Test failed: ~S" ',form))))
    (let ((saved-wbs nil)
	  (saved-chs nil))
      (dotimes (i n)
	(when (zerop (mod i 10))
	  (format t "."))
	(let ((cfn (if (zerop (mod i 4)) 'erapmoc 'compare))
	      (wbs (wb-set))
	      ((chs (ch-custom-set cfn)))
	      (use-seq-of-symbols? (= 7 (ldb (byte 3 1) i))))
	  ;; I had this at 256, but that was too high: it forced almost all the maps to have four
	  ;; full or nearly-full levels, making certain scenarios improbable -- and bugs lurked there.
	  (dotimes (j (+ 64 (random 128)))
	    (let ((mi (if use-seq-of-symbols?
			  (@ *seq-of-symbols* (random (size *seq-of-symbols*)))
			(make-my-integer (random 1024))))
		  (prev-wbs wbs)
		  (prev-chs chs))
	      (test (eqv (contains? chs mi) (contains? wbs mi)))
	      (test (or (empty? chs) (contains? chs (arb chs))))
	      (if (< (random 100) 20)
		  (progn
		    (excludef wbs mi)
		    (excludef chs mi)
		    (unless (or (contains? prev-wbs mi)
				(eq chs prev-chs))
		      (error "ch-set less failed to detect no change")))
		(progn
		  (includef wbs mi)
		  (includef chs mi)))
	      (test (verify chs))
	      (let ((wbs-from-ch (convert 'wb-set chs)))
		(unless (equal? wbs wbs-from-ch)
		  (error "ch-set convert 'wb-set or equal? failed")))
	      (test (eqv (subset? chs prev-chs) (subset? wbs prev-wbs)))
	      (when (let ((quot rem (floor j 32)))
		      (and (= 0 rem) (>= quot 1)))
		(let ((elts (wb-set)))
		  (dotimes (k (size chs))
		    (includef elts (at-index chs k)))
		  (unless (equal? elts wbs)
		    (error "ch-set at-index failed")))
		(unless use-seq-of-symbols?
		  (let ((idx (random (size chs)))
			((elt (at-index chs idx))
			 ((tmp-chs (with (less chs elt)
					 ;; Adding 4096 doesn't change the hash value.
					 (make-my-integer (+ (my-integer-value elt) 4096)))))))
		    ;; `ch-set-tree-compare' is tough to test thoroughly.  This at least checks the case that is
		    ;; least obviously correct by inspection, where all the hash values are the same but two elements
		    ;; nonetheless differ.
		    (when (eq (compare-fn-name chs) 'compare)
		      (test (and (eq (compare chs tmp-chs) ':less)
				 (eq (compare tmp-chs chs) ':greater)))))
		  (let ((chs-p0 chs-p1 (partition (fn (x) (evenp (my-integer-value x))) chs))
			(wbs-p0 wbs-p1 (partition (fn (x) (evenp (my-integer-value x))) wbs)))
		    (test (equal? (convert 'wb-set chs-p0) wbs-p0))
		    (test (equal? chs-p1 (convert 'ch-set wbs-p1 :compare-fn-name (compare-fn-name chs)))))
		  (let ((chs-p0 chs-p1 (fset2:partition (fn (x) (evenp (my-integer-value x))) chs))
			(wbs-p0 wbs-p1 (fset2:partition (fn (x) (evenp (my-integer-value x))) wbs)))
		    (test (equal? (convert 'wb-set chs-p0) wbs-p0))
		    (test (equal? chs-p1 (convert 'ch-set wbs-p1 :compare-fn-name (compare-fn-name chs))))))
		(test (equal? chs (convert 'ch-set wbs :compare-fn-name (compare-fn-name chs))))
		(test (equal? chs (convert 'ch-set (convert 'seq wbs) :compare-fn-name (compare-fn-name chs))))
		(test (equal? chs (convert 'ch-set (convert 'vector wbs) :compare-fn-name (compare-fn-name chs))))
		(let ((k 0)
		      (it (iterator chs))
		      (f-it (fun-iterator chs)))
		  (do-set (x chs)
		    (test (equal? x (at-index chs k)))
		    (test (funcall it ':more?))
		    (test (not (funcall f-it ':empty?)))
		    (let ((itval (funcall it ':get))
			  (f-itval (funcall f-it ':first)))
		      (test (equal? x itval))
		      (test (equal? x f-itval)))
		    (test (= (index chs x) k))
		    (incf k)
		    (setq f-it (funcall f-it ':rest)))
		  (test (funcall it ':done?))
		  (test (funcall f-it ':empty?)))
		(test (equal? (reverse (convert 'seq chs))
			      (gmap (:result seq) nil (:arg fun-sequence chs :from-end? t)))))))
	  (when saved-chs
	    (flet ((check-pref (result label &optional right?)
		     (let ((bad (gmap :or (fn (x) (let ((sx? sx (lookup result x)))
						    (and sx? (not (eq x sx)) x)))
				      (:arg set (if right? saved-chs chs)))))
		       (when bad
			 (error "~A failed ~:[left~;right~] preference: ~A"
				label right? bad)))))
	      (let ((chs-union (union chs saved-chs)))
		(test (verify chs-union))
		(test (equal? (convert 'wb-set chs-union) (union wbs saved-wbs)))
		(check-pref chs-union "Set union"))
	      (let ((chs-intersection (intersection chs saved-chs)))
		(test (verify chs-intersection))
		(test (equal? (convert 'wb-set chs-intersection) (intersection wbs saved-wbs)))
		(check-pref chs-intersection "Set intersection"))
	      (let ((chs-diff (set-difference chs saved-chs)))
		(test (verify chs-diff))
		(test (equal? (convert 'wb-set chs-diff) (set-difference wbs saved-wbs)))
		(check-pref chs-diff "Set difference")
		(let ((chs-diff-2a chs-diff-2b (set-difference-2 chs saved-chs)))
		  (test (verify chs-diff-2a))
		  (test (verify chs-diff-2b))
		  (test (equal? chs-diff-2a chs-diff))
		  (test (equal? chs-diff-2b (set-difference saved-chs chs)))
		  (check-pref chs-diff-2a "Set difference-2")
		  (check-pref chs-diff-2b "Set difference-2" t)))))
	  ;; To get a good test for `disjoint?', we need different statistics -- choosing 256 out of 1024,
	  ;; disjointness is astronomically unlikely.  Choosing 55 out of 4096 gives roughly 50% odds.
	  ;; (Why so few?  The Birthday Paradox.)
	  (let ((wbs0 (gmap (:result wb-set) (fn (_i) (make-my-integer (random 4096))) (:arg index 0 55)))
		(wbs1 (gmap (:result wb-set) (fn (_i) (make-my-integer (random 4096))) (:arg index 0 55)))
		((chs0 (convert 'ch-set wbs0))
		 (chs1 (convert 'ch-set wbs1))))
	    (test (eqv (disjoint? chs0 chs1) (disjoint? wbs0 wbs1))))
	  (setq saved-wbs wbs)
	  (setq saved-chs chs))))))

(defmethod verify ((m ch-map))
  (let ((hmorg (ch-map-org m)))
    (ch-map-tree-verify (ch-map-contents m) (hash-map-org-key-hash-fn hmorg) (hash-map-org-val-hash-fn hmorg))))

(defvar *champ-map-test-pairs* (seq))

(defun test-champ-maps (n)
  (declare (optimize (speed 0) (debug 3)))
  (macrolet ((test (form)
	       `(unless ,form
		  (error "Test failed: ~S" ',form))))
    (let ((saved-wbm nil)
	  (saved-chm nil))
      (dotimes (i n)
	(when (zerop (mod i 10))
	  (format t "."))
	(let ((cfn (if (zerop (mod i 4)) 'erapmoc 'compare))
	      (wbm (wb-map))
	      ((chm (ch-custom-map cfn nil)))
	      (use-seq-of-symbols? (= 7 (ldb (byte 3 1) i))))
	  (setq *champ-map-test-pairs* (seq))
	  (dotimes (j (+ 64 (random 128)))
	    (let ((mi (if use-seq-of-symbols?
			  (@ *seq-of-symbols* (random (size *seq-of-symbols*)))
			(make-my-integer (random 1024))))
		  (val (make-my-integer (random 128)))
		  (prev-wbm wbm)
		  (prev-chm chm))
	      (test (eql (lookup chm mi) (lookup wbm mi)))
	      (test (or (empty? chm) (let ((k v (arb chm)))
				       (equal? v (lookup chm k)))))
	      (if (< (random 100) 20)
		  (progn
		    (push-last *champ-map-test-pairs* (list '- mi val))
		    (excludef wbm mi)
		    (excludef chm mi)
		    (test (or (domain-contains? prev-wbm mi)
			      (eq chm prev-chm))))
		(progn
		  (push-last *champ-map-test-pairs* (list '+ mi val))
		  (setf (@ wbm mi) val)
		  (setf (@ chm mi) val)))
	      (when (< (random 100) 5)
		;; Cause value hashes to be cached, triggering incremental updating.
		(hash-value chm))
	      (test (verify chm))
	      (when (let ((quot rem (floor j 32)))
		      (and (= 0 rem) (>= quot 1)))
		(let ((wbm-from-ch (convert 'wb-map chm)))
		  (unless (equal? wbm wbm-from-ch)
		    (error "ch-map equal? failed on ~A~%vs. ~A:~%diffs ~A~%prev ~A" wbm chm
			   (multiple-value-list (map-difference-2 wbm wbm-from-ch)) prev-chm)))
		(let ((ch-dom (domain chm)))
		  (test (verify ch-dom))
		  (test (equal? (convert 'wb-set ch-dom) (domain wbm))))
		(unless use-seq-of-symbols?
		  (let ((idx (random (size chm)))
			((elt (at-index chm idx))
			 ((chm-less-elt tval (less chm elt))
			  ((tmp-chm (with chm-less-elt
					  ;; Adding 4096 doesn't change the hash value.
					  (make-my-integer (+ (my-integer-value elt) 4096))
					  (@ chm elt)))))))
		    (test (verify chm-less-elt))
		    (test (equal? tval (@ chm elt)))
		    (test (verify tmp-chm))
		    ;; `ch-map-tree-compare' is tough to test thoroughly.  This at least checks the case that is
		    ;; least obviously correct by inspection, where all the hash values are the same but two elements
		    ;; nonetheless differ.
		    (when (eq (key-compare-fn-name chm) 'compare)
		      (test (eq (compare chm tmp-chm) ':less))
		      (test (eq (compare tmp-chm chm) ':greater)))))
		(let ((k 0)
		      (it (iterator chm))
		      (f-it (fun-iterator chm)))
		  (do-map (x y chm)
		    (let ((idxx idxy (at-index chm k)))
		      (test (and (equal? x idxx) (equal? y idxy))))
		    (test (funcall it ':more?))
		    (test (not (funcall f-it ':empty?)))
		    (let ((itval (funcall it ':get))
			  (f-itval (funcall f-it ':first)))
		      (test (equal? x itval))
		      (test (equal? x f-itval)))
		    (test (= (index chm x) k))
		    (incf k)
		    (setq f-it (funcall f-it ':rest)))
		  (test (funcall it ':done?))
		  (test (funcall f-it ':empty?)))
		(test (equal? (reverse (convert 'seq chm))
			      (gmap (:result seq) #'cons (:arg fun-map chm :from-end? t)))))))
	  (flet ((filter-mod-8 (x y)
		   (declare (ignore x))
		   (if (zerop (mod (my-integer-value y) 8))
		       (values nil ':no-value)
		     y))
		 (check-pref (result source label &optional right?)
		   (let ((bad (gmap :or (fn (k v) (let ((mv mv? mk (lookup result k)))
						    (and mv? (or (not (eq k mk))
								 (and (equal? v mv) (not (eql v mv))))
							 k)))
				    (:arg map source))))
		     (when bad
		       (error "~A failed ~:[left~;right~] preference on iteration ~D: ~A"
			      label right? i bad)))))
	    (when saved-chm
	      (let ((chm-union (map-union chm saved-chm #'filter-mod-8)))
		(test (verify chm-union))
		(let ((wbm-union (map-union wbm saved-wbm #'filter-mod-8))
		      ((chm-union-as-wbm (convert 'wb-map chm-union))))
		  (unless (equal? chm-union-as-wbm wbm-union)
		    (let ((ch-only wb-only (map-difference-2 chm-union-as-wbm wbm-union)))
 		      (error "ch-map union failed: ~A, ~A" ch-only wb-only))))
		(check-pref chm-union chm "Map union"))
	      (let ((chm-intersection (map-intersection chm saved-chm #'filter-mod-8)))
		(test (verify chm-intersection))
		(let ((wbm-intersection (map-intersection wbm saved-wbm #'filter-mod-8))
		      ((chm-int-as-wbm (convert 'wb-map chm-intersection))))
		  (test (equal? chm-int-as-wbm wbm-intersection)))
		(check-pref chm-intersection chm "Map intersection"))
	      (let ((chm-diff-2a chm-diff-2b (map-difference-2 chm saved-chm))
		    (wbm-diff-2a wbm-diff-2b (map-difference-2 wbm saved-wbm)))
		(test (verify chm-diff-2a))
		(test (verify chm-diff-2b))
		(test (equal? (convert 'wb-map chm-diff-2a) wbm-diff-2a))
		(test (equal? (convert 'wb-map chm-diff-2b) wbm-diff-2b))
		(check-pref chm-diff-2a chm "Map difference-2")
		(check-pref chm-diff-2b saved-chm "Map difference-2" t))
	      ;; &&& `restrict' and `restrict-not'
	      (let ((saved-chm-dom (domain saved-chm))
		    (saved-wbm-dom (domain saved-wbm))
		    ((ch-pos (restrict chm saved-chm-dom))
		     (ch-neg (restrict-not chm saved-chm-dom))
		     (wb-pos (restrict wbm saved-wbm-dom))
		     (wb-neg (restrict-not wbm saved-wbm-dom))))
		(test (verify ch-pos))
		(test (verify ch-neg))
		(test (equal? (convert 'wb-map ch-pos) wb-pos))
		(test (equal? (convert 'wb-map ch-neg) wb-neg)))))
	  (setq saved-wbm wbm)
	  (setq saved-chm chm))))))


;;; ====================================================================================================
;;; ====================================================================================================

;;; FSet2 testing

(in-package :fset2)

(define-tuple-key +k5+ :default 'plugh)
(define-tuple-key +k6+)

(defun fset::test-fset2 ()
  (declare (optimize (debug 3)))
  (test-fset2-gmap)
  (macrolet ((test (form)
	       `(unless ,form
		  (error "Test failed: ~S" ',form)))
	     (test-error (form)
	       `(unless (handler-case (progn ,form nil)
			  (error () t))
		  (error "Test-error failed: ~S" ',form))))
    #+sbcl
    ;; Check that each shadowed GF has the same methods in `fset:' and `fset2:'.
    (flet ((methods (gf)
	     (gmap (:result set)
		   (fn (method) (caddr (getf (slot-value method 'sb-pcl::plist) ':name)))
		   (:arg list (slot-value gf 'sb-pcl::methods)))))
      ;; `image' is a special case; its methods on maps have been moved to `map-image'.
      (dolist (gf-name '(lookup map-union map-intersection map-difference-2 compose filter partition rank))
	(let ((fset-gf (symbol-function (intern (string gf-name) ':fset)))
	      (fset2-gf (symbol-function gf-name))
	      ((missing extra (set-difference-2 (methods fset-gf) (methods fset2-gf)))))
	  (unless (and (empty? missing) (empty? extra))
	    (error "Methods on ~A missing: ~A~:[~;~%extra: ~A~]" gf-name missing (nonempty? extra) extra))))
      ;; Also check that all the shadowed symbols used in `eql' specializers on `convert' work in `fset2:'.
      (let ((convert-methods (methods #'convert))
	    (all-missing (map))
	    (all-extra (map)))
	(dolist (to-type '(set map wb-map ch-map map-to-sets seq wb-seq))
	  (let ((fset-sym (intern (string to-type) ':fset))
		(fset2-methods (image #'cdr (gmap (:result set :filterp (fn (x) (equal (car x) `(eql ,to-type))))
						  nil (:arg set convert-methods))))
		((fset-methods (image #'cdr (gmap (:result set :filterp (fn (x) (equal (car x) `(eql ,fset-sym))))
						  nil (:arg set convert-methods))))
		 ((missing extra (set-difference-2 fset-methods fset2-methods)))))
	    (when (nonempty? missing)
	      (setf (@ all-missing to-type) missing))
	    (when (nonempty? extra)
	      (setf (@ all-extra to-type) extra))
	    ;; Also, a GMap check.
	    (when (and (or (get fset-sym 'gmap::arg-type-expander) (get fset-sym 'gmap::arg-type-synonym))
		       (not (or (get to-type 'gmap::arg-type-expander) (get to-type 'gmap::arg-type-synonym))))
	      (error "fset:~A is a GMap arg type, but its fset2: version isn't" fset-sym))
	    (when (and (or (get fset-sym 'gmap::res-type-expander) (get fset-sym 'gmap::res-type-synonym))
		       (not (or (get to-type 'gmap::res-type-expander) (get to-type 'gmap::res-type-synonym))))
	      (error "fset:~A is a GMap result type, but its fset2: version isn't" fset-sym))))
	(unless (and (empty? all-missing) (empty? all-extra))
	  (error "Convert methods missing: ~A~:[~;~%extra: ~A~]" all-missing (nonempty? all-extra) all-extra))))
    ;; Just checking that these `lookup' methods exist
    (let ((ls '(0 1 2 3 4 5 6 7 8 9)))
	(test (equal (@ ls 'first) 0))
	(test (equal (with ls 'first 10) '(10 1 2 3 4 5 6 7 8 9)))
	(test (equal (@ ls 'second) 1))
	(test (equal (with ls 'second 11) '(0 11 2 3 4 5 6 7 8 9)))
	(test (equal (@ ls 'third) 2))
	(test (equal (with ls 'third 12) '(0 1 12 3 4 5 6 7 8 9)))
	(test (equal (@ ls 'fourth) 3))
	(test (equal (with ls 'fourth 13) '(0 1 2 13 4 5 6 7 8 9)))
	(test (equal (@ ls 'fifth) 4))
	(test (equal (with ls 'fifth 14) '(0 1 2 3 14 5 6 7 8 9)))
	(test (equal (@ ls 'sixth) 5))
	(test (equal (with ls 'sixth 15) '(0 1 2 3 4 15 6 7 8 9)))
	(test (equal (@ ls 'seventh) 6))
	(test (equal (with ls 'seventh 16) '(0 1 2 3 4 5 16 7 8 9)))
	(test (equal (@ ls 'eighth) 7))
	(test (equal (with ls 'eighth 17) '(0 1 2 3 4 5 6 17 8 9)))
	(test (equal (@ ls 'ninth) 8))
	(test (equal (with ls 'ninth 18) '(0 1 2 3 4 5 6 7 18 9)))
	(test (equal (@ ls 'tenth) 9))
	(test (equal (with ls 'tenth 19) '(0 1 2 3 4 5 6 7 8 19))))
    (test (equal? (multiple-value-list (@ (wb-set 2 3) 2))
		  '(t 2)))
    (test (equal? (multiple-value-list (@ (ch-set 2 3) 2))
		  '(t 2)))
    (test (equal? (@ (bag 1 1 2) 2) 1))
    (test (equal? (@ '1+ 1) 2))
    (test (equal? (@ #'1+ 1) 2))
    (test (equal? (@ #(foo bar baz) 1) 'bar))
    (test (equal? (multiple-value-list (@ (wb-replay-set 17 3) 3))
		  '(t 3)))
    (test (equal? (multiple-value-list (@ (ch-replay-set 17 3) 3))
		  '(t 3)))
    (test (equal? (multiple-value-list (@ (wb-replay-map ('foo 17) ('bar 3)) 'foo))
		  '(17 t)))
    (test-error (@ (replay-map :no-default ('foo 17) ('bar 3)) 'baz))
    (test-error (@ (ch-replay-map :no-default ('foo 17) ('bar 3)) 'baz))
    (test-error (@ (wb-replay-map :no-default ('foo 17) ('bar 3)) 'baz))
    (test (equal? (multiple-value-list (@ (ch-replay-set 17 3) 3))
		  '(t 3)))

    (test (equal? (convert 'set (seq 3 19 'zot "xyzzy"))
		  (ch-set 3 19 'zot "xyzzy")))
    (test (equal? (convert 'set #(3 19 zot "xyzzy"))
		  (ch-set 3 19 'zot "xyzzy")))
    (test (equal? (convert 'wb-set (convert 'ch-set (set 3 19 'zot "xyzzy") :compare-fn-name 'erapmoc))
		  (wb-set 3 19 'zot "xyzzy")))
    (test (equal? (convert 'set (map ('a 3) ('b 7)))
		  (set '(a . 3) '(b . 7))))
    (test (equal? (convert 'ch-map (bag (% 'a 7) 'b 'b 'c))
		  (map ('a 7) ('b 2) ('c 1))))
    (test (equal? (convert 'seq (map (1 3) (2 10) :default 17))
		  (seq '(1 . 3) '(2 . 10))))

    ;; New defaulting semantics for `map-union', `map-intersection', `map-difference-2', and `compose'
    (let ((chm (map ('a 3)))
	  (chm-d (map ('a 3) :default 42))
	  (chm-no-d (map ('a 2) :no-default))
	  (wbm (wb-map ('c 7)))
	  (wbm-d (wb-map ('c 7) :default 21))
	  (wbm-no-d (wb-map ('c 7) :no-default)))
      (test (equal? (@ chm 'b) nil))
      (test (equal? (@ chm-d 'b) 42))
      (test-error (@ chm-no-d 'b))
      (test (equal? (incf (lookup chm-no-d 'a)) 3))
      (test-error (incf (@ chm-no-d 'b)))
      (test-error (incf (lookup chm-no-d 'b)))
      (test (equal? (let ((tmp chm-d))
		      (decf (@ tmp 'b))
		      tmp)
		    (map ('a 3) ('b 41) :default 42)))
      (test (equal? (multiple-value-list (default chm)) '(nil t)))
      (test (equal? (multiple-value-list (default chm-d)) '(42 t)))
      (test (equal? (multiple-value-list (default chm-no-d)) '(nil nil)))
      (test (equal? (multiple-value-list (default (seq))) '(nil t)))
      (test (equal? (multiple-value-list (default (empty-seq :default 42))) '(42 t)))
      (test (equal? (multiple-value-list (default (empty-seq :no-default? t))) '(nil nil)))

      (test (equal? (map-union chm (map ('b 4)))
		    (ch-map ('a 3) ('b 4))))
      (test (not (equal? (map-union chm (map ('b 4)))
			 (ch-map ('a 3) ('b 4) :default 7))))
      (test (equal? (map-union chm-d (map ('b 4)))
		    (map ('a 3) ('b 4)))) ; val-fn discards left default
      (test (equal? (map-union (map ('b 4)) chm-no-d)
		    (map ('a 3) ('b 4))))
      (test (equal? (map-union (map ('b 4) :no-default) chm-no-d)
		    (map ('a 3) ('b 4) :no-default)))
      (test (equal? (map-union (map ('b 4) :no-default) chm-d)
		    (map ('a 3) ('b 4) :default 42)))
      (test (equal? (map-union (map ('b 4)) chm-d (fn (_x y) (if (= y 42) (values nil ':no-value)
							       y)))
		    (map ('a 3) ('b 4) :no-default)))
      (test (equal? (map-union wbm-d (wb-map ('b 4)))
		    (wb-map ('b 4) ('c 7)))) ; val-fn discards left default
      (test (equal? (map-union (wb-map ('b 4)) wbm-no-d)
		    (wb-map ('b 4) ('c 7))))
      (test (equal? (map-union (wb-map ('b 4) :no-default) wbm-no-d)
		    (wb-map ('b 4) ('c 7) :no-default)))
      (test (equal? (map-union (wb-map ('b 4) :no-default) wbm-d)
		    (wb-map ('b 4) ('c 7) :default 21)))
      (test (equal? (map-union (wb-map ('b 4)) wbm-d (fn (_x y) (if (= y 21) (values nil ':no-value)
								  y)))
		    (wb-map ('b 4) ('c 7) :no-default)))
      (test (equal? (map-union chm wbm)
		    (ch-map ('a 3) ('c 7))))
      (test (equal? (map-union wbm-d chm-no-d)
		    (wb-map ('a 3) ('c 7) :default 21)))
      (test (equal? (map-union chm-d wbm-no-d)
		    (ch-map ('a 3) ('c 7) :default 42)))

      (test (equal? (map-intersection chm chm-d) chm-d))
      (test (equal? (map-intersection chm chm-no-d) chm-no-d))
      (test (equal? (map-intersection chm-no-d chm) chm-no-d))
      (test (equal? (map-intersection chm chm-d (fn (_x y) (if (= y 42) (values nil ':no-value)
							     y)))
		    chm-no-d))
      (test (equal? (map-intersection wbm wbm-d) wbm-d))
      (test (equal? (map-intersection wbm wbm-no-d) wbm-no-d))
      (test (equal? (map-intersection wbm-no-d wbm) wbm-no-d))
      (test (equal? (map-intersection wbm wbm-d (fn (_x y) (if (= y 21) (values nil ':no-value)
							     y)))
		    wbm-no-d))
      (test (equal? (map-intersection chm (wb-map ('a 4) :default 17)) (ch-map ('a 4) :default 17)))
      (test (equal? (map-intersection wbm chm-no-d) (wb-map :no-default)))
      (test (equal? (map-intersection wbm (ch-map ('c 9) :default 42)
				      (fn (_x y) (if (= y 42) (values nil ':no-value)
						   y)))
		    (wb-map ('c 9) :no-default)))

      (test (equal? (multiple-value-list (map-difference-2 chm chm-d))
		    (list (map) (map :default 42))))
      (test (equal? (multiple-value-list (map-difference-2 chm (map ('a 4))))
		    (list (map ('a 3) :no-default) (map ('a 4) :no-default))))
      (test (equal? (multiple-value-list (map-difference-2 chm wbm-d))
		    (list (map ('a 3)) (wb-map ('c 7) :default 21))))
      (test (equal? (multiple-value-list (map-difference-2 (wb-map ('c 7) ('z 14) :default 42) wbm-d))
		    (list (wb-map ('z 14) :default 42) (wb-map :default 21))))
      (test (equal? (multiple-value-list (map-difference-2 wbm (map ('a 4))))
		    (list (wb-map ('c 7) :no-default) (map ('a 4) :no-default))))

      (test (equal? (filter #'evenp (seq 1 2 3 4 5)) (seq 2 4)))
      (test (equal? (filter #'evenp (with-default (seq 1 2 3 4 5) 17))
		    (with-default (seq 2 4) 17)))
      (test (equal? (filter 'evenp (seq 1 2 3 4 5)) (seq 2 4)))
      (test (equal? (filter (map (1 t) (3 t)) (seq 1 2 3 4 5)) (seq 1 3)))
      (test (equal? (filter (set 1 3 9) (seq 1 2 3 4 5)) (seq 1 3)))
      (test (equal? (filter (bag 1 1 3 9) (seq 1 2 3 4 5)) (seq 1 3)))

      (test (equal? (multiple-value-list (partition (map (1 t) (4 t) (7 t)) (wb-set 0 1 2 3 4 5 6 7)))
		    (list (wb-set 1 4 7) (wb-set 0 2 3 5 6))))
      (test (equal? (multiple-value-list (partition (map (1 t) (4 t) (7 t)) (ch-set 0 1 2 3 4 5 6 7)))
		    (list (ch-set 1 4 7) (ch-set 0 2 3 5 6))))

      (test (equal? (compose (wb-map ('a 7)) (map (7 12) :default 3))
		    (wb-map ('a 12) :default 3)))
      (test (equal? (compose (wb-map ('a 7) :no-default) (map (7 12) :default 3))
		    (wb-map ('a 12) :no-default)))
      (test-error (compose (wb-map ('a 6)) (map (7 12) :no-default)))
      (test-error (fset:compose (wb-map ('a 6)) (map (7 12) :no-default)))
      (test-error (compose (wb-map ('a 6)) (map (7 12) :no-default)))
      (test-error (fset:compose (wb-map ('a 6)) (map (7 12) :no-default)))
      (test (equal? (compose (wb-map ('a 7) :no-default) (map (7 12) :no-default))
		    (wb-map ('a 12) :no-default)))
      (test (equal? (compose (ch-map ('a 7)) (map (7 12) :default 3))
		    (ch-map ('a 12) :default 3)))
      (test (equal? (compose (ch-map ('a 7) :no-default) (map (7 12) :default 3))
		    (ch-map ('a 12) :no-default)))
      (test-error (compose (ch-map ('a 6)) (map (7 12) :no-default)))
      (test-error (fset:compose (ch-map ('a 6)) (map (7 12) :no-default)))
      (test-error (compose (wb-map ('a 6)) (map (7 12) :no-default)))
      (test-error (fset:compose (wb-map ('a 6)) (map (7 12) :no-default)))
      (test (equal? (compose (ch-map ('a 7) :no-default) (map (7 12) :no-default))
		    (ch-map ('a 12) :no-default)))

      (test (equal? (map-image (lambda (k v) (values (1+ k) (+ v 2)))
                               (map (1 2) (2 3) (3 3)))
                    (map (2 4) (3 5) (4 5))))
      (test (equal? (map-image (lambda (k v) (values (1+ k) (+ v 2)))
                               (wb-map (1 2) (2 3) (3 3)))
                    (wb-map (2 4) (3 5) (4 5))))
      (test (equal? (map-image #'values (map (1 2) (4 6)))
		    (map (1 2) (4 6))))
      (test (equal? (map-image #'values (wb-map (1 2) (4 6)))
		    (wb-map (1 2) (4 6))))
      (test (equal? (map-image 'values (map (1 2) (4 6)))
		    (map (1 2) (4 6))))
      (test (equal? (map-image 'values (ch-map (1 2) (4 6)))
		    (ch-map (1 2) (4 6))))
      (test (equal? (map-image #'values (map (1 2) (4 6)) :default 8)
		    (map (1 2) (4 6) :default 8)))
      (test (equal? (map-image #'values (wb-map (1 2) (4 6)) :default 8)
		    (wb-map (1 2) (4 6) :default 8)))
      (test (equal? (map-image '+ (map (1 2) (4 6)))
                    (map (3 nil) (10 nil))))
      (test (equal? (map-image '+ (wb-map (1 2) (4 6)))
                    (wb-map (3 nil) (10 nil))))

      (test (= (rank (wb-set 1 3 5) 2) 1))
      (test (equal? (@ (tuple) +k5+) 'plugh))
      (test (equal? (@ (tuple) +k6+) nil))
      (test (equal? (@ (tuple) (get-tuple-key 'fubar :default 11)) 11))
      (test-error (@ (tuple) (get-tuple-key 'fubar :no-default? t)))
      (test (equal? (@ (tuple) (get-tuple-key 'fubar :default 0)) 0))
      (test (equal? (@ (tuple) (get-tuple-key 'zot)) nil))

      (test (equal? (filter #'evenp (seq 1 2 3 4 5)) (seq 2 4)))
      (test (equal? (filter #'evenp (with-default (seq 1 2 3 4 5) 17))
		    (with-default (seq 2 4) 17)))
      (test (equal? (filter 'evenp (seq 1 2 3 4 5)) (seq 2 4)))
      (test (equal? (filter (map (1 t) (3 t)) (seq 1 2 3 4 5)) (seq 1 3)))
      (test (equal? (filter (set 1 3 9) (seq 1 2 3 4 5)) (seq 1 3)))
      (test (equal? (filter (bag 1 1 3 9) (seq 1 2 3 4 5)) (seq 1 3)))

      (test (equal? (image #'1+ (seq 1 7 5 :no-default)) (seq 2 8 6 :no-default)))
      (test (equal? (image '1+ (seq 1 7 5 :no-default)) (seq 2 8 6 :no-default)))
      (test (equal? (image #'1+ (seq 1 7 5 :default 0))
		    (seq 2 8 6 :default 1)))
      (test (equal? (image (map (1 8) (3 10)) (seq 0 1 2 3 4 5))
		    (seq nil 8 nil 10 nil nil)))
      (test (equal? (image (set -3 1 3 21) (seq 0 1 2 3 4 5))
		    (seq nil t nil t nil nil)))
      (test (equal? (image (bag 1 3 3 10) (without-default (seq 0 1 2 3 4 5)))
		    (without-default (seq 0 1 0 2 0 0))))
      (test (equal? (convert 'set (wb-2-relation ('a 3) ('a 5) ('b 3) ('c 4)))
		    (wb-set '(a . 3) '(a . 5) '(b . 3) '(c . 4))))
      (test (equal? (convert 'set (ch-2-relation ('a 3) ('a 5) ('b 3) ('c 4)))
		    (ch-set '(a . 3) '(a . 5) '(b . 3) '(c . 4))))
      (test (equal? (convert 'wb-2-relation (wb-map ('a 5) ('b 3) ('c 4)))
		    (wb-2-relation ('a 5) ('b 3) ('c 4))))
      (test (equal? (convert '2-relation (ch-map ('a 5) ('b 3) ('c 4)))
		    (2-relation ('a 5) ('b 3) ('c 4))))
      (test (equal? (convert 'wb-2-relation (wb-map ('a (set 3 5)) ('b (set 2)) ('c (set 4 7)))
			     :from-type 'map-to-sets)
		    (wb-2-relation ('a 3) ('a 5) ('b 2) ('c 4) ('c 7))))
      (test (equal? (convert '2-relation (map ('a (set 3 5)) ('b (set 2)) ('c (set 4 7)))
			     :from-type 'map-to-sets)
		    (ch-2-relation ('a 3) ('a 5) ('b 2) ('c 4) ('c 7))))
      (test (equal? (convert 'map (ch-2-relation ('a 3) ('b 2) ('c 4)))
		    (map ('a 3) ('b 2) ('c 4))))
      (test (equal? (convert 'wb-map (wb-2-relation ('a 3) ('b 2) ('c 4)))
		    (wb-map ('a 3) ('b 2) ('c 4))))
      (test (equal? (convert 'map (ch-2-relation ('a 3) ('b 2) ('c 4)))
		    (map ('a 3) ('b 2) ('c 4))))
      (test (equal? (convert 'ch-map (ch-2-relation ('a 3) ('b 2) ('c 4)))
		    (map ('a 3) ('b 2) ('c 4))))
      (test (equal? (convert 'map-to-sets (wb-2-relation ('a 3) ('a 5) ('b 3) ('c 4) ('c 8)))
		    (wb-map ('a (wb-set 3 5)) ('b (wb-set 3)) ('c (wb-set 4 8)) :default (wb-set))))
      (test (equal? (convert 'map-to-sets (ch-2-relation ('a 3) ('a 5) ('b 3) ('c 4) ('c 8)))
		    (map ('a (set 3 5)) ('b (set 3)) ('c (set 4 8)) :default (ch-set))))
      (let ((conv (convert 'map-to-sets (ch-custom-2-relation 'compare 'fset::int-compare
							      ('a 3) ('a 5) ('b 3) ('c 4) ('c 8)))))
	(test (gmap :and (fn (k s) (equal? s (@ conv k)))
		    (:arg map (ch-custom-map nil 'eql-compare
					     ('a (ch-custom-set 'fset::int-compare 3 5))
					     ('b (ch-custom-set 'fset::int-compare 3))
					     ('c (ch-custom-set 'fset::int-compare 4 8))))))))))

(defun test-fset2-gmap ()
  (macrolet ((test (form)
	       `(unless ,form
		  (error "Test failed: ~S" ',form))))
    (test (equal? (gmap (:result list) nil (:arg set (wb-set 13 7 41 2)))
		  '(2 7 13 41)))
    (test (equal? (sort (gmap (:result list) nil (:arg set (ch-set 13 7 41 2))) #'<)
		  '(2 7 13 41)))
    (test (equal? (gmap (:result list) nil (:arg wb-set (wb-set 13 7 41 2)))
		  '(2 7 13 41)))
    (test (equal? (sort (gmap (:result list) nil (:arg ch-set (ch-set 13 7 41 2))) #'<)
		  '(2 7 13 41)))
    (test (equal? (gmap (:result set) nil (:arg list '(8 3 14 6)))
		  (ch-set 8 3 14 6)))
    (test (equal? (gmap (:result wb-set :compare-fn-name 'erapmoc) nil (:arg list '(8 3 14 6)))
		  (wb-custom-set 'erapmoc 8 3 14 6)))
    (test (equal? (gmap (:result ch-set :compare-fn-name 'erapmoc) nil (:arg list '(8 3 14 6)))
		  (ch-custom-set 'erapmoc 8 3 14 6)))
    (test (equal? (gmap (:result union) nil (:arg list (list (set 3 7) (set 9 1))))
		  (ch-set 1 3 7 9)))
    (test (equal? (gmap (:result intersection) nil (:arg list (list (set 3 7 9) (set 9 3))))
		  (ch-set 3 9)))

    (test (equal? (gmap (:result list) nil (:arg bag (bag 3 7 (% 9 2))))
		  '(3 7 9 9)))
    (test (equal? (gmap (:result list) nil (:arg wb-bag (bag 3 7 (% 9 2))))
		  '(3 7 9 9)))
    (test (equal? (gmap (:result list) #'cons (:arg bag-pairs (bag 3 7 (% 9 2))))
		  '((3 . 1) (7 . 1) (9 . 2))))
    (test (equal? (gmap (:result list) #'cons (:arg wb-bag-pairs (bag 3 7 (% 9 2))))
		  '((3 . 1) (7 . 1) (9 . 2))))
    (test (equal? (gmap (:result list) #'cons (:arg fun-bag-pairs (bag 3 7 (% 9 2))))
		  '((3 . 1) (7 . 1) (9 . 2))))
    (test (equal? (gmap (:result bag) nil (:arg list '(3 7 9 2 7 3)))
		  (wb-bag 2 (% 3 2) (% 7 2) 9)))
    (test (equal? (gmap (:result bag-pairs) (fn (x) (values (car x) (cdr x)))
			(:arg list '((a . 2) (b . 6) (q . 4))))
		  (wb-bag (% 'a 2) (% 'b 6) (% 'q 4))))
    (test (equal? (gmap (:result wb-bag :compare-fn-name 'erapmoc) nil (:arg list '(3 7 9 2 7 3)))
		  (wb-custom-bag 'erapmoc 2 (% 3 2) (% 7 2) 9)))
    (test (equal? (gmap (:result wb-bag-pairs :compare-fn-name 'erapmoc) (fn (x) (values (car x) (cdr x)))
			(:arg list '((a . 2) (b . 6) (q . 4))))
		  (wb-custom-bag 'erapmoc (% 'a 2) (% 'b 6) (% 'q 4))))
    (test (equal? (gmap (:result bag-sum) nil (:arg list (list (bag 2 2 3 3 3 4) (bag 1 2 4))))
		  (bag 1 (% 2 3) (% 3 3) (% 4 2))))
    (test (equal? (gmap (:result bag-product) nil (:arg list (list (bag 2 2 3 3 3 4) (bag 1 2 2 4))))
		  (bag (% 2 4) 4)))

    (test (equal? (sort (gmap (:result list) #'cons (:arg map (map ('a 3) ('b 7) ('c 6)))) #'string< :key #'car)
		  '((a . 3) (b . 7) (c . 6))))
    (test (equal? (sort (gmap (:result list) #'cons (:arg fun-map (map ('a 3) ('b 7) ('c 6)))) #'string< :key #'car)
		  '((a . 3) (b . 7) (c . 6))))
    (test (equal? (gmap (:result list) #'cons (:arg wb-map (wb-map ('a 3) ('b 7) ('c 6))))
		  '((a . 3) (b . 7) (c . 6))))
    (test (equal? (sort (gmap (:result list) #'cons (:arg ch-map (ch-map ('a 3) ('b 7) ('c 6))))
			#'string< :key #'car)
		  '((a . 3) (b . 7) (c . 6))))
    (test (equal? (gmap (:result map) #'values (:arg list '(foo bar baz)) (:arg list '(12 17 91)))
		  (ch-map ('foo 12) ('bar 17) ('baz 91))))
    (test (equal? (gmap (:result wb-map) #'values (:arg list '(foo bar baz)) (:arg list '(12 17 91)))
		  (wb-map ('foo 12) ('bar 17) ('baz 91))))
    (test (equal? (gmap (:result ch-map) #'values (:arg list '(foo bar baz)) (:arg list '(12 17 91)))
		  (ch-map ('foo 12) ('bar 17) ('baz 91))))
    (test (equal? (gmap (:result map-union) nil (:arg list (list (map ('a 7) ('b 4)) (map ('c 8) ('a 11)))))
		  (ch-map ('a 11) ('b 4) ('c 8))))
    (test (equal? (gmap (:result map-intersection) nil (:arg list (list (map ('a 7) ('b 4)) (map ('c 8) ('a 11)))))
		  (ch-map ('a 11))))
    (test (equal? (gmap (:result map-to-sets) #'values
			(:arg list '(a b a b c a))
			(:arg list '(0 1 2 3 4 5)))
		  (ch-map ('a (ch-set 0 2 5)) ('b (ch-set 1 3)) ('c (ch-set 4)) :default (ch-set))))

    (test (equal? (gmap (:result list) nil (:arg seq (seq 3 'foo 99)))
		  '(3 foo 99)))
    (test (equal? (gmap (:result list) nil (:arg seq (seq 3 'foo 99 42 "hello" 'fizzbuzz)
						 :start 1 :end 5))
		  '(foo 99 42 "hello")))
    (test (equal? (gmap (:result list) nil (:arg seq (seq 3 'foo 99) :from-end? t))
		  '(99 foo 3)))
    (test (equal? (gmap (:result list) nil (:arg seq (seq 3 'foo 99 42 "hello" 'fizzbuzz)
						 :start 1 :end 5 :from-end? t))
		  '("hello" 42 99 foo)))
    (test (equal? (gmap (:result list) nil (:arg wb-seq (seq 3 'foo 99)))
		  '(3 foo 99)))
    (test (equal? (gmap (:result list) nil (:arg wb-seq (seq 3 'foo 99 42 "hello" 'fizzbuzz)
						 :start 1 :end 5))
		  '(foo 99 42 "hello")))
    (test (equal? (gmap (:result list) nil (:arg wb-seq (seq 3 'foo 99) :from-end? (> (get-universal-time) 1000000)))
		  '(99 foo 3)))
    (test (equal? (gmap (:result list) nil (:arg wb-seq (seq 3 'foo 99 42 "hello" 'fizzbuzz)
						 :start 1 :end 5 :from-end? (> (get-universal-time) 1000000)))
		  '("hello" 42 99 foo)))
    (test (equal? (gmap (:result seq :filterp #'integerp) nil (:arg list '(3 'bar 99)))
		  (seq 3 99)))
    (test (equal? (gmap (:result concat) nil (:arg list (list (seq 'now 'is) (seq 'the 'time))))
		  (seq 'now 'is 'the 'time)))))
