The fundamental reason that collection types should be pure is that if they're not,
you wind up with two notions of equality -- object identity and value equality --
that define the same object.


[2013.11.24]

I want to use this in SCA, so I'm (finally!) generifying it and giving it a thorough
once-over.

(x) Let's make 'with' able to extend the list by one element forward.

(x) Let's rename 'insert' to 'withInserted'; 'prepend' to 'withFirst'; 'append' to
'withLast'; 'delete' to 'less'.

(x) Let's let 'subList' throw 'IndexOutOfBoundsException' the same way 'List.subList'
does.

(x) Make sure the map types implement 'keySet' as well as 'domain'; they're now
synonyms, but I greatly prefer the set-theoretic term.  Similarly for 'values' and
'range'.

( ) Should 'range' with an initial set be changed to take a class object and a
comparator instance?  Also 'toSet', er, 'entrySet'.

( ) Add a 'PureMap.union' that takes a function to combine range values.  Also add
'PureMap.intersection' and 'PureMap.difference'.

(x) I think 'PureSet.arb' should throw an exception on the empty set -- it's more
Java-ish and consistent with the fact that sets can contain 'null'.

( ) Dumping the whole 'cacheEqual' thing.  Interesting idea, but I don't think I've
come across many algorithms that it would help on.

( ) Should introduce a static 'eql' function into each class that handles null,
and go through and un-beta-expand it.  [WIP: Pure{Tree,Hash}Set, PureTreeList done.]

( ) I have the opportunity to fix the partial/total map confusion that CL-FSet has,
though I'm not sure exactly how.  Well, in Java it makes a little sense for a partial
map to throw an exception for a key outside its domain.  (In CL I prefer to use the
second value instead.  Does this mean the second value should always be T for a total
map?  Maybe so.  Also, as I've previously noted, a total map should store only those
pairs whose second value is unequal to the default.  Ah, now I remember the big
quandary: what to do about 'domain' on a total map.  Hmm...  Okay, how about this.
We're not actually trying to hide the internal structure of a total map; it's defined
as a pair of a partial map and a default value.  We simply say the domain is
_defined_ to be the set of keys that are not mapped to the default value; it's an
abuse of the term "domain" (and maybe we should stick with "keySet", at least in
Java) but makes complete sense practically.)

( ) Could add set complements -- they're occasionally useful.

( ) Would be worth it to add @SuppressWarnings annotations in all the places
we're getting unchecked-cast warnings, but it's a pain because you have to
make a local variable declaration to hold the annotation.

( ) The map constructors from arrays need to be redesigned.  Have to think about
this.

( ) I decided 'subList' should throw 'IllegalArgumentException' when it was supposed
to -- since I have 'subseq' anyway, which doesn't -- but I still have 'subSet' and
'subMap' not throwing.  Not sure if I want to change this.

( ) Should port the iterator stack preallocation code from the CL version.

( ) Make sure we're doing the historically-related-trees optimization everywhere
appropriate.

( ) I've quickly come across use cases for 'image' and 'reduce' in SCA.

( ) The construct-then-use pattern is very common in SCA code.  My idea for mutating
the tree during construction, then doing functional updates after that, seems very
viable.

